<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kai Sticker Maker - Pro AI</title>
    <!-- External Libraries -->
    <script src="https://unpkg.com/konva@9.3.14/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Fonts and Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lobster&family=Pacifico&family=Playfair+Display:wght@700&family=Roboto+Slab:wght@400;700&family=Montserrat:wght@400;700&family=Lato:wght@400;700&family=Oswald:wght@400;700&family=Raleway:wght@400;700&family=Poppins:wght@400;600&family=Merriweather:wght@400;700&family=Dancing+Script:wght@400;700&family=Caveat&family=Bebas+Neue&family=Anton&display=swap" rel="stylesheet">
    
    <!-- STYLES -->
    <style>
        /* CSS Reset and Global Styles */
        :root {
            --bg-light: #f0f2f5;
            --bg-dark: #121212;
            --surface-light: #ffffff;
            --surface-dark: #1e1e1e;
            --primary: #4a90e2;
            --primary-light: #6aaaf2;
            --accent: #e91e63;
            --text-light: #212529;
            --text-dark: #e9ecef;
            --border-light: #dee2e6;
            --border-dark: #444444;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-family: 'Inter', sans-serif;
        }

        html { box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }

        body {
            margin: 0; padding: 0; font-family: var(--font-family); background-color: var(--bg-light);
            color: var(--text-light); display: flex; flex-direction: column; height: 100vh;
            overflow: hidden; transition: background-color 0.3s, color 0.3s;
            overscroll-behavior: none;
        }
        body.magic-wand-active .konvajs-content,
        body.crop-tool-active .konvajs-content,
        body.selection-tool-active .konvajs-content {
            cursor: crosshair;
        }
        body.multi-select-active .konvajs-content {
             cursor: crosshair;
        }
        body.magic-wand-active .konvajs-content {
            cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L9 9l-7 3 7 3 3 7 3-7 7-3-7-3-3-7z"/><path d="M22 22L12 12"/></svg>') 12 12, auto;
        }
        
        body.dark {
            --bg-light: var(--bg-dark); --surface-light: var(--surface-dark); --text-light: var(--text-dark);
            --border-light: var(--border-dark); --shadow-color: rgba(0, 0, 0, 0.4);
        }

        /* Top Bar */
        .top-bar {
            position: fixed; top: 0; left: 0; width: 100%;
            height: 42px; background-color: var(--surface-light);
            border-bottom: 1px solid var(--border-light); z-index: 999;
            display: flex; align-items: center; padding-right: 16px;
        }
        #sidebarToggleBtn {
            position: relative; top: 0; left: 0; width: 50px; height: 100%;
            border: none; border-right: 1px solid var(--border-light);
            background: none;
        }

        .tabs-container {
             flex-grow: 1; display: flex; flex-wrap: nowrap; overflow-x: auto;
             height: 100%; align-items: flex-end; padding: 0 5px;
        }
        .tab {
            display: flex; align-items: center; padding: 8px 12px; background-color: transparent;
            border: 1px solid transparent; border-bottom: none; border-radius: 8px 8px 0 0;
            margin-right: 4px; cursor: pointer; font-size: 14px; white-space: nowrap;
            transition: all 0.2s ease; position: relative; max-width: 150px;
            color: var(--text-light); opacity: 0.7; border-color: var(--border-light);
        }
        .tab:hover { background-color: var(--bg-light); opacity: 1;}
        .tab.active { background-color: var(--bg-light); font-weight: 600; opacity: 1; border-color: var(--border-light); }
        .tab-name { text-overflow: ellipsis; overflow: hidden; }
        .tab-close {
            margin-left: 8px; border-radius: 50%; width: 18px; height: 18px;
            display: flex; align-items: center; justify-content: center; font-size: 14px;
            line-height: 1; transition: background-color 0.2s;
        }
        .tab-close:hover { background-color: #ff5f57; color: white; }
        .new-tab-btn { padding: 8px; border: none; background: none; cursor: pointer; font-size: 20px; color: var(--text-light); line-height: 1;}
        
        /* Main Content Area */
        #main-content { display: flex; position: relative; height: 100vh; padding-top: 42px; }

        .canvas-area {
            flex-grow: 1; height: 100%;
            display: flex; justify-content: center; align-items: center;
            padding: 20px; overflow: hidden; background-color: var(--bg-light);
            cursor: default; transition: padding 0.3s ease;
        }
        #container { transition: transform 0.2s ease-out; will-change: transform; }
        .konvajs-content { box-shadow: 0 5px 20px rgba(0,0,0,0.15); background-color: white; }
        body.dark .konvajs-content { background-color: #2a2a2a; }

        /* Fullscreen Mode */
        body.fullscreen .top-bar, body.fullscreen .sidebar, body.fullscreen #propertiesSidebar { display: none; }
        body.fullscreen .canvas-area { padding: 0; width: 100% !important; }
        body.fullscreen #main-content { padding-top: 0; }
        
        /* UI container for floating buttons */
        .ui-container { position: fixed; top: 52px; right: 20px; z-index: 9999; display: flex; gap: 10px; }
        body.sidebar-visible .ui-container { right: 300px; }
        body.fullscreen .ui-container { top: 20px; }

        .ui-button {
            width: 44px; height: 44px; border-radius: 50%; background: var(--surface-light);
            border: 1px solid var(--border-light); box-shadow: 0 2px 8px var(--shadow-color);
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            color: var(--text-light); transition: all 0.2s ease;
        }
        .ui-button:hover, .ui-button.active { background: var(--primary); color: white; }
        .ui-button svg { width: 22px; height: 22px; stroke: currentColor; fill: none; stroke-width: 2; }
        .ui-button:disabled {
            cursor: not-allowed;
            opacity: 0.5;
            background: var(--surface-light);
            color: var(--text-light);
        }
        .ui-button:disabled:hover {
             background: var(--surface-light);
             color: var(--text-light);
        }
        
        /* Top Bar Controls */
        .top-controls {
            display: flex; align-items: center; gap: 16px; margin-left: auto;
        }
        .top-controls label { font-size: 14px; font-weight: 500; display: flex; align-items: center; gap: 8px;}
        .top-controls input[type="range"] {
             -webkit-appearance: none; appearance: none;
             width: 100px; height: 4px; background: var(--border-light);
             border-radius: 5px; outline: none; cursor: pointer;
        }
        .top-controls input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--primary);
            border-radius: 50%; cursor: pointer;
        }

        /* Sidebar Drawer (Left) */
        .sidebar {
            position: fixed; left: 0; top: 0; height: 100%; width: 280px; background-color: var(--surface-light);
            box-shadow: 4px 0 15px rgba(0,0,0,0.1); transform: translateX(-100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); z-index: 1000;
            padding: 20px; overflow-y: auto;
        }
        .sidebar.open { transform: translateX(0); }
        .sidebar h3 { font-size: 16px; font-weight: 600; margin-top: 0; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-light); }
        .sidebar-section { margin-bottom: 25px; }
        .sidebar label { display: block; margin-bottom: 8px; font-size: 14px; font-weight: 500; }
        .sidebar input, .sidebar select {
            width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light);
            background-color: var(--bg-light); color: var(--text-light); font-family: inherit;
        }
        .sidebar .button-group { display: flex; gap: 8px; }
        .sidebar .button-group button { flex: 1; padding: 8px; background: var(--bg-light); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .sidebar .button-group button:hover { background-color: var(--primary-light); color: white; border-color: var(--primary-light); }
        
        .sidebar-button {
            width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-light);
            border: 1px solid var(--border-light); border-radius: 6px; color: var(--text-light);
            font-weight: 500; font-size: 14px; text-align: left; cursor: pointer;
            display: flex; align-items: center; gap: 10px; transition: all 0.2s ease;
        }
        .sidebar-button:hover, .sidebar-button.active { background-color: var(--primary); color: white; border-color: var(--primary); }
        .sidebar-button svg { width: 20px; height: 20px; stroke-width: 2; }
        .sidebar-button.ai-button { background-color: var(--accent); color: white; border-color: var(--accent); }
        .sidebar-button.ai-button:hover { opacity: 0.9; }

        /* Properties Sidebar (Right) */
        #propertiesSidebar {
            width: 0; flex-shrink: 0; height: 100%;
            background-color: var(--surface-light);
            overflow: hidden;
            transition: width 0.3s ease;
            box-shadow: -2px 0 10px var(--shadow-color);
            display: flex; flex-direction: column;
        }
        #propertiesSidebar.visible { width: 280px; }
        #sidebarPlaceholder { padding: 20px; text-align: center; color: #aaa; font-style: italic; }
        #propertiesSidebar.visible #sidebarPlaceholder { display: none; }
        #propertiesSidebar:not(.visible) .menu-tabs, #propertiesSidebar:not(.visible) .menu-content { display: none; }

        .menu-tabs { display: flex; border-bottom: 1px solid var(--border-light); padding: 0 12px; flex-wrap: wrap;}
        .menu-tab { padding: 10px 12px; cursor: pointer; color: var(--text-light); opacity: 0.6; font-weight: 500; border-bottom: 2px solid transparent; }
        .menu-tab.active { opacity: 1; border-bottom: 2px solid var(--primary); }
        .menu-content { padding: 16px; overflow-y: auto; flex-grow: 1; font-size: 14px;}
        .tab-pane { display: none; }
        .tab-pane.active { display: block; animation: fadeIn 0.3s ease; }
        .control-group { margin-bottom: 16px; }
        .control-group label { font-weight: 500; margin-bottom: 8px; display: block; }
        .control-group input, .control-group select, .control-group textarea {
            width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light);
            background-color: var(--bg-light); color: var(--text-light); font-size: 14px;
            font-family: inherit;
        }
        .control-group textarea { min-height: 80px; resize: vertical; }
        .control-row { display: flex; align-items: center; gap: 8px; }
        .control-row input[type="color"] { padding: 0; height: 36px; border: none; background: none; }
        .control-row input[type="number"] { width: 70px; }
        .control-group .button-group { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .control-group .button-group button { padding: 8px; background: var(--bg-light); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .control-group .button-group button.active { background-color: var(--primary); color: white; }
        
        /* Adjust Pane New Styles */
        .control-group.collapsible { margin-bottom: 8px; border: 1px solid var(--border-light); border-radius: 4px; overflow: hidden; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; cursor: pointer; background-color: var(--bg-light); transition: background-color 0.2s; }
        .collapsible-header:hover { background-color: var(--border-light); }
        .collapsible-header label { margin-bottom: 0; flex-grow: 1; font-weight: 500; font-size: 13px; }
        .collapsible-header .value-display { font-weight: normal; color: #888; }
        body.dark .collapsible-header .value-display { color: #aaa; }
        .collapsible-header .reset-btn { background: none; border: none; cursor: pointer; padding: 2px; line-height: 1; opacity: 0.5; }
        .collapsible-header .reset-btn:hover { opacity: 1; color: var(--accent); }
        .collapsible-header .reset-btn svg { width: 14px; height: 14px; }
        .collapsible-content { display: none; padding: 12px; background-color: var(--surface-light); border-top: 1px solid var(--border-light); }
        .collapsible.active .collapsible-content { display: block; }
        .slider-container { display: flex; align-items: center; gap: 8px; }
        .adjust-btn { width: 28px; height: 28px; border: 1px solid var(--border-light); background-color: var(--bg-light); border-radius: 4px; font-weight: bold; cursor: pointer; }


        /* Modal Styles */
        .modal {
            display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.6); backdrop-filter: blur(5px); justify-content: center;
            align-items: center; animation: fadeIn 0.3s ease;
        }
        .modal-content {
            background-color: var(--surface-light); padding: 24px; border-radius: 12px;
            box-shadow: 0 10px 30px var(--shadow-color); width: 90%; max-width: 600px; max-height: 90vh;
            position: relative; display: flex; flex-direction: column; align-items: center;
        }
        .modal-content h2 { margin: 0 0 16px 0; font-weight: 600; color: var(--text-light); }
        #previewImage { max-width: 100%; max-height: calc(90vh - 100px); border: 1px solid var(--border-light); border-radius: 8px; background-color: white; }
        .close-modal { position: absolute; top: 15px; right: 20px; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s; color: #aaa; }
        .close-modal:hover { color: var(--text-light); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* AI Modal Specific Styles */
        .ai-prompt-container { width: 100%; }
        #aiImagePrompt { width: 100%; min-height: 80px; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); margin-bottom: 8px; }
        #generateImageBtn { width: 100%; padding: 10px; border-radius: 6px; border: none; background-color: var(--accent); color: white; font-weight: 600; cursor: pointer; }
        #aiImageResultContainer { margin-top: 16px; min-height: 100px; width: 100%; display: flex; justify-content: center; align-items: center; border: 1px dashed var(--border-light); border-radius: 8px; padding: 10px; }
        #aiGeneratedImage { max-width: 100%; max-height: 300px; border-radius: 4px; }
        #addAiImageToCanvasBtn { width: 100%; padding: 10px; border: none; background-color: var(--primary); color: white; border-radius: 6px; font-weight: 600; cursor: pointer; margin-top: 16px; }
        #imageDropzone {
            border: 2px dashed var(--border-light); border-radius: 8px; padding: 10px; text-align: center;
            cursor: pointer; transition: border-color 0.2s; min-height: 80px; display: flex;
            justify-content: center; align-items: center; margin-top: 16px; position: relative;
        }
        #imageDropzone:hover { border-color: var(--primary); }
        #imagePreview { max-width: 100%; max-height: 100px; border-radius: 4px; display: none; }
        #clearImageBtn {
            position: absolute; top: -10px; right: -10px; width: 24px; height: 24px; border-radius: 50%;
            background-color: var(--accent); color: white; border: none; cursor: pointer;
            font-weight: bold; display: none;
        }

        /* Toast Notification */
        .toast {
            position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #333;
            color: white; padding: 12px 20px; border-radius: 8px; z-index: 2000; visibility: hidden;
            opacity: 0; transition: opacity 0.3s, visibility 0.3s;
        }
        .toast.show { visibility: visible; opacity: 1; }
        .hidden-input { display: none; }
    </style>
</head>
<body>
    <div class="top-bar">
        <button id="sidebarToggleBtn" class="ui-button" title="Toggle Menu">
            <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
        </button>
        <div id="tabsContainer" class="tabs-container"></div>
        <!-- TOP BAR CONTROLS -->
        <div class="top-controls">
            <label for="zoomSlider">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                <input type="range" id="zoomSlider" min="0.1" max="5" value="1" step="0.01">
                <span id="zoomValue">100%</span>
            </label>
            <label for="rotationSlider">
                <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.49 15.01l-3.54 3.54-1.5-1.51"/><path d="M3.51 9a9 9 0 102.13 12.37"/></svg>
                <input type="range" id="rotationSlider" min="-180" max="180" value="0" step="1">
                <span id="rotationValue">0°</span>
            </label>
        </div>
    </div>
    
    <div id="main-content">
        <!-- CANVAS -->
        <div id="canvas-area" class="canvas-area">
            <div id="container"></div>
        </div>
         <!-- PROPERTIES SIDEBAR -->
        <div id="propertiesSidebar">
            <div id="sidebarPlaceholder">Select an item to see its properties.</div>
            <div class="menu-tabs">
                <div class="menu-tab active" data-tab="transform">Transform</div>
                <div class="menu-tab" data-tab="text" data-type="text">Text</div>
                <div class="menu-tab" data-tab="fill" data-type="text">Fill</div>
                <div class="menu-tab" data-tab="effects" data-type="text">Effects</div>
                <div class="menu-tab" data-tab="image" data-type="image">Image</div>
                <div class="menu-tab" data-tab="adjust" data-type="image">Adjust</div>
            </div>
            <div class="menu-content">
                <!-- Transform Pane -->
                <div class="tab-pane active" id="pane-transform">
                    <div class="control-group"><label for="selectionRotationSlider">Rotation</label><input type="range" id="selectionRotationSlider" min="-180" max="180" value="0" step="1"></div>
                    <div class="control-group"><label for="selectionZoomSlider">Scale</label><input type="range" id="selectionZoomSlider" min="0.1" max="10" value="1" step="0.01"></div>
                    <div class="control-group"><button id="deleteBtn" class="sidebar-button" style="background-color: #ff5f57; color: white; border-color: #ff5f57;">Delete</button></div>
                </div>
                <!-- Text Pane -->
                <div class="tab-pane" id="pane-text">
                    <div class="control-group">
                        <label for="text-content">Text Content</label>
                        <textarea id="textContent"></textarea>
                    </div>
                    <div class="control-group">
                        <label for="fontFamily">Font Family</label>
                        <select id="fontFamily">
                            <optgroup label="Web Safe">
                                <option value="Inter">Inter</option>
                                <option value="Arial">Arial</option>
                                <option value="Georgia">Georgia</option>
                            </optgroup>
                            <optgroup label="Display & Script">
                                <option value="Anton" style="font-family: 'Anton';">Anton</option>
                                <option value="Bebas Neue" style="font-family: 'Bebas Neue';">Bebas Neue</option>
                                <option value="Caveat" style="font-family: 'Caveat';">Caveat</option>
                                <option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option>
                                <option value="Lobster" style="font-family: 'Lobster';">Lobster</option>
                                <option value="Oswald" style="font-family: 'Oswald';">Oswald</option>
                                <option value="Pacifico" style="font-family: 'Pacifico';">Pacifico</option>
                            </optgroup>
                             <optgroup label="Serif">
                                <option value="Merriweather" style="font-family: 'Merriweather';">Merriweather</option>
                                <option value="Playfair Display" style="font-family: 'Playfair Display';">Playfair Display</option>
                                <option value="Roboto Slab" style="font-family: 'Roboto Slab';">Roboto Slab</option>
                            </optgroup>
                             <optgroup label="Sans-Serif">
                                <option value="Lato" style="font-family: 'Lato';">Lato</option>
                                <option value="Montserrat" style="font-family: 'Montserrat';">Montserrat</option>
                                <option value="Poppins" style="font-family: 'Poppins';">Poppins</option>
                                <option value="Raleway" style="font-family: 'Raleway';">Raleway</option>
                            </optgroup>
                        </select>
                    </div>
                    <div class="control-row">
                        <div class="control-group"><label for="fontSize">Size</label><input type="number" id="fontSize" value="32" min="1"></div>
                        <div class="control-group"><label>Style</label><div class="button-group"><button id="boldBtn"><b>B</b></button><button id="italicBtn"><i>I</i></button><button id="underlineBtn"><u>U</u></button></div></div>
                    </div>
                </div>
                <!-- Fill Pane -->
                <div class="tab-pane" id="pane-fill">
                    <div class="control-group"><label>Fill Type</label><select id="fillType"><option value="solid">Solid Color</option><option value="gradient">Linear Gradient</option></select></div>
                    <div id="solidFillOptions"><div class="control-group"><label for="fillColor">Color</label><input type="color" id="fillColor" value="#000000"></div></div>
                    <div id="gradientFillOptions" style="display:none;"><div class="control-group"><label>Colors</label><div class="control-row"><input type="color" id="gradientColor1" value="#ff0000"><input type="color" id="gradientColor2" value="#0000ff"></div></div><div class="control-group"><label for="gradientRotation">Angle</label><input type="range" id="gradientRotation" min="0" max="360" value="0" step="1"></div></div>
                </div>
                <!-- Effects Pane -->
                <div class="tab-pane" id="pane-effects">
                     <div class="control-group"><label>Stroke (Outline)</label><div class="control-row"><input type="color" id="strokeColor" value="#000000"><input type="number" id="strokeWidth" value="0" min="0" max="50"></div></div>
                    <div class="control-group"><label>Shadow</label><div class="control-row"><input type="color" id="shadowColor" value="#000000"><input type="number" id="shadowBlur" placeholder="Blur" value="0" min="0" max="50"></div><div class="control-row" style="margin-top: 8px;"><input type="number" id="shadowOffsetX" placeholder="X" value="0"><input type="number" id="shadowOffsetY" placeholder="Y" value="0"></div></div>
                </div>
                 <!-- Image Pane -->
                <div class="tab-pane" id="pane-image">
                    <div class="control-group">
                        <button id="selectionToolBtn" class="sidebar-button"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="16" y2="21"></line><line x1="3" y1="8" x2="21" y2="8"></line><line x1="3" y1="16" x2="21" y2="16"></line></svg><span>Selection Tool</span></button>
                        <button id="magicWandBtn" class="sidebar-button"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2L9 9l-7 3 7 3 3 7 3-7 7-3-7-3-3-7z"/><path d="M22 22L12 12"/></svg><span>Magic Wand</span></button>
                        <button id="cropToolBtn" class="sidebar-button"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path></svg><span>Crop Tool</span></button>
                    </div>
                    <div class="control-group" id="magicWandControls" style="display:none;">
                        <label for="magicWandTolerance">Tolerance: <span id="magicWandToleranceValue">20</span></label>
                        <input type="range" id="magicWandTolerance" min="0" max="255" value="20">
                        <label for="magicWandFeather" style="margin-top: 8px;">Feather: <span id="magicWandFeatherValue">0</span></label>
                        <input type="range" id="magicWandFeather" min="-50" max="50" value="0">
                        <div style="display: flex; align-items: center; margin-top: 8px;">
                            <input type="checkbox" id="magicWandContiguous" checked style="width: auto; margin-right: 8px;">
                            <label for="magicWandContiguous" style="margin-bottom: 0;">Contiguous</label>
                        </div>
                        <p style="font-size:12px; opacity:0.7; margin-top:8px;">Click a color on the image to remove it. Adjust sliders to refine. Press Esc to cancel.</p>
                    </div>
                </div>
                <!-- Adjust Pane -->
                <div class="tab-pane" id="pane-adjust">
                    <div class="control-group">
                        <button id="resetAllAdjustmentsBtn" class="sidebar-button">Reset All Adjustments</button>
                    </div>
                    <div id="adjustmentsContainer"></div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- FLOATING UI BUTTONS -->
    <div class="ui-container">
        <button id="multiSelectToolBtn" class="ui-button" title="Selection Tool (V)">
            <svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
               <path stroke="none" d="M0 0h24v24H0z" fill="none"></path>
               <path d="M9 12l-6 -9l18 6l-10 4l-4 10z"></path>
            </svg>
        </button>
        <button id="undoBtn" class="ui-button" title="Undo (Ctrl+Z)">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.38 11.23 17.28 8 12.5 8z"></path></svg>
        </button>
        <button id="redoBtn" class="ui-button" title="Redo (Ctrl+Y)">
            <svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.78 0-8.88 3.23-9.87 7.5l-2.37-.78C.22 10.23 4.31 6 9.5 6c2.65 0 5.05.99 6.9 2.6L20 5v9h-9l3.62-3.62z"></path></svg>
        </button>
        <button id="centerViewBtn" class="ui-button" title="Center View">
            <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="3"/></svg>
        </button>
        <button id="fullscreenToggleBtn" class="ui-button" title="Toggle Fullscreen">
            <svg id="maximizeIcon" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>
            <svg id="minimizeIcon" style="display: none;" viewBox="0 0 24 24"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>
        </button>
        <button id="themeToggle" class="ui-button" title="Toggle Theme">
             <svg id="themeIconSun" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>
             <svg id="themeIconMoon" style="display: none;" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
        </button>
    </div>

    <!-- LEFT SIDEBAR -->
    <div id="sidebar" class="sidebar"></div>
    
    <input type="file" id="fileInput" accept="image/*" multiple class="hidden-input">
    <input type="file" id="loadProjectInput" accept=".json" class="hidden-input">
    <input type="file" id="aiImageInput" accept="image/*" class="hidden-input">
    
    <!-- MODALS -->
    <div id="previewModal" class="modal">
        <div class="modal-content">
            <span id="closePreview" class="close-modal">&times;</span>
            <h2>Finished Product Preview</h2>
            <img id="previewImage" src="" alt="Preview of your design">
        </div>
    </div>

    <div id="aiImageModal" class="modal">
        <div class="modal-content">
            <span id="closeAiImageModal" class="close-modal">&times;</span>
            <h2>✨ AI Image Studio</h2>
            <div class="ai-prompt-container">
                <textarea id="aiImagePrompt" placeholder="Describe the image you want to create..."></textarea>
                <button id="generateImageBtn">Generate</button>
            </div>
             <div id="imageDropzone">
                <span id="dropzoneText">Optional: Drop image to edit</span>
                <img id="imagePreview" src="" alt="Preview"/><button id="clearImageBtn">&times;</button>
            </div>
            <div id="aiImageResultContainer">
                <div id="aiImageLoader" style="display: none;">Generating...</div>
                <img id="aiGeneratedImage" src="" alt="AI Generated Image" style="display:none;">
            </div>
            <button id="addAiImageToCanvasBtn" style="display:none;">Add to Canvas</button>
        </div>
    </div>

    <div id="toast" class="toast"></div>
    
    <!-- JAVASCRIPT LOGIC -->
    <script type="module">
        window.onload = function() {
            // Utility to debounce function calls for performance
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            class CanvasManager {
                constructor(containerId) {
                    this.containerId = containerId;
                    this.container = document.getElementById(containerId);
                    this.stage = null; this.layer = null; this.gridLayer = null; this.watermarkLayer = null; this.tr = null;
                    this.selectedNodes = [];
                    this.clipboardNodes = [];
                    this.history = [];
                    this.historyStep = -1;
                    this.isMagicWandActive = false;
                    this.isCropToolActive = false;
                    this.isSelectionToolActive = false;
                    this.isMultiSelectActive = false;
                    this.selectionRectangle = null;
                    this.cropRect = null;
                    this.selectionRect = null;
                    this.drawingLayer = null;
                    this.gridSize = 20; this.DPI = 96; this.isLandscape = true;
                    this.rotation = 0; this.zoom = 1; this.offsetX = 0; this.offsetY = 0;
                    this.canvasSizes = {
                        '1080p': { isPx: true, width: 1920, height: 1080 },
                        '4k': { isPx: true, width: 3840, height: 2160 },
                        'letter': { width: 8.5, height: 11 }, 'a4': { width: 8.27, height: 11.69 }, 'legal': { width: 8.5, height: 14 },
                        'tabloid': { width: 11, height: 17 }, 
                        'ig_square': { isPx: true, width: 1080, height: 1080 },
                        'ig_story': { isPx: true, width: 1080, height: 1920 }, 'twitter': { isPx: true, width: 1600, height: 900 },
                        'facebook': { isPx: true, width: 1200, height: 630 },
                    };
                    this._transformState = { node: null, lastDist: 0, startTouchAngle: 0, startNodeRotation: 0 };
                    this._panState = { isPanning: false, startX: 0, startY: 0, initialOffsetX: 0, initialOffsetY: 0, initialRotation: 0, initialZoom: 1, mode: '' };
                    this.debouncedApplyAdjustments = debounce(this.applyAdjustments.bind(this), 250);
                    this._initGlobalCanvasMouseListeners();
                }

                _initGlobalCanvasMouseListeners() {
                    const canvasArea = document.getElementById('canvas-area');
                    this._boundStartCanvasInteraction = this._startCanvasInteraction.bind(this);
                    this._boundMoveCanvasInteraction = this._moveCanvasInteraction.bind(this);
                    this._boundEndCanvasInteraction = this._endCanvasInteraction.bind(this);
                    canvasArea.addEventListener('mousedown', (e) => { if (e.target === canvasArea) this._boundStartCanvasInteraction(e); });
                    canvasArea.addEventListener('touchstart', (e) => { if (e.target === canvasArea) this._boundStartCanvasInteraction(e); }, { passive: false });
                    window.addEventListener('mousemove', this._boundMoveCanvasInteraction);
                    window.addEventListener('mouseup', this._boundEndCanvasInteraction);
                    window.addEventListener('touchmove', this._boundMoveCanvasInteraction, { passive: false });
                    window.addEventListener('touchend', this._boundEndCanvasInteraction);
                }

                _startCanvasInteraction(e) {
                    if (this.isCropToolActive || this.isSelectionToolActive || this.isMultiSelectActive) return;
                    const nativeEvent = e.evt || e;
                    nativeEvent.preventDefault();
                    const touches = nativeEvent.touches;
                    if (touches) {
                        if (touches.length === 1) { this._panState.mode = 'pan'; this._panState.startX = touches[0].clientX; this._panState.startY = touches[0].clientY; this._panState.initialOffsetX = this.offsetX; this._panState.initialOffsetY = this.offsetY; } 
                        else if (touches.length >= 2) { this._panState.mode = 'zoom-rotate'; this._transformState.lastDist = this.getTouchDistance(touches); this._transformState.startTouchAngle = this.getTouchAngle(touches); this._transformState.startNodeRotation = this.rotation; }
                    } else {
                        this._panState.mode = nativeEvent.altKey ? 'rotate-zoom' : 'pan'; this._panState.startX = nativeEvent.clientX; this._panState.startY = nativeEvent.clientY;
                        this._panState.initialOffsetX = this.offsetX; this._panState.initialOffsetY = this.offsetY; this._panState.initialRotation = this.rotation; this._panState.initialZoom = this.zoom;
                        document.getElementById('canvas-area').style.cursor = 'grabbing';
                    }
                    this._panState.isPanning = true;
                }

                _moveCanvasInteraction(e) {
                    if (!this._panState.isPanning) return;
                    const nativeEvent = e.evt || e; nativeEvent.preventDefault();
                    const touches = nativeEvent.touches;
                    if (touches) {
                        if (touches.length === 1 && this._panState.mode === 'pan') { const dx = touches[0].clientX - this._panState.startX; const dy = touches[0].clientY - this._panState.startY; this.offsetX = this._panState.initialOffsetX + dx; this.offsetY = this._panState.initialOffsetY + dy; } 
                        else if (touches.length >= 2 && this._panState.mode === 'zoom-rotate') { const newDist = this.getTouchDistance(touches); const newAngle = this.getTouchAngle(touches); this.setZoom(this.zoom * (newDist / this._transformState.lastDist)); this.setRotation(this._transformState.startNodeRotation + (newAngle - this._transformState.startTouchAngle)); this._transformState.lastDist = newDist; }
                    } else {
                        const dx = nativeEvent.clientX - this._panState.startX; const dy = nativeEvent.clientY - this._panState.startY;
                        if (this._panState.mode === 'pan') { this.offsetX = this._panState.initialOffsetX + dx; this.offsetY = this._panState.initialOffsetY + dy; } 
                        else if (this._panState.mode === 'rotate-zoom') { this.setRotation(this._panState.initialRotation - dy * 0.2); this.setZoom(this._panState.initialZoom + dx * 0.005); }
                    }
                    this.updateContainerTransform();
                }

                _endCanvasInteraction() { if (this._panState.isPanning) { this._panState.isPanning = false; this._panState.mode = ''; document.getElementById('canvas-area').style.cursor = 'default'; } }
                getTouchDistance(touches) { const [t1, t2] = touches; return Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2)); }
                getTouchAngle(touches) { const [t1, t2] = touches; return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * 180 / Math.PI; }

                _createTransformer() {
                    return new Konva.Transformer({
                        anchorStroke: '#4a90e2', anchorFill: 'white', anchorSize: 10, borderStroke: '#4a90e2',
                        borderDash: [4, 4], rotateAnchorOffset: 30, centeredScaling: true,
                        boundBoxFunc: (oldBox, newBox) => {
                            const node = this.tr.nodes()[0];
                            if (!node || this.tr.nodes().length > 1) return newBox;
                            const activeAnchor = this.tr.getActiveAnchor();
                            const isSide = ['middle-left', 'middle-right', 'top-center', 'bottom-center'].includes(activeAnchor);
                            
                            if (node instanceof Konva.Image && isSide) {
                                const stage = node.getStage();
                                const pointerPos = stage.getPointerPosition();
                                if (!pointerPos) return oldBox;

                                const center = node.getAbsolutePosition();
                                const angleRad = Math.atan2(pointerPos.y - center.y, pointerPos.x - center.x);
                                const startAngle = node.getAttr('transformStartAngle');
                                const initialRotation = node.getAttr('transformInitialRotation');

                                if (startAngle !== undefined && initialRotation !== undefined) {
                                     const rotationDiff = angleRad - startAngle;
                                     node.rotation(initialRotation + Konva.Util.radToDeg(rotationDiff));
                                }
                                return oldBox;
                            }
                            return newBox;
                        }
                    });
                }

                initStage(width, height) {
                    if(this.stage) this.stage.destroy();
                    this.stage = new Konva.Stage({ container: this.containerId, width: width, height: height });
                    this.stage.container().style.backgroundColor = document.body.classList.contains('dark') ? '#2a2a2a' : 'white';
                    this.layer = new Konva.Layer({ id: 'main-layer' }); this.gridLayer = new Konva.Layer({ id: 'grid-layer' });
                    this.watermarkLayer = new Konva.Layer({ id: 'watermark-layer', listening: false });
                    this.stage.add(this.gridLayer, this.layer, this.watermarkLayer);
                    this.tr = this._createTransformer();
                    this.layer.add(this.tr); this.drawGrid(); this.addWatermark(); this.attachStageListeners(); this.centerView();
                    this.saveHistory();
                }

                attachStageListeners() { 
                    this.stage.on('click tap', (e) => this.handleSelect(e)); 
                    document.getElementById('canvas-area').addEventListener('wheel', (e) => this.handleWheelZoom(e), { passive: false });
                    this.stage.on('mousedown touchstart', (e) => { if (e.target === this.stage) this._startCanvasInteraction(e); });
                    this.stage.on('touchstart', (e) => {
                        e.evt.preventDefault(); const touches = e.evt.touches;
                        if (touches.length >= 2) {
                            const target = e.target.getDraggable() ? e.target : e.target.getParent();
                            if (target && target !== this.stage && this.selectedNodes.includes(target)) {
                                 this._transformState.node = target; this.tr.hide(); this.layer.draw();
                                 this._transformState.startNodeRotation = this._transformState.node.rotation();
                                 this._transformState.startTouchAngle = this.getTouchAngle(touches);
                            } else { this._transformState.node = null; }
                            this._transformState.lastDist = this.getTouchDistance(touches);
                        }
                    });
                    this.stage.on('touchmove', (e) => {
                        e.evt.preventDefault(); const touches = e.evt.touches; if (touches.length < 2) return;
                        if (this._transformState.node) {
                            const node = this._transformState.node; const newDist = this.getTouchDistance(touches);
                            const scaleRatio = newDist / this._transformState.lastDist; node.scale({ x: node.scaleX() * scaleRatio, y: node.scaleY() * scaleRatio });
                            const newAngle = this.getTouchAngle(touches); const angleDelta = newAngle - this._transformState.startTouchAngle;
                            node.rotation(this._transformState.startNodeRotation + angleDelta); this.layer.batchDraw();
                            this._transformState.lastDist = newDist;
                        }
                    });
                    this.stage.on('touchend', (e) => { if (this._transformState.node) { this.tr.nodes([this._transformState.node]); this.tr.show(); this.layer.draw(); } this._transformState.node = null; });
                }
                
                setCanvasSize(sizeKey) {
                    const size = this.canvasSizes[sizeKey]; let w = size.isPx ? size.width : Math.round(size.width * this.DPI);
                    let h = size.isPx ? size.height : Math.round(size.height * this.DPI);
                    this.canvasWidth = this.isLandscape ? Math.max(w,h) : Math.min(w,h);
                    this.canvasHeight = this.isLandscape ? Math.min(w,h) : Math.max(w,h);
                    this.initStage(this.canvasWidth, this.canvasHeight);
                }

                drawGrid() {
                    this.gridLayer.destroyChildren(); const stroke = document.body.classList.contains('dark') ? '#495057' : '#e9ecef';
                    for (let i = 0; i < this.canvasWidth / this.gridSize; i++) { this.gridLayer.add(new Konva.Line({ points: [Math.round(i * this.gridSize) + 0.5, 0, Math.round(i * this.gridSize) + 0.5, this.canvasHeight], stroke: stroke, strokeWidth: 1, listening: false })); }
                    for (let j = 0; j < this.canvasHeight / this.gridSize; j++) { this.gridLayer.add(new Konva.Line({ points: [0, Math.round(j * this.gridSize) + 0.5, this.canvasWidth, Math.round(j * this.gridSize) + 0.5], stroke: stroke, strokeWidth: 1, listening: false })); }
                    this.gridLayer.batchDraw();
                }

                addWatermark() {
                    this.watermarkLayer.destroyChildren(); const text = 'Kaiser'; const fontSize = 60; const fontFamily = 'Georgia, serif';
                    const fill = document.body.classList.contains('dark') ? '#ffffff' : '#000000';
                    const textNode = new Konva.Text({ text, fontSize, fontFamily });
                    const textWidth = textNode.width(); const textHeight = textNode.height();
                    const gapX = textWidth * 1.5; const gapY = textHeight * 2;
                    for (let y = -textHeight; y < this.stage.height() + gapY; y += gapY) {
                        for (let x = -textWidth; x < this.stage.width() + gapX; x += gapX) {
                            this.watermarkLayer.add(new Konva.Text({ x: x, y: y, text, fontSize, fontFamily, fill, opacity: 0.08, rotation: -20, }));
                        }
                    } this.watermarkLayer.batchDraw();
                }

                _bindNodeEvents(node) {
                    if (!node) return;
                    // Use namespaces to safely remove/add events without interfering with others
                    node.off('.events');

                    if (node.draggable()) {
                        node.on('dragmove.events transform.events', () => this.snapToGrid(node));
                        node.on('dragend.events transformend.events', () => this.saveHistory());
                    }

                    if (node instanceof Konva.Text) {
                        node.on('dblclick.events dbltap.events', () => this.editText(node));
                    }
                    
                    // Add listeners needed for custom rotation on side handles for images
                    node.on('transformstart.events', () => {
                        const stage = node.getStage();
                        if (!stage) return;
                        const pointerPos = stage.getPointerPosition();
                        if (!pointerPos) return;

                        const center = node.getAbsolutePosition();
                        node.setAttr('transformStartAngle', Math.atan2(pointerPos.y - center.y, pointerPos.x - center.x));
                        node.setAttr('transformInitialRotation', node.rotation());
                    });
                    
                    node.on('transformend.events', () => {
                        node.setAttr('transformStartAngle', undefined);
                        node.setAttr('transformInitialRotation', undefined);
                    });
                }

                addImage(src, index = 0, attrs = {}) {
                    Konva.Image.fromURL(src, (img) => {
                        const defaultAttrs = { x: this.stage.width()/2, y: this.stage.height()/2, draggable: true, name: 'image', id: 'img_' + crypto.randomUUID() };
                        const finalAttrs = { ...defaultAttrs, ...attrs };
                        img.setAttrs(finalAttrs);

                         if (!attrs.width && !attrs.height) { // Only scale if not already sized
                            const maxDim = Math.min(this.canvasWidth, this.canvasHeight) * 0.4;
                            const scale = maxDim / Math.max(img.width(), img.height());
                            if (scale < 1) img.scale({ x: scale, y: scale });
                        }
                        
                        img.offsetX(img.width() / 2); img.offsetY(img.height() / 2);
                        img.x(finalAttrs.x); img.y(finalAttrs.y);
                        this.layer.add(img);
                        this._bindNodeEvents(img);
                        this.applyAdjustments(img);
                        this.saveHistory();
                    }, { crossOrigin: 'Anonymous' });
                }

                addText(text = 'Double-click to edit') {
                    const textNode = new Konva.Text({ text, x: 50, y: 50, fontSize: 32, fontFamily: 'Inter', fill: document.body.classList.contains('dark') ? '#e9ecef' : '#212529', draggable: true, });
                    textNode.offsetX(textNode.width() / 2); textNode.offsetY(textNode.height() / 2);
                    textNode.x(textNode.x() + textNode.width() / 2); textNode.y(textNode.y() + textNode.height() / 2);
                    this.layer.add(textNode);
                    this._bindNodeEvents(textNode);
                    this.layer.draw(); 
                    this.saveHistory();
                    return textNode;
                }

                editText(textNode) {
                    textNode.hide(); this.tr.hide(); this.layer.draw(); uiManager.hidePropertiesSidebar();
                    const textPosition = textNode.absolutePosition(); const stageBox = this.stage.container().getBoundingClientRect();
                    const areaPosition = { x: stageBox.left + textPosition.x, y: stageBox.top + textPosition.y, };
                    const textarea = document.createElement('textarea'); document.body.appendChild(textarea);
                    Object.assign(textarea.style, { position: 'absolute', top: areaPosition.y + 'px', left: areaPosition.x + 'px', width: textNode.width() * textNode.scaleX() + 'px', height: textNode.height() * textNode.scaleY() + 'px', fontSize: textNode.fontSize() * textNode.scaleY() + 'px', border: '1px solid #4a90e2', padding: '0px', margin: '0px', overflow: 'hidden', background: 'white', outline: 'none', resize: 'none', lineHeight: textNode.lineHeight(), fontFamily: textNode.fontFamily(), transformOrigin: 'left top', transform: `rotateZ(${this.rotation + textNode.rotation()}deg) scale(${this.zoom})`, textAlign: textNode.align(), color: textNode.fill(), zIndex: 1002, });
                    textarea.value = textNode.text(); textarea.focus();
                    const removeTextarea = () => { if(document.body.contains(textarea)) { 
                        textNode.text(textarea.value); textNode.offsetX(textNode.width() / 2); textNode.offsetY(textNode.height() / 2); textNode.show(); 
                        this.tr.show(); this.layer.draw(); uiManager.showPropertiesSidebar(textNode); document.body.removeChild(textarea); 
                        this.saveHistory();
                        window.removeEventListener('click', handleOutsideClick); 
                    } };
                    textarea.addEventListener('keydown', (e) => { if (e.key === 'Escape' || (e.key === 'Enter' && !e.shiftKey)) {e.preventDefault(); removeTextarea();} });
                    const handleOutsideClick = (e) => { if (e.target !== textarea) { removeTextarea(); } };
                    setTimeout(() => window.addEventListener('click', handleOutsideClick), 0);
                }

                snapToGrid(node) { node.position({ x: Math.round(node.x() / this.gridSize) * this.gridSize, y: Math.round(node.y() / this.gridSize) * this.gridSize }); this.layer.batchDraw(); }
                
                handleSelect(e) {
                    if (this.isMultiSelectActive || this.isCropToolActive || this.isSelectionToolActive) { return; }
                    
                    const target = e.target;
                    if (this.isMagicWandActive) {
                        if (target === this.selectedNodes[0]) { this.applyMagicWand(target); return; } 
                        else { this.exitMagicWandMode(); }
                    }

                    if (target.getParent() instanceof Konva.Transformer) return;
                    
                    const isCtrlPressed = e.evt.ctrlKey || e.evt.metaKey;

                    if (target === this.stage) {
                        this.selectedNodes.forEach(node => this.commitMagicWand(node));
                        this.tr.nodes([]); this.selectedNodes = []; uiManager.hidePropertiesSidebar();
                    } else {
                        const node = target.getDraggable() ? target : target.getParent();
                        if (node && !(node instanceof Konva.Transformer)) {
                             const isSelected = this.selectedNodes.includes(node);
                             if (isCtrlPressed) {
                                if (isSelected) {
                                    this.selectedNodes = this.selectedNodes.filter(n => n !== node);
                                } else {
                                    this.selectedNodes.push(node);
                                }
                             } else {
                                if (!isSelected) {
                                    this.selectedNodes.forEach(oldNode => this.commitMagicWand(oldNode));
                                    this.selectedNodes = [node];
                                }
                             }

                            // Bring all selected nodes to the front
                            this.selectedNodes.forEach(n => n.moveToTop());

                            if (this.selectedNodes.length === 1) {
                                if (this.selectedNodes[0] instanceof Konva.Image) {
                                    this.tr.keepRatio(true);
                                    this.tr.rotateEnabled(false);
                                    this.tr.enabledAnchors(['top-left', 'top-right', 'bottom-left', 'bottom-right', 'middle-left', 'middle-right', 'top-center', 'bottom-center']);
                                } else {
                                    this.tr.keepRatio(false);
                                    this.tr.rotateEnabled(true);
                                    this.tr.enabledAnchors(undefined);
                                }
                                uiManager.showPropertiesSidebar(this.selectedNodes[0]);
                            } else {
                                this.tr.keepRatio(true);
                                this.tr.rotateEnabled(true);
                                this.tr.enabledAnchors(undefined); // Use default for multi-select
                                if (this.selectedNodes.length > 1) {
                                    uiManager.hidePropertiesSidebar();
                                } else {
                                    uiManager.showPropertiesSidebar(this.selectedNodes[0]);
                                }
                            }
                            this.tr.nodes(this.selectedNodes);
                        }
                    }
                    this.layer.draw();
                }
                
                handleWheelZoom(e) { e.preventDefault(); this.setZoom(e.deltaY > 0 ? this.zoom / 1.1 : this.zoom * 1.1); }
                centerView() { this.setZoom(1); this.setRotation(0); this.offsetX = 0; this.offsetY = 0; this.updateContainerTransform(); }
                updateContainerTransform() { this.container.style.transform = `translateX(${this.offsetX}px) translateY(${this.offsetY}px) rotate(${this.rotation}deg) scale(${this.zoom})`; }
                setRotation(deg) { this.rotation = Math.max(-180, Math.min(deg, 180)); this.updateContainerTransform(); uiManager.updateRotationSlider(this.rotation); }
                setZoom(scale) { this.zoom = Math.max(0.1, Math.min(scale, 5)); this.updateContainerTransform(); uiManager.updateZoomSlider(this.zoom); }

                updateNodeProperty(prop, value) {
                    if (this.selectedNodes.length !== 1) return;
                    const node = this.selectedNodes[0];
                    if (prop === 'scale') { node.scale({ x: value, y: value }); } 
                    else if (prop === 'rotation') { node.rotation(value); }
                    else if (node instanceof Konva.Text) {
                        let fontStyle = node.fontStyle() || '';
                        switch (prop) {
                            case 'text': node.text(value); break;
                            case 'fontFamily': node.fontFamily(value); break;
                            case 'fontSize': node.fontSize(parseInt(value)); break;
                            case 'fill': node.fill(value); node.fillPriority('color'); break;
                            case 'bold': fontStyle = fontStyle.includes('bold') ? fontStyle.replace('bold', '').trim() : `bold ${fontStyle}`.trim(); node.fontStyle(fontStyle); break;
                            case 'italic': fontStyle = fontStyle.includes('italic') ? fontStyle.replace('italic', '').trim() : `italic ${fontStyle}`.trim(); node.fontStyle(fontStyle); break;
                            case 'underline': node.textDecoration(node.textDecoration() === 'underline' ? '' : 'underline'); break;
                            case 'stroke': node.stroke(value); break;
                            case 'strokeWidth': node.strokeWidth(parseInt(value)); break;
                            case 'shadowColor': node.shadowColor(value); break;
                            case 'shadowBlur': node.shadowBlur(parseInt(value)); break;
                            case 'shadowOffsetX': node.shadowOffsetX(parseInt(value)); break;
                            case 'shadowOffsetY': node.shadowOffsetY(parseInt(value)); break;
                            case 'gradient':
                                node.fillPriority('linear-gradient');
                                const angle = value.angle * (Math.PI / 180);
                                const radius = Math.max(node.width(), node.height()) / 2;
                                node.fillLinearGradientStartPoint({ x: -Math.cos(angle) * radius, y: -Math.sin(angle) * radius });
                                node.fillLinearGradientEndPoint({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
                                node.fillLinearGradientColorStops([0, value.color1, 1, value.color2]);
                                break;
                        }
                        node.offsetX(node.width() / 2); node.offsetY(node.height() / 2);
                    }
                    this.layer.batchDraw();
                }
                
                toggleMagicWandMode() {
                    if (this.isMagicWandActive) {
                        // --- EXIT LOGIC ---
                        this.isMagicWandActive = false;
                        document.body.classList.remove('magic-wand-active');
                        document.getElementById('magicWandBtn').classList.remove('active');
                        this.selectedNodes.forEach(node => this.commitMagicWand(node));
                        if (this.selectedNodes.length > 0 && this.selectedNodes[0].draggable() === false) {
                            this.selectedNodes[0].draggable(true);
                            this.tr.nodes(this.selectedNodes);
                            this.tr.show();
                            this.layer.draw();
                        }
                    } else {
                        // --- ENTER LOGIC ---
                        this.exitAllToolModes();
                        if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) {
                            uiManager.showToast('Please select a single image first.');
                            return;
                        }
                        this.isMagicWandActive = true;
                        document.body.classList.add('magic-wand-active');
                        document.getElementById('magicWandBtn').classList.add('active');
                        uiManager.showToast('Magic Wand active. Click a color to remove.');
                        this.tr.hide();
                        this.selectedNodes[0].draggable(false);
                        this.layer.draw();
                    }
                }

                exitMagicWandMode() { if (this.isMagicWandActive) { this.toggleMagicWandMode(); } }
                
                commitMagicWand(node) {
                    if (node && node.getAttr('originalImage')) {
                        node.setAttr('originalImage', null);
                        node.setAttr('magicWandParams', null);
                        this.saveHistory();
                    }
                }

                updateMagicWandLive() {
                    if (this.selectedNodes.length !== 1) return;
                    const node = this.selectedNodes[0];
                    const params = node.getAttr('magicWandParams');
                    if (!params) return;

                    params.tolerance = parseInt(document.getElementById('magicWandTolerance').value, 10);
                    params.feather = parseInt(document.getElementById('magicWandFeather').value, 10);
                    params.isContiguous = document.getElementById('magicWandContiguous').checked;

                    node.setAttr('magicWandParams', params);
                    this._performMagicWandProcessing(node);
                }

                _getMagicWandSelection(imageData, width, height, tolerance, isContiguous, startX, startY) {
                    const { data } = imageData;
                    const pixelsToRemove = new Array(width * height).fill(false);
                    const startIndex = (startY * width + startX) * 4;
                    const startR = data[startIndex]; const startG = data[startIndex + 1]; const startB = data[startIndex + 2];

                    if (isContiguous) {
                        const pixelStack = [[startX, startY]];
                        const visited = new Array(width * height).fill(false);
                        while (pixelStack.length > 0) {
                            const [x, y] = pixelStack.pop();
                            const index = y * width + x;
                            if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) { continue; }
                            const dataIndex = index * 4;
                            const r = data[dataIndex]; const g = data[dataIndex + 1]; const b = data[dataIndex + 2];
                            const colorDistance = Math.sqrt(Math.pow(r - startR, 2) + Math.pow(g - startG, 2) + Math.pow(b - startB, 2));
                            visited[index] = true;
                            if (colorDistance <= tolerance) {
                                pixelsToRemove[index] = true;
                                pixelStack.push([x + 1, y]); pixelStack.push([x - 1, y]); pixelStack.push([x, y + 1]); pixelStack.push([x, y - 1]);
                            }
                        }
                    } else {
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i]; const g = data[i + 1]; const b = data[i + 2];
                            const colorDistance = Math.sqrt(Math.pow(r - startR, 2) + Math.pow(g - startG, 2) + Math.pow(b - startB, 2));
                            if (colorDistance <= tolerance) { pixelsToRemove[i / 4] = true; }
                        }
                    }
                    return pixelsToRemove;
                }
                
                async _performMagicWandProcessing(node) {
                    const originalImage = node.getAttr('originalImage');
                    const params = node.getAttr('magicWandParams');
                    if (!originalImage || !params) return;

                    const { startX, startY, tolerance, isContiguous, feather } = params;
                    const imageEl = originalImage;
                    const width = imageEl.naturalWidth || imageEl.width;
                    const height = imageEl.naturalHeight || imageEl.height;

                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(imageEl, 0, 0, width, height);
                    const imageData = tempCtx.getImageData(0, 0, width, height);
                    const pixelsToRemove = this._getMagicWandSelection(imageData, width, height, tolerance, isContiguous, startX, startY);
                    const { data } = imageData;

                    if (feather > 0) {
                        const distanceMap = new Array(width * height).fill(-1);
                        const queue = [];
                        for (let i = 0; i < pixelsToRemove.length; i++) { if (!pixelsToRemove[i]) { distanceMap[i] = 0; queue.push([i % width, Math.floor(i / width)]); } }
                        let head = 0; const dx = [0, 0, 1, -1]; const dy = [1, -1, 0, 0];
                        while(head < queue.length) {
                            const [x, y] = queue[head++]; const dist = distanceMap[y * width + x]; if (dist >= feather) continue;
                            for(let i = 0; i < 4; i++) {
                                const nx = x + dx[i]; const ny = y + dy[i];
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIndex = ny * width + nx;
                                    if (distanceMap[nIndex] === -1) { distanceMap[nIndex] = dist + 1; queue.push([nx, ny]); }
                                }
                            }
                        }
                        for (let i = 0; i < pixelsToRemove.length; i++) {
                            if (pixelsToRemove[i]) {
                                const dist = distanceMap[i]; const dataIndex = i * 4;
                                if (dist === -1 || dist > feather) { data[dataIndex + 3] = 0; } 
                                else { data[dataIndex + 3] = Math.floor(data[dataIndex + 3] * (dist / feather)); }
                            }
                        }
                    } else if (feather < 0) {
                        const chokeAmount = Math.abs(feather);
                        const distanceMap = new Array(width * height).fill(-1);
                        const queue = [];
                        for (let i = 0; i < pixelsToRemove.length; i++) {
                            if (pixelsToRemove[i]) {
                                distanceMap[i] = 0;
                                queue.push([i % width, Math.floor(i / width)]);
                            }
                        }
                        let head = 0; const dx = [0, 0, 1, -1]; const dy = [1, -1, 0, 0];
                        while (head < queue.length) {
                            const [x, y] = queue[head++]; const dist = distanceMap[y * width + x];
                            if (dist >= chokeAmount) continue;
                            for (let i = 0; i < 4; i++) {
                                const nx = x + dx[i]; const ny = y + dy[i];
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                                    const nIndex = ny * width + nx;
                                    if (distanceMap[nIndex] === -1) {
                                        distanceMap[nIndex] = dist + 1;
                                        pixelsToRemove[nIndex] = true;
                                        queue.push([nx, ny]);
                                    }
                                }
                            }
                        }
                         for (let i = 0; i < pixelsToRemove.length; i++) {
                            if (pixelsToRemove[i]) { data[i * 4 + 3] = 0; }
                        }
                    } else { // feather === 0
                        for (let i = 0; i < pixelsToRemove.length; i++) { if (pixelsToRemove[i]) { data[i * 4 + 3] = 0; } }
                    }

                    tempCtx.putImageData(imageData, 0, 0);
                    const newImage = new Image(); newImage.crossOrigin = 'Anonymous'; newImage.src = tempCanvas.toDataURL();
                    return new Promise((resolve) => {
                        newImage.onload = () => { 
                            node.image(newImage); 
                            node.clearCache();
                            this.layer.batchDraw(); 
                            resolve(); 
                        };
                    });
                }

                async applyMagicWand(target) {
                    if (!this.isMagicWandActive || !(target instanceof Konva.Image)) return;
                    const node = target;
                    
                    this.commitMagicWand(node); // Commit any previous wand effect on this node
                    node.setAttr('originalImage', node.image()); // Set the current state as the new original

                    const pos = node.getRelativePointerPosition();
                    const imageEl = node.image();
                    const naturalWidth = imageEl.naturalWidth || imageEl.width;
                    const naturalHeight = imageEl.naturalHeight || imageEl.height;

                    const startX = Math.floor(pos.x * (naturalWidth / node.width()));
                    const startY = Math.floor(pos.y * (naturalHeight / node.height()));

                    if (startX < 0 || startX >= naturalWidth || startY < 0 || startY >= naturalHeight) {
                        uiManager.showToast('Please click inside the image.'); return;
                    }
                    
                    const tolerance = parseInt(document.getElementById('magicWandTolerance').value, 10);
                    const isContiguous = document.getElementById('magicWandContiguous').checked;
                    const feather = parseInt(document.getElementById('magicWandFeather').value, 10);
                    
                    node.setAttr('magicWandParams', { startX, startY, tolerance, isContiguous, feather });

                    uiManager.showToast('Processing... Adjust sliders to refine.');
                    await this._performMagicWandProcessing(node);
                }

                toggleCropToolMode() {
                    if (this.isCropToolActive) {
                        this.exitCropToolMode();
                        return;
                    }
                    this.exitAllToolModes();
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) {
                         uiManager.showToast('Please select a single image to crop.'); return;
                    }

                    this.isCropToolActive = true;
                    document.body.classList.add('crop-tool-active');
                    document.getElementById('cropToolBtn').classList.add('active');
                    
                    uiManager.showToast('Crop Tool active. Draw a rectangle to crop.'); this.tr.hide(); this.selectedNodes[0].draggable(false);
                    this.drawingLayer = new Konva.Layer(); this.stage.add(this.drawingLayer);
                    let x1, y1, x2, y2;
                    this.stage.on('mousedown.crop touchstart.crop', (e) => {
                        const pos = this.stage.getPointerPosition(); x1 = pos.x; y1 = pos.y; x2 = pos.x; y2 = pos.y;
                        this.cropRect = new Konva.Rect({ x: x1, y: y1, width: 0, height: 0, stroke: 'rgba(74, 144, 226, 0.8)', strokeWidth: 2, dash: [4, 4], });
                        this.drawingLayer.add(this.cropRect);
                    });
                    this.stage.on('mousemove.crop touchmove.crop', (e) => {
                        if (!this.cropRect) return;
                        const pos = this.stage.getPointerPosition(); x2 = pos.x; y2 = pos.y;
                        this.cropRect.setAttrs({ x: Math.min(x1, x2), y: Math.min(y1, y2), width: Math.abs(x2 - x1), height: Math.abs(y2 - y1), });
                    });
                    this.stage.on('mouseup.crop touchend.crop', () => {
                        if (!this.cropRect || this.cropRect.width() < 5) { this.exitCropToolMode(); return; }
                        this.applyCrop(this.selectedNodes[0], this.cropRect.getClientRect()); this.exitCropToolMode();
                    });
                }

                exitCropToolMode() {
                    if (!this.isCropToolActive) return;
                    this.isCropToolActive = false; document.body.classList.remove('crop-tool-active');
                    document.getElementById('cropToolBtn').classList.remove('active');
                    if (this.drawingLayer) { this.drawingLayer.destroy(); this.drawingLayer = null; }
                    this.cropRect = null; this.stage.off('.crop');
                    if (this.selectedNodes.length > 0) {
                        this.selectedNodes.forEach(n => n.draggable(true));
                        this.tr.nodes(this.selectedNodes); this.tr.show(); this.layer.draw();
                    }
                }
                
                applyCrop(node, cropArea) {
                    const dataURL = node.toDataURL({ ...cropArea, pixelRatio: 3 });
                    this.addImage(dataURL, 0, { x: cropArea.x + cropArea.width / 2, y: cropArea.y + cropArea.height / 2 });
                    uiManager.showToast('Image cropped and pasted!');
                }

                toggleSelectionToolMode() {
                     if (this.isSelectionToolActive) {
                        this.exitSelectionToolMode();
                        return;
                    }
                    this.exitAllToolModes();
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) {
                         uiManager.showToast('Please select a single image first.'); return;
                    }
                    
                    this.isSelectionToolActive = true;
                    document.body.classList.add('selection-tool-active');
                    document.getElementById('selectionToolBtn').classList.add('active');
                    
                    uiManager.showToast('Draw a rectangle, then press Ctrl+C to copy selection.'); this.tr.hide(); this.selectedNodes[0].draggable(false);
                    this.drawingLayer = new Konva.Layer(); this.stage.add(this.drawingLayer);
                    let x1, y1;
                    let isDrawingSelection = false;

                    this.stage.on('mousedown.selection touchstart.selection', (e) => {
                        isDrawingSelection = true;
                        if(this.selectionRect) { this.selectionRect.destroy(); }
                        if(this.startPointMarker) { this.startPointMarker.destroy(); }
                        const pos = this.stage.getPointerPosition(); x1 = pos.x; y1 = pos.y;
                        
                        this.startPointMarker = new Konva.Circle({ x: x1, y: y1, radius: 5, fill: 'white', stroke: '#e91e63', strokeWidth: 2 });
                        this.drawingLayer.add(this.startPointMarker);

                        this.selectionRect = new Konva.Rect({ x: x1, y: y1, width: 0, height: 0, stroke: 'rgba(233, 30, 99, 0.9)', strokeWidth: 2, dash: [4, 4], });
                        this.drawingLayer.add(this.selectionRect);
                    });
                    this.stage.on('mousemove.selection touchmove.selection', (e) => {
                        if (!isDrawingSelection) return;
                        const pos = this.stage.getPointerPosition();
                        this.selectionRect.setAttrs({ x: Math.min(x1, pos.x), y: Math.min(y1, pos.y), width: Math.abs(pos.x - x1), height: Math.abs(pos.y - y1), });
                    });
                    this.stage.on('mouseup.selection touchend.selection', (e) => {
                        isDrawingSelection = false;
                    });
                }

                exitSelectionToolMode() {
                    if (!this.isSelectionToolActive) return;
                    this.isSelectionToolActive = false; document.body.classList.remove('selection-tool-active');
                    document.getElementById('selectionToolBtn').classList.remove('active');
                    if (this.drawingLayer) { this.drawingLayer.destroy(); this.drawingLayer = null; }
                    this.selectionRect = null; 
                    this.startPointMarker = null;
                    this.stage.off('.selection');
                    if (this.selectedNodes.length > 0) {
                         this.selectedNodes.forEach(n => n.draggable(true));
                        this.tr.nodes(this.selectedNodes); this.tr.show(); this.layer.draw();
                    }
                }
                
                toggleMultiSelectMode() {
                    this.isMultiSelectActive = !this.isMultiSelectActive;
                    document.body.classList.toggle('multi-select-active', this.isMultiSelectActive);
                    document.getElementById('multiSelectToolBtn').classList.toggle('active', this.isMultiSelectActive);

                    if (this.isMultiSelectActive) {
                        this.exitAllToolModes(true);
                        this.tr.nodes([]);
                        this.selectionRectangle = new Konva.Rect({ fill: 'rgba(74, 144, 226, 0.3)', visible: false });
                        this.layer.add(this.selectionRectangle);

                        let x1, y1, x2, y2;
                        this.stage.on('mousedown.multiselect', (e) => {
                            if (e.target !== this.stage) { return; }
                            e.evt.preventDefault();
                            x1 = this.stage.getPointerPosition().x; y1 = this.stage.getPointerPosition().y; x2 = x1; y2 = y1;
                            this.selectionRectangle.visible(true); this.selectionRectangle.width(0); this.selectionRectangle.height(0);
                        });

                        this.stage.on('mousemove.multiselect', (e) => {
                            if (!this.selectionRectangle.visible()) { return; }
                            e.evt.preventDefault();
                            x2 = this.stage.getPointerPosition().x; y2 = this.stage.getPointerPosition().y;
                            this.selectionRectangle.setAttrs({ x: Math.min(x1, x2), y: Math.min(y1, y2), width: Math.abs(x2 - x1), height: Math.abs(y2 - y1) });
                        });

                        this.stage.on('mouseup.multiselect', (e) => {
                            if (!this.selectionRectangle.visible()) { return; }
                            e.evt.preventDefault();
                            this.selectionRectangle.visible(false);
                            const shapes = this.stage.find('.image, Konva.Text');
                            const box = this.selectionRectangle.getClientRect();
                            const selected = shapes.filter((shape) => Konva.Util.haveIntersection(box, shape.getClientRect()));
                            this.selectedNodes = selected;
                            this.tr.nodes(selected);
                            this.layer.draw();
                        });

                    } else {
                        this.stage.off('.multiselect');
                        if (this.selectionRectangle) {
                            this.selectionRectangle.destroy();
                            this.selectionRectangle = null;
                        }
                    }
                }

                exitAllToolModes(keepMultiSelect = false) {
                    if (!keepMultiSelect) {
                        if (this.isMultiSelectActive) this.toggleMultiSelectMode();
                    }
                    if (this.isMagicWandActive) this.exitMagicWandMode();
                    if (this.isCropToolActive) this.exitCropToolMode();
                    if (this.isSelectionToolActive) this.exitSelectionToolMode();
                }

                copySelectionToClipboard() {
                    if (!this.isSelectionToolActive || this.selectedNodes.length !== 1 || !this.selectionRect || this.selectionRect.width() < 1) { return; }
                    const node = this.selectedNodes[0];
                    const cropArea = this.selectionRect.getClientRect();
                    const dataURL = node.toDataURL({ ...cropArea, pixelRatio: 3 });
                    this.clipboardNodes = [{ type: 'imageURL', src: dataURL }];
                    uiManager.showToast("Selection copied to clipboard!");
                    this.exitSelectionToolMode();
                }

                cutSelectionFromImage() {
                    if (!this.isSelectionToolActive || this.selectedNodes.length !== 1 || !this.selectionRect || this.selectionRect.width() < 1) {
                        return;
                    }
                    const node = this.selectedNodes[0];
                    const cropArea = this.selectionRect.getClientRect();

                    const dataURL = node.toDataURL({ ...cropArea, pixelRatio: 3 });
                    this.clipboardNodes = [{ type: 'imageURL', src: dataURL }];
                    uiManager.showToast("Selection cut!");

                    const imageElement = node.image();
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = imageElement.naturalWidth;
                    tempCanvas.height = imageElement.naturalHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(imageElement, 0, 0);

                    const transform = node.getAbsoluteTransform().copy().invert();
                    const p1 = transform.point({ x: cropArea.x, y: cropArea.y });
                    const p2 = transform.point({ x: cropArea.x + cropArea.width, y: cropArea.y });
                    const p3 = transform.point({ x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height });
                    const p4 = transform.point({ x: cropArea.x, y: cropArea.y + cropArea.height });

                    tempCtx.save();
                    tempCtx.beginPath();
                    tempCtx.moveTo(p1.x, p1.y);
                    tempCtx.lineTo(p2.x, p2.y);
                    tempCtx.lineTo(p3.x, p3.y);
                    tempCtx.lineTo(p4.x, p4.y);
                    tempCtx.closePath();
                    
                    tempCtx.globalCompositeOperation = 'destination-out';
                    tempCtx.fill();
                    tempCtx.restore();

                    const newImage = new Image();
                    newImage.src = tempCanvas.toDataURL();
                    newImage.onload = () => {
                        node.image(newImage);
                        this.layer.batchDraw();
                        this.saveHistory();
                    };
                    this.exitSelectionToolMode();
                }

                getPreviewDataURL() { 
                    this.tr.hide(); this.gridLayer.hide(); uiManager.hidePropertiesSidebar();
                    const tempTransform = this.container.style.transform;
                    this.container.style.transform = ''; const dataURL = this.stage.toDataURL({ pixelRatio: 0.5 });
                    this.container.style.transform = tempTransform; this.tr.show(); this.gridLayer.show(); if(this.selectedNodes.length) uiManager.showPropertiesSidebar(this.selectedNodes[0]);
                    return dataURL; 
                }
                getExportDataURL() {
                    this.tr.hide(); this.gridLayer.hide(); this.watermarkLayer.hide(); uiManager.hidePropertiesSidebar();
                    const tempTransform = this.container.style.transform;
                    this.container.style.transform = ''; const dataURL = this.stage.toDataURL({ pixelRatio: 2 });
                    this.container.style.transform = tempTransform; this.tr.show(); this.gridLayer.show(); this.watermarkLayer.show(); if(this.selectedNodes.length) uiManager.showPropertiesSidebar(this.selectedNodes[0]);
                    return dataURL; 
                }
                exportToPNG() { saveAs(this.getExportDataURL(), 'design.png'); }
                exportToPDF() { const pdf = new jspdf.jsPDF({ orientation: this.canvasWidth > this.canvasHeight ? 'landscape' : 'portrait', unit: 'px', format: [this.canvasWidth, this.canvasHeight] }); pdf.addImage(this.getExportDataURL(), 'PNG', 0, 0, this.canvasWidth, this.canvasHeight); pdf.save('design.pdf'); }
                
                deleteSelected() { 
                    if (this.selectedNodes.length === 0) return;
                    uiManager.hidePropertiesSidebar(); this.selectedNodes.forEach(node => node.destroy()); 
                    this.tr.nodes([]); this.selectedNodes = []; this.layer.draw(); this.saveHistory();
                }
                copySelected() { 
                    if (this.selectedNodes.length > 0) {
                        this.clipboardNodes = this.selectedNodes.map(node => node.clone());
                        uiManager.showToast(`${this.selectedNodes.length} item(s) copied!`);
                    }
                }
                pasteFromClipboard() {
                    if (!this.clipboardNodes || this.clipboardNodes.length === 0) { uiManager.showToast('Nothing to paste.'); return; }
                     if (this.clipboardNodes[0].type === 'imageURL') {
                        this.addImage(this.clipboardNodes[0].src);
                        this.clipboardNodes = [];
                        return;
                    }
                    const newNodes = [];
                    this.clipboardNodes.forEach(nodeToClone => {
                        const newNode = nodeToClone.clone();
                        if (newNode instanceof Konva.Image) { newNode.id('img_' + crypto.randomUUID()); }
                        newNode.x(newNode.x() + 20); newNode.y(newNode.y() + 20); newNode.draggable(true);
                        this.layer.add(newNode); this._bindNodeEvents(newNode); newNodes.push(newNode);
                    });
                    this.tr.nodes(newNodes); this.selectedNodes = newNodes; this.layer.draw(); this.saveHistory();
                }

                handleKeyboard(e) {
                    if (this.isMagicWandActive && e.key === 'Escape') { this.toggleMagicWandMode(); } // Use toggle to handle commit
                    if (this.isCropToolActive && e.key === 'Escape') { this.exitCropToolMode(); }
                    if (this.isSelectionToolActive && e.key === 'Escape') { this.exitSelectionToolMode(); }
                    
                    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) return;
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key.toLowerCase()) {
                            case 'c': 
                                e.preventDefault(); 
                                if(this.isSelectionToolActive) this.copySelectionToClipboard();
                                else this.copySelected(); 
                                break;
                            case 'x':
                                e.preventDefault();
                                if (this.isSelectionToolActive) {
                                    this.cutSelectionFromImage();
                                } else {
                                    this.copySelected();
                                    this.deleteSelected();
                                }
                                break;
                            case 'v': e.preventDefault(); this.pasteFromClipboard(); break;
                            case 'z': e.preventDefault(); this.undo(); break;
                            case 'y': e.preventDefault(); this.redo(); break;
                        }
                    } 
                    if (e.key === 'Delete' || e.key === 'Backspace') { this.deleteSelected(); }
                }

                saveHistory() {
                    this.history = this.history.slice(0, this.historyStep + 1);
                    const imagesData = {};
                    this.layer.find('Image').forEach(imgNode => {
                        if (imgNode.id() && imgNode.image() && imgNode.image().src) {
                            imagesData[imgNode.id()] = imgNode.image().src;
                        }
                    });
                    const state = {
                        layerJSON: this.layer.toJSON(),
                        images: imagesData
                    };
                    this.history.push(state);
                    this.historyStep++;
                    uiManager.updateUndoRedoButtons();
                }

                async undo() {
                    if (this.historyStep > 0) {
                        this.historyStep--;
                        await this.loadLayerState(this.history[this.historyStep]);
                    }
                    uiManager.updateUndoRedoButtons();
                }

                async redo() {
                    if (this.historyStep < this.history.length - 1) {
                        this.historyStep++;
                        await this.loadLayerState(this.history[this.historyStep]);
                    }
                    uiManager.updateUndoRedoButtons();
                }

                async loadLayerState(historyEntry) {
                    const { layerJSON, images: imagesData } = historyEntry;
                    try {
                        const imageElements = {};
                        const imageLoadPromises = Object.keys(imagesData || {}).map(imageId => {
                            return new Promise((resolve, reject) => {
                                const img = new window.Image();
                                img.onload = () => { imageElements[imageId] = img; resolve(); };
                                img.onerror = (err) => reject(new Error(`Could not load history image ${imageId}`));
                                img.src = imagesData[imageId];
                            });
                        });
                        await Promise.all(imageLoadPromises);

                        const oldLayer = this.stage.findOne('#main-layer');
                        if (oldLayer) { oldLayer.destroy(); }
                        
                        this.layer = Konva.Node.create(layerJSON);
                        this.layer.setAttrs({ id: 'main-layer' });
                        this.stage.add(this.layer);

                        this.layer.find('Image').forEach(imgNode => {
                            if (imgNode.id() && imageElements[imgNode.id()]) {
                                imgNode.image(imageElements[imgNode.id()]);
                                this.applyAdjustments(imgNode); // Re-apply filters
                            }
                        });

                        const oldTr = this.layer.findOne('Transformer');
                        if(oldTr) oldTr.destroy();
                        this.tr = this._createTransformer();
                        this.layer.add(this.tr);
                        
                        this.tr.nodes([]); this.selectedNodes = []; uiManager.hidePropertiesSidebar();
                        this.gridLayer.moveToBottom(); this.watermarkLayer.moveToTop();
                        this.rebindListeners(this.layer);
                        this.stage.draw();
                    } catch (error) {
                        console.error("Failed to load history state:", error);
                        uiManager.showToast("Error: Could not perform undo/redo.");
                    }
                }

                saveState() {
                    this.tr.nodes([]); this.layer.draw(); const stageObject = this.stage.toObject();
                    const imagesData = {};
                    this.stage.find('Image').forEach(imgNode => { if (imgNode.id() && imgNode.image() && imgNode.image().src) { imagesData[imgNode.id()] = imgNode.image().src; } });
                    return JSON.stringify({ stage: stageObject, images: imagesData });
                }

                async loadState(jsonString) {
                    let projectData;
                    try { projectData = JSON.parse(jsonString); } catch (e) { uiManager.showToast('Error: Invalid project file format.'); console.error("JSON Parse Error:", e); return; }
                    if (projectData.stage && projectData.images) {
                        try {
                            const imageElements = {};
                            const imageLoadPromises = Object.keys(projectData.images).map(imageId => {
                                return new Promise((resolve, reject) => {
                                    const img = new window.Image();
                                    img.onload = () => { imageElements[imageId] = img; resolve(); };
                                    img.onerror = (err) => reject(new Error(`Could not load image ${imageId}`));
                                    img.src = projectData.images[imageId];
                                });
                            });
                            await Promise.all(imageLoadPromises);
                            if (this.stage) { this.stage.destroy(); }
                            this.stage = Konva.Node.create(projectData.stage, this.containerId);
                            this.stage.find('Image').forEach(imgNode => { 
                                if (imgNode.id() && imageElements[imgNode.id()]) { 
                                    imgNode.image(imageElements[imgNode.id()]); 
                                    this.applyAdjustments(imgNode);
                                } 
                            });
                        } catch (error) { console.error("Failed to load project assets:", error); uiManager.showToast("Error: Could not load project images."); this.cm.setCanvasSize('letter'); return; }
                    } else { if (this.stage) { this.stage.destroy(); } this.stage = Konva.Node.create(projectData, this.containerId); }
                    
                    this.layer = this.stage.findOne('#main-layer'); 
                    this.gridLayer = this.stage.findOne('#grid-layer'); 
                    this.watermarkLayer = this.stage.findOne('#watermark-layer');
                    
                    if (!this.layer) { this.layer = new Konva.Layer({ id: 'main-layer' }); this.stage.add(this.layer); }
                    if (!this.gridLayer) { this.gridLayer = new Konva.Layer({ id: 'grid-layer' }); this.stage.add(this.gridLayer); }
                    if (!this.watermarkLayer) { this.watermarkLayer = new Konva.Layer({ id: 'watermark-layer', listening: false }); this.stage.add(this.watermarkLayer); }
                    
                    const oldTr = this.stage.findOne('Transformer');
                    if (oldTr) oldTr.destroy();
                    this.tr = this._createTransformer();
                    this.layer.add(this.tr); 

                    this.stage.container().style.backgroundColor = document.body.classList.contains('dark') ? '#2a2a2a' : 'white';
                    this.rebindListeners(this.stage); this.drawGrid(); this.addWatermark(); this.attachStageListeners();
                    this.stage.draw(); this.centerView();
                    this.history = []; this.historyStep = -1; this.saveHistory();
                }
                rebindListeners(node) {
                    this._bindNodeEvents(node);
                    if (node.hasChildren()) { node.getChildren().forEach(child => this.rebindListeners(child)); }
                }

                updateImageAdjustments(property, value) {
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) return;
                    const node = this.selectedNodes[0];
                    let adjustments = node.getAttr('adjustments') || {};
                    adjustments[property] = parseFloat(value);
                    node.setAttr('adjustments', adjustments);
                    this.debouncedApplyAdjustments(node);
                }

                applyAdjustments(node) {
                    if (!(node instanceof Konva.Image)) return;
                    const adjustments = node.getAttr('adjustments') || {};
                    const hasAdjustments = Object.values(adjustments).some(v => v !== 0);

                    if (!hasAdjustments) {
                        node.filters([]);
                        node.cache();
                        return;
                    }
                    
                    node.filters([this.masterAdjustmentFilter]);

                    // Pass adjustment values to the filter via custom node properties
                    const adjustSliders = ['Lightness', 'Contrast', 'Saturation', 'Warmth', 'Tint', 'Hue', 'Highlight', 'Shadow', 'Vignette', 'Sharpen', 'Grain', 'Fade'];
                    adjustSliders.forEach(name => {
                         const key = name.toLowerCase();
                         node.setAttr(key, adjustments[key] || 0);
                    });

                    node.cache();
                }

                masterAdjustmentFilter(imageData) {
                    const adj = this.getAttrs();
                    const d = imageData.data;
                    const w = imageData.width;
                    const h = imageData.height;

                    const lightness = (adj.lightness || 0) / 100;
                    const contrast = (adj.contrast || 0) / 100;
                    const saturation = (adj.saturation || 0) / 100;
                    const warmth = (adj.warmth || 0) / 100;
                    const tint = (adj.tint || 0) / 100;
                    const hue = adj.hue || 0;
                    const highlight = (adj.highlight || 0) / 100;
                    const shadow = (adj.shadow || 0) / 100;
                    const vignette = (adj.vignette || 0) / 100;
                    const sharpen = (adj.sharpen || 0) / 100;
                    const grain = (adj.grain || 0) / 100;
                    const fade = (adj.fade || 0) / 100;

                    const contrastFactor = 1.0 + contrast;
                    const intercept = 128 * (1.0 - contrastFactor);

                    const sharpenKernel = [0, -sharpen, 0, -sharpen, 1 + 4 * sharpen, -sharpen, 0, -sharpen, 0];
                    
                    const src = new Uint8ClampedArray(d); // Create a copy for sharpening

                    for (let i = 0; i < d.length; i += 4) {
                        let r = src[i], g = src[i+1], b = src[i+2];

                        // 1. Lightness
                        r += lightness * 255; g += lightness * 255; b += lightness * 255;

                        // 2. Contrast
                        r = r * contrastFactor + intercept; g = g * contrastFactor + intercept; b = b * contrastFactor + intercept;

                        // 3. Warmth & Tint
                        r += warmth * 50; b -= warmth * 50;
                        g += tint * 50;

                        // 4. Saturation & Hue
                        if (saturation !== 0 || hue !== 0) {
                            const hsv = rgbToHsv(r, g, b);
                            hsv.h = (hsv.h + hue) % 360;
                            hsv.s = Math.max(0, Math.min(1, hsv.s * (1 + saturation)));
                            const newRgb = hsvToRgb(hsv.h, hsv.s, hsv.v);
                            r = newRgb.r; g = newRgb.g; b = newRgb.b;
                        }

                        // 5. Highlights and Shadows
                        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                        if (highlight > 0) {
                            const highlightFactor = luminance / 255;
                            r += highlight * highlightFactor * 255; g += highlight * highlightFactor * 255; b += highlight * highlightFactor * 255;
                        } else if (highlight < 0) {
                            const highlightFactor = luminance / 255;
                             r += highlight * highlightFactor * 255; g += highlight * highlightFactor * 255; b += highlight * highlightFactor * 255;
                        }
                         if (shadow > 0) {
                            const shadowFactor = 1.0 - (luminance / 255);
                            r += shadow * shadowFactor * 255; g += shadow * shadowFactor * 255; b += shadow * shadowFactor * 255;
                        } else if (shadow < 0) {
                             const shadowFactor = 1.0 - (luminance / 255);
                             r += shadow * shadowFactor * 255; g += shadow * shadowFactor * 255; b += shadow * shadowFactor * 255;
                        }

                        // 6. Fade
                        if (fade > 0) {
                            const fadeAmount = fade * 50;
                            r = (r * (1 - fade)) + (fadeAmount);
                            g = (g * (1 - fade)) + (fadeAmount);
                            b = (b * (1 - fade)) + (fadeAmount);
                        }

                        // Clamp initial values
                        d[i] = Math.max(0, Math.min(255, r));
                        d[i+1] = Math.max(0, Math.min(255, g));
                        d[i+2] = Math.max(0, Math.min(255, b));
                    }
                    
                    // 7. Sharpen (Convolution) - needs a second loop
                    if (sharpen > 0) {
                        for (let y = 1; y < h - 1; y++) {
                            for (let x = 1; x < w - 1; x++) {
                                let r = 0, g = 0, b = 0;
                                for (let ky = -1; ky <= 1; ky++) {
                                    for (let kx = -1; kx <= 1; kx++) {
                                        const kernelIndex = (ky + 1) * 3 + (kx + 1);
                                        const pixelIndex = ((y + ky) * w + (x + kx)) * 4;
                                        r += src[pixelIndex] * sharpenKernel[kernelIndex];
                                        g += src[pixelIndex + 1] * sharpenKernel[kernelIndex];
                                        b += src[pixelIndex + 2] * sharpenKernel[kernelIndex];
                                    }
                                }
                                const destIndex = (y * w + x) * 4;
                                d[destIndex] = Math.max(0, Math.min(255, r));
                                d[destIndex + 1] = Math.max(0, Math.min(255, g));
                                d[destIndex + 2] = Math.max(0, Math.min(255, b));
                            }
                        }
                    }

                    // 8. Vignette and Grain - final loop
                     for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const index = (y * w + x) * 4;
                            
                            // Vignette
                            if (vignette > 0) {
                                const dx = (x - w / 2) / (w/2);
                                const dy = (y - h / 2) / (h/2);
                                const dist = Math.sqrt(dx * dx + dy * dy);
                                const darken = Math.pow(dist, 2.5) * vignette;
                                d[index] *= (1 - darken);
                                d[index + 1] *= (1 - darken);
                                d[index + 2] *= (1 - darken);
                            }

                            // Grain
                            if (grain > 0) {
                                const grainAmount = (Math.random() - 0.5) * grain * 50;
                                d[index] += grainAmount;
                                d[index + 1] += grainAmount;
                                d[index + 2] += grainAmount;
                            }

                             // Final clamp
                             d[index] = Math.max(0, Math.min(255, d[index]));
                             d[index+1] = Math.max(0, Math.min(255, d[index+1]));
                             d[index+2] = Math.max(0, Math.min(255, d[index+2]));
                        }
                    }

                    function rgbToHsv(r, g, b) {
                      r /= 255; g /= 255; b /= 255;
                      let max = Math.max(r, g, b), min = Math.min(r, g, b);
                      let h, s, v = max;
                      let d = max - min;
                      s = max === 0 ? 0 : d / max;
                      if (max === min) { h = 0; } 
                      else {
                        switch (max) {
                          case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                          case g: h = (b - r) / d + 2; break;
                          case b: h = (r - g) / d + 4; break;
                        }
                        h /= 6;
                      }
                      return { h: h * 360, s: s, v: v };
                    }
                    function hsvToRgb(h, s, v) {
                      let r, g, b, i, f, p, q, t;
                      h /= 360; i = Math.floor(h * 6); f = h * 6 - i;
                      p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s);
                      switch (i % 6) {
                        case 0: r = v; g = t; b = p; break;
                        case 1: r = q; g = v; b = p; break;
                        case 2: r = p; g = v; b = t; break;
                        case 3: r = p; g = q; b = v; break;
                        case 4: r = t; g = p; b = v; break;
                        case 5: r = v; g = p; b = q; break;
                      }
                      return { r: r * 255, g: g * 255, b: b * 255 };
                    }
                }
            }

            class UIManager {
                constructor(canvasManager) {
                    this.cm = canvasManager; 
                    this.sidebar = document.getElementById('sidebar');
                    this.propertiesSidebar = document.getElementById('propertiesSidebar');
                    this.tabsContainer = document.getElementById('tabsContainer'); 
                    this.projects = [];
                    this.activeProjectId = null; this.projectCounter = 1;
                }
                init() { this.buildSidebar(); this.setupEventListeners(); this.setInitialTheme(); this.createNewProject(); this.initPropertiesSidebar(); }

                buildSidebar() {
                    this.sidebar.innerHTML = `
                        <div class="sidebar-section">
                            <h3>Project</h3>
                            <button id="newProjectBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg><span>New Project</span></button>
                            <button id="saveProjectBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg><span>Save Project</span></button>
                            <button id="loadProjectBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg><span>Load Project</span></button>
                        </div>
                        <div class="sidebar-section">
                            <h3>Add Content</h3>
                            <button id="uploadBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg><span>Upload Image</span></button>
                            <button id="addTextBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg><span>Add Text</span></button>
                             <button id="aiImageBtn" class="sidebar-button ai-button"><svg viewBox="0 0 24 24" stroke="currentColor"><path d="M10 3L8 8l-5 2 5 2 2 5 2-5 5-2-5-2-2-5zM18 13l-2 5-5-2 5-2 2-5 2 5z"/></svg><span>AI Studio</span></button>
                        </div>
                        <div class="sidebar-section">
                            <h3>Canvas</h3>
                            <label>Size: <select id="canvasSizeSelect">
                                <option value="1080p" selected>HD (1920x1080 px)</option>
                                <option value="4k">4K (3840x2160 px)</option>
                                <option value="letter">Letter (8.5 x 11 in)</option>
                                <option value="a4">A4 (8.27 x 11.69 in)</option>
                                <option value="legal">Legal (8.5 x 14 in)</option>
                                <option value="tabloid">Tabloid (11 x 17 in)</option>
                                <option value="ig_square">Instagram Post (1080x1080 px)</option>
                                <option value="ig_story">Instagram Story (1080x1920 px)</option>
                                <option value="twitter">X/Twitter Post (1600x900 px)</option>
                                <option value="facebook">Facebook Post (1200x630 px)</option>
                            </select></label>
                            <label>Orientation: <button id="orientationToggleBtn" class="button-group" style="padding: 8px 12px; width: auto; display: flex; align-items: center; gap: 8px;"></button></label>
                        </div>
                        <div class="sidebar-section"><h3>View & Export</h3><div class="button-group"><button id="previewBtn">Preview</button><button id="exportPngBtn">PNG</button><button id="exportPdfBtn">PDF</button></div></div>`;
                    this.updateOrientationButton();
                }

                setupEventListeners() {
                    document.getElementById('sidebarToggleBtn').addEventListener('click', (e) => { e.stopPropagation(); this.toggleSidebar(); });
                    document.getElementById('fullscreenToggleBtn').addEventListener('click', () => this.toggleFullscreen());
                    document.getElementById('themeToggle').addEventListener('click', () => this.toggleTheme());
                    document.getElementById('centerViewBtn').addEventListener('click', () => this.cm.centerView());
                    document.getElementById('undoBtn').addEventListener('click', () => this.cm.undo());
                    document.getElementById('redoBtn').addEventListener('click', () => this.cm.redo());
                    document.getElementById('multiSelectToolBtn').addEventListener('click', () => this.cm.toggleMultiSelectMode());
                    document.getElementById('zoomSlider').addEventListener('input', (e) => this.cm.setZoom(parseFloat(e.target.value)));
                    document.getElementById('rotationSlider').addEventListener('input', (e) => this.cm.setRotation(parseInt(e.target.value, 10)));
                    document.getElementById('canvas-area').addEventListener('click', () => { if (this.sidebar.classList.contains('open')) { this.sidebar.classList.remove('open'); }});
                    document.getElementById('newProjectBtn').addEventListener('click', () => this.createNewProject());
                    document.getElementById('saveProjectBtn').addEventListener('click', () => this.saveProject());
                    document.getElementById('loadProjectBtn').addEventListener('click', () => document.getElementById('loadProjectInput').click());
                    document.getElementById('loadProjectInput').addEventListener('change', (e) => this.loadProjectFromFile(e));
                    document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
                    document.getElementById('addTextBtn').addEventListener('click', () => this.cm.addText());
                    document.getElementById('aiImageBtn').addEventListener('click', () => { document.getElementById('aiImageModal').style.display = 'flex'; this.sidebar.classList.remove('open'); });
                    document.getElementById('canvasSizeSelect').addEventListener('change', (e) => this.cm.setCanvasSize(e.target.value));
                    document.getElementById('orientationToggleBtn').addEventListener('click', () => { this.cm.isLandscape = !this.cm.isLandscape; this.cm.setCanvasSize(document.getElementById('canvasSizeSelect').value); this.updateOrientationButton(); });
                    document.getElementById('previewBtn').addEventListener('click', () => { document.getElementById('previewModal').style.display = 'flex'; document.getElementById('previewImage').src = this.cm.getPreviewDataURL(); });
                    document.getElementById('exportPngBtn').addEventListener('click', () => this.cm.exportToPNG());
                    document.getElementById('exportPdfBtn').addEventListener('click', () => this.cm.exportToPDF());
                }
                
                renderTabs() {
                    this.tabsContainer.innerHTML = '';
                    this.projects.forEach(project => {
                        const tab = document.createElement('div');
                        tab.className = 'tab' + (project.id === this.activeProjectId ? ' active' : ''); tab.dataset.id = project.id;
                        const tabName = document.createElement('span'); tabName.className = 'tab-name'; tabName.textContent = project.name; tab.appendChild(tabName);
                        const closeBtn = document.createElement('span'); closeBtn.className = 'tab-close'; closeBtn.innerHTML = '&times;';
                        closeBtn.addEventListener('click', (e) => { e.stopPropagation(); this.closeProject(project.id); });
                        tab.appendChild(closeBtn); tab.addEventListener('click', async () => await this.switchProject(project.id)); this.tabsContainer.appendChild(tab);
                    });
                    const newTabBtn = document.createElement('button'); newTabBtn.className = 'new-tab-btn'; newTabBtn.textContent = '+';
                    newTabBtn.title = 'New Project'; newTabBtn.addEventListener('click', () => this.createNewProject()); this.tabsContainer.appendChild(newTabBtn);
                }
                saveCurrentProjectState() {
                    if (!this.activeProjectId) return;
                    const project = this.projects.find(p => p.id === this.activeProjectId);
                    if (project) { 
                        project.state = this.cm.saveState();
                        project.zoom = this.cm.zoom;
                        project.rotation = this.cm.rotation;
                        project.offsetX = this.cm.offsetX;
                        project.offsetY = this.cm.offsetY;
                    }
                }
                createNewProject() {
                    this.saveCurrentProjectState();
                    const newProject = { id: Date.now(), name: `Project ${this.projectCounter++}`, state: null };
                    this.projects.push(newProject);
                    this.activeProjectId = newProject.id;
                    this.cm.setCanvasSize('1080p'); this.renderTabs();
                    this.updateUndoRedoButtons();
                }
                async switchProject(projectId) {
                    if (projectId === this.activeProjectId) return;
                    this.saveCurrentProjectState(); 
                    this.activeProjectId = projectId;
                    const project = this.projects.find(p => p.id === this.activeProjectId);
                    if (project && project.state) { 
                        await this.cm.loadState(project.state); 
                    } else { 
                        this.cm.setCanvasSize('1080p'); 
                    }

                    if (project && typeof project.zoom !== 'undefined') {
                        this.cm.setZoom(project.zoom);
                        this.cm.setRotation(project.rotation);
                        this.cm.offsetX = project.offsetX;
                        this.cm.offsetY = project.offsetY;
                        this.cm.updateContainerTransform();
                    }

                    this.renderTabs();
                    this.updateUndoRedoButtons();
                }
                async closeProject(projectId) {
                    if (this.projects.length <= 1) { this.showToast("Cannot close the last project."); return; }
                    const indexToRemove = this.projects.findIndex(p => p.id === projectId); if (indexToRemove === -1) return;
                    this.projects.splice(indexToRemove, 1);
                    if (this.activeProjectId === projectId) {
                        const newActiveIndex = Math.max(0, indexToRemove - 1);
                        this.activeProjectId = this.projects[newActiveIndex].id;
                        const project = this.projects.find(p => p.id === this.activeProjectId);
                        if (project && project.state) { await this.cm.loadState(project.state); } else { this.cm.setCanvasSize('1080p'); }
                    } this.renderTabs();
                    this.updateUndoRedoButtons();
                }
                saveProject() {
                    this.saveCurrentProjectState(); const project = this.projects.find(p => p.id === this.activeProjectId); if (!project) return;
                    const blob = new Blob([project.state], { type: 'application/json' }); saveAs(blob, `${project.name}.json`);
                }
                loadProjectFromFile(e) {
                    const file = e.target.files[0]; if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const jsonString = event.target.result; this.saveCurrentProjectState();
                            const newProject = { id: Date.now(), name: file.name.replace('.json', ''), state: jsonString };
                            this.projects.push(newProject); this.activeProjectId = newProject.id;
                            await this.cm.loadState(jsonString); this.renderTabs();
                            this.updateUndoRedoButtons();
                        } catch (err) { this.showToast("Error: Invalid project file."); console.error(err);
                        } finally { e.target.value = ''; }
                    };
                    reader.readAsText(file);
                }

                toggleSidebar() { this.sidebar.classList.toggle('open'); }
                updateOrientationButton() {
                    const btn = document.getElementById('orientationToggleBtn'); if (!btn) return;
                    const icon = this.cm.isLandscape ? `<svg viewBox="0 0 24 24"><path d="M23 18H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1h22a1 1 0 0 1 1 1v10a1 1 0 0 1-1 1zM2 16h20V8H2v8z"></path></svg>` : `<svg viewBox="0 0 24 24"><path d="M18 1H7a1 1 0 0 0-1 1v22a1 1 0 0 0 1 1h11a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1zM8 22V2h9v20H8z"></path></svg>`;
                    btn.innerHTML = `${icon} ${this.cm.isLandscape ? 'Landscape' : 'Portrait'}`;
                }
                updateZoomSlider(scale) { document.getElementById('zoomSlider').value = scale; document.getElementById('zoomValue').textContent = `${Math.round(scale * 100)}%`; }
                updateRotationSlider(deg) { const roundedDeg = Math.round(deg); document.getElementById('rotationSlider').value = roundedDeg; document.getElementById('rotationValue').textContent = `${roundedDeg}°`; }

                updateUndoRedoButtons() {
                    document.getElementById('undoBtn').disabled = this.cm.historyStep <= 0;
                    document.getElementById('redoBtn').disabled = this.cm.historyStep >= this.cm.history.length - 1;
                }

                initPropertiesSidebar() {
                    const menu = this.propertiesSidebar;
                    menu.querySelectorAll('.menu-tab').forEach(tab => {
                        tab.addEventListener('click', () => {
                            menu.querySelector('.menu-tab.active').classList.remove('active');
                            menu.querySelector('.tab-pane.active').classList.remove('active');
                            tab.classList.add('active');
                            menu.querySelector(`#pane-${tab.dataset.tab}`).classList.add('active');
                        });
                    });
                    
                    const controlsToTrack = [
                        'selectionRotationSlider', 'selectionZoomSlider', 'textContent',
                        'fontFamily', 'fontSize', 'fillColor', 'strokeColor', 'strokeWidth',
                        'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY',
                        'gradientColor1', 'gradientColor2', 'gradientRotation', 'fillType'
                    ];

                    controlsToTrack.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) {
                           el.addEventListener('change', () => this.cm.saveHistory());
                           if (el.type === 'range' || el.type === 'number') {
                               el.addEventListener('input', (e) => this.cm.updateNodeProperty(el.id.replace('selection', '').replace('Slider','').toLowerCase(), e.target.value));
                           }
                        }
                    });

                    const buttonsToTrack = ['boldBtn', 'italicBtn', 'underlineBtn'];
                    buttonsToTrack.forEach(id => {
                        document.getElementById(id).addEventListener('click', () => this.cm.saveHistory());
                    });


                    document.getElementById('selectionRotationSlider').addEventListener('input', (e) => this.cm.updateNodeProperty('rotation', parseFloat(e.target.value)));
                    document.getElementById('selectionZoomSlider').addEventListener('input', (e) => this.cm.updateNodeProperty('scale', parseFloat(e.target.value)));
                    document.getElementById('deleteBtn').addEventListener('click', () => this.cm.deleteSelected());
                    document.getElementById('textContent').addEventListener('input', (e) => this.cm.updateNodeProperty('text', e.target.value));
                    document.getElementById('fontFamily').addEventListener('change', (e) => this.cm.updateNodeProperty('fontFamily', e.target.value));
                    document.getElementById('fontSize').addEventListener('input', (e) => this.cm.updateNodeProperty('fontSize', e.target.value));
                    document.getElementById('boldBtn').addEventListener('click', (e) => { this.cm.updateNodeProperty('bold'); e.currentTarget.classList.toggle('active'); });
                    document.getElementById('italicBtn').addEventListener('click', (e) => { this.cm.updateNodeProperty('italic'); e.currentTarget.classList.toggle('active'); });
                    document.getElementById('underlineBtn').addEventListener('click', (e) => { this.cm.updateNodeProperty('underline'); e.currentTarget.classList.toggle('active'); });
                    document.getElementById('fillColor').addEventListener('input', (e) => this.cm.updateNodeProperty('fill', e.target.value));
                    document.getElementById('strokeColor').addEventListener('input', (e) => this.cm.updateNodeProperty('stroke', e.target.value));
                    document.getElementById('strokeWidth').addEventListener('input', (e) => this.cm.updateNodeProperty('strokeWidth', e.target.value));
                    document.getElementById('shadowColor').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowColor', e.target.value));
                    document.getElementById('shadowBlur').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowBlur', e.target.value));
                    document.getElementById('shadowOffsetX').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowOffsetX', e.target.value));
                    document.getElementById('shadowOffsetY').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowOffsetY', e.target.value));
                    document.getElementById('selectionToolBtn').addEventListener('click', () => this.cm.toggleSelectionToolMode());
                    document.getElementById('magicWandBtn').addEventListener('click', () => this.cm.toggleMagicWandMode());
                    document.getElementById('cropToolBtn').addEventListener('click', () => this.cm.toggleCropToolMode());
                    
                    const toleranceSlider = document.getElementById('magicWandTolerance');
                    const toleranceValue = document.getElementById('magicWandToleranceValue');
                    toleranceSlider.addEventListener('input', (e) => { toleranceValue.textContent = e.target.value; this.cm.updateMagicWandLive(); });
                    toleranceSlider.addEventListener('change', () => this.cm.saveHistory());

                    const featherSlider = document.getElementById('magicWandFeather');
                    const featherValue = document.getElementById('magicWandFeatherValue');
                    featherSlider.addEventListener('input', (e) => { featherValue.textContent = e.target.value; this.cm.updateMagicWandLive(); });
                    featherSlider.addEventListener('change', () => this.cm.saveHistory());
                    
                    document.getElementById('magicWandContiguous').addEventListener('change', () => { this.cm.updateMagicWandLive(); this.cm.saveHistory(); });
                    
                    // New Adjustment controls
                    this.buildAdjustmentsUI();
                    document.getElementById('resetAllAdjustmentsBtn').addEventListener('click', () => {
                        if (this.cm.selectedNodes.length === 1) {
                            const node = this.cm.selectedNodes[0];
                            node.setAttr('adjustments', {});
                            this.cm.applyAdjustments(node);
                            this.showPropertiesSidebar(node); // Refresh sliders
                            this.cm.saveHistory();
                        }
                    });

                    const updateGradient = () => {
                        this.cm.updateNodeProperty('gradient', {
                            color1: document.getElementById('gradientColor1').value, color2: document.getElementById('gradientColor2').value,
                            angle: document.getElementById('gradientRotation').value
                        });
                    };
                    document.getElementById('gradientColor1').addEventListener('input', updateGradient);
                    document.getElementById('gradientColor2').addEventListener('input', updateGradient);
                    document.getElementById('gradientRotation').addEventListener('input', updateGradient);
                    document.getElementById('fillType').addEventListener('change', (e) => {
                        const isSolid = e.target.value === 'solid';
                        document.getElementById('solidFillOptions').style.display = isSolid ? 'block' : 'none';
                        document.getElementById('gradientFillOptions').style.display = isSolid ? 'none' : 'block';
                        if(isSolid) { this.cm.updateNodeProperty('fill', document.getElementById('fillColor').value); }
                        else { updateGradient(); }
                    });
                }
                
                buildAdjustmentsUI() {
                    const container = document.getElementById('adjustmentsContainer');
                    container.innerHTML = '';
                    const adjustments = [
                        { name: 'Lightness', min: -100, max: 100, step: 1 }, { name: 'Contrast', min: -100, max: 100, step: 1 },
                        { name: 'Saturation', min: -100, max: 100, step: 1 }, { name: 'Warmth', min: -100, max: 100, step: 1 },
                        { name: 'Tint', min: -100, max: 100, step: 1 }, { name: 'Hue', min: -180, max: 180, step: 1 },
                        { name: 'Highlight', min: -100, max: 100, step: 1 }, { name: 'Shadow', min: -100, max: 100, step: 1 },
                        { name: 'Vignette', min: 0, max: 100, step: 1 }, { name: 'Sharpen', min: 0, max: 100, step: 1 },
                        { name: 'Grain', min: 0, max: 100, step: 1 }, { name: 'Fade', min: 0, max: 100, step: 1 },
                    ];

                    adjustments.forEach(({ name, min, max, step }) => {
                        const key = name.toLowerCase();
                        const controlGroup = document.createElement('div');
                        controlGroup.className = 'control-group collapsible';

                        controlGroup.innerHTML = `
                            <div class="collapsible-header">
                                <label>${name}</label>
                                <span class="value-display" id="adjust${name}Value">0</span>
                                <button class="reset-btn" data-target="adjust${name}" title="Reset">
                                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 11a8.1 8.1 0 0 0-7.5-6.5C7.2 4.5 3.1 8.6 3 14a8.1 8.1 0 0 0 7.5 6.5c4.7 0 8.5-3.8 8.5-8.5v-1" /><polyline points="16 7 20 7 20 11" /></svg>
                                </button>
                            </div>
                            <div class="collapsible-content">
                                <div class="slider-container">
                                    <button class="adjust-btn minus" data-target="adjust${name}" data-amount="-${step}">-</button>
                                    <input type="range" id="adjust${name}" min="${min}" max="${max}" value="0" step="${step}">
                                    <button class="adjust-btn plus" data-target="adjust${name}" data-amount="${step}">+</button>
                                </div>
                            </div>
                        `;
                        container.appendChild(controlGroup);

                        // Add event listeners
                        const slider = controlGroup.querySelector(`#adjust${name}`);
                        const valueLabel = controlGroup.querySelector(`#adjust${name}Value`);
                        const header = controlGroup.querySelector('.collapsible-header');
                        const resetBtn = controlGroup.querySelector('.reset-btn');
                        const minusBtn = controlGroup.querySelector('.minus');
                        const plusBtn = controlGroup.querySelector('.plus');

                        header.addEventListener('click', () => controlGroup.classList.toggle('active'));

                        const updateValue = (newValue) => {
                            slider.value = newValue;
                            valueLabel.textContent = newValue;
                            this.cm.updateImageAdjustments(key, newValue);
                        };

                        slider.addEventListener('input', (e) => {
                            valueLabel.textContent = e.target.value;
                            this.cm.updateImageAdjustments(key, e.target.value);
                        });

                        slider.addEventListener('change', () => {
                            // Apply final change immediately and save history
                            this.cm.applyAdjustments(this.cm.selectedNodes[0]);
                            this.cm.saveHistory();
                        });

                        resetBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            updateValue(0);
                            this.cm.applyAdjustments(this.cm.selectedNodes[0]);
                            this.cm.saveHistory();
                        });
                        
                        const adjustValue = (amount) => {
                            const currentValue = parseFloat(slider.value);
                            const newValue = Math.max(min, Math.min(max, currentValue + amount));
                            updateValue(newValue);
                        };

                        minusBtn.addEventListener('click', () => adjustValue(-step));
                        plusBtn.addEventListener('click', () => adjustValue(step));
                        minusBtn.addEventListener('mouseup', () => {this.cm.applyAdjustments(this.cm.selectedNodes[0]); this.cm.saveHistory()});
                        plusBtn.addEventListener('mouseup', () => {this.cm.applyAdjustments(this.cm.selectedNodes[0]); this.cm.saveHistory()});
                    });
                }
                
                showPropertiesSidebar(node) {
                    if (!node) { this.hidePropertiesSidebar(); return; }
                     this.propertiesSidebar.classList.add('visible');
                    document.body.classList.add('sidebar-visible');
                    
                    const isText = node instanceof Konva.Text;
                    const isImage = node instanceof Konva.Image;

                    this.propertiesSidebar.querySelectorAll('[data-type]').forEach(el => el.style.display = 'none');
                    this.propertiesSidebar.querySelectorAll('.menu-tab').forEach(tab => { if (tab.dataset.tab === "transform") tab.style.display = 'flex';});
                     document.getElementById('magicWandControls').style.display = 'none';
                    
                    if (isText) this.propertiesSidebar.querySelectorAll('[data-type="text"]').forEach(el => el.style.display = 'flex');
                    if (isImage) {
                        this.propertiesSidebar.querySelectorAll('[data-type="image"]').forEach(el => el.style.display = 'flex');
                        document.getElementById('magicWandControls').style.display = 'block';
                    }
                    
                    const firstVisibleTab = this.propertiesSidebar.querySelector('.menu-tab[style*="display: flex"]');
                    if(firstVisibleTab && !this.propertiesSidebar.querySelector('.menu-tab.active[style*="display: flex"]')) {
                         this.propertiesSidebar.querySelectorAll('.menu-tab, .tab-pane').forEach(el => el.classList.remove('active'));
                         firstVisibleTab.classList.add('active');
                         document.getElementById(`pane-${firstVisibleTab.dataset.tab}`).classList.add('active');
                    }
                    
                    document.getElementById('selectionRotationSlider').value = node.rotation();
                    document.getElementById('selectionZoomSlider').value = node.scaleX();

                    if(isText) {
                        document.getElementById('textContent').value = node.text();
                        document.getElementById('fontFamily').value = node.fontFamily();
                        document.getElementById('fontSize').value = node.fontSize();
                        document.getElementById('boldBtn').classList.toggle('active', node.fontStyle().includes('bold'));
                        document.getElementById('italicBtn').classList.toggle('active', node.fontStyle().includes('italic'));
                        document.getElementById('underlineBtn').classList.toggle('active', node.textDecoration() === 'underline');
                        const isGradient = node.fillPriority() === 'linear-gradient';
                        document.getElementById('fillType').value = isGradient ? 'gradient' : 'solid';
                        document.getElementById('solidFillOptions').style.display = isGradient ? 'none' : 'block';
                        document.getElementById('gradientFillOptions').style.display = isGradient ? 'block' : 'none';
                        document.getElementById('fillColor').value = node.fill();
                        if(isGradient && node.fillLinearGradientColorStops()){
                            document.getElementById('gradientColor1').value = node.fillLinearGradientColorStops()[1];
                            document.getElementById('gradientColor2').value = node.fillLinearGradientColorStops()[3];
                        }
                        document.getElementById('strokeColor').value = node.stroke() || '#000000';
                        document.getElementById('strokeWidth').value = node.strokeWidth() || 0;
                        document.getElementById('shadowColor').value = node.shadowColor() || '#000000';
                        document.getElementById('shadowBlur').value = node.shadowBlur() || 0;
                        document.getElementById('shadowOffsetX').value = node.shadowOffsetX() || 0;
                        document.getElementById('shadowOffsetY').value = node.shadowOffsetY() || 0;
                    }

                    if (isImage) {
                        const magicParams = node.getAttr('magicWandParams');
                        if (magicParams) {
                            document.getElementById('magicWandTolerance').value = magicParams.tolerance;
                            document.getElementById('magicWandToleranceValue').textContent = magicParams.tolerance;
                            document.getElementById('magicWandFeather').value = magicParams.feather;
                            document.getElementById('magicWandFeatherValue').textContent = magicParams.feather;
                            document.getElementById('magicWandContiguous').checked = magicParams.isContiguous;
                        }
                        const adjustments = node.getAttr('adjustments') || {};
                        const adjustSliders = ['Lightness', 'Contrast', 'Saturation', 'Warmth', 'Tint', 'Hue', 'Highlight', 'Shadow', 'Vignette', 'Sharpen', 'Grain', 'Fade'];
                        adjustSliders.forEach(name => {
                            const key = name.toLowerCase();
                            const value = adjustments[key] || 0;
                            const slider = document.getElementById(`adjust${name}`);
                            const valueLabel = document.getElementById(`adjust${name}Value`);
                            if (slider) slider.value = value;
                            if (valueLabel) valueLabel.textContent = value;
                        });
                    }
                }
                
                hidePropertiesSidebar() { 
                    this.propertiesSidebar.classList.remove('visible');
                    document.body.classList.remove('sidebar-visible');
                }

                toggleFullscreen() { const isFullscreen = document.body.classList.toggle('fullscreen'); document.getElementById('maximizeIcon').style.display = isFullscreen ? 'none' : 'block'; document.getElementById('minimizeIcon').style.display = isFullscreen ? 'block' : 'none'; }
                toggleTheme() { document.body.classList.toggle('dark'); localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light'); this.updateTheme(); this.cm.stage.container().style.backgroundColor = document.body.classList.contains('dark') ? '#2a2a2a' : 'white'; this.cm.drawGrid(); this.cm.addWatermark(); }
                updateTheme() { const isDark = document.body.classList.contains('dark'); document.getElementById('themeIconSun').style.display = isDark ? 'none' : 'block'; document.getElementById('themeIconMoon').style.display = isDark ? 'block' : 'none'; }
                setInitialTheme() { 
                    document.body.classList.add('dark');
                    this.updateTheme(); 
                }
                showToast(message) { const toast = document.getElementById('toast'); toast.textContent = message; toast.classList.add('show'); setTimeout(() => { toast.classList.remove('show'); }, 3000); }
            }

            const cm = new CanvasManager('container');
            const uiManager = new UIManager(cm);
            uiManager.init();
            let imageEditBase64 = null;

            document.getElementById('fileInput').addEventListener('change', (e) => {
                if (e.target.files.length > 0) { Array.from(e.target.files).forEach((file, index) => { const reader = new FileReader(); reader.onload = (event) => cm.addImage(event.target.result, index); reader.readAsDataURL(file); }); e.target.value = ''; }
            });
            document.getElementById('closePreview').addEventListener('click', () => { document.getElementById('previewModal').style.display = 'none'; document.getElementById('previewImage').src = ''; });
            document.addEventListener('keydown', (e) => cm.handleKeyboard(e));
            
            window.addEventListener('click', (e) => {
                const isModalOpen = !!document.querySelector('.modal[style*="display: flex"]');
                if (isModalOpen) return;

                const isOnCanvasPadding = e.target.id === 'canvas-area';

                if (isOnCanvasPadding) {
                    cm.tr.nodes([]);
                    cm.selectedNodes = [];
                    cm.layer.draw();
                    uiManager.hidePropertiesSidebar();
                }
            });

            const aiImageModal = document.getElementById('aiImageModal');
            document.getElementById('closeAiImageModal').addEventListener('click', () => { aiImageModal.style.display = 'none'; });
            function handleImageFile(file) {
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        document.getElementById('imagePreview').src = e.target.result; document.getElementById('imagePreview').style.display = 'block';
                        document.getElementById('dropzoneText').style.display = 'none'; document.getElementById('clearImageBtn').style.display = 'block';
                        imageEditBase64 = e.target.result.split(',')[1];
                    }; reader.readAsDataURL(file);
                } else { uiManager.showToast('Please upload a valid image file.'); }
            }
            const dropzone = document.getElementById('imageDropzone');
            dropzone.addEventListener('click', () => document.getElementById('aiImageInput').click());
            dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.style.borderColor = 'var(--primary)'; });
            dropzone.addEventListener('dragleave', () => { dropzone.style.borderColor = 'var(--border-light)'; });
            dropzone.addEventListener('drop', (e) => { e.preventDefault(); handleImageFile(e.dataTransfer.files[0]); });
            document.getElementById('aiImageInput').addEventListener('change', (e) => handleImageFile(e.target.files[0]));
            document.getElementById('clearImageBtn').addEventListener('click', (e) => {
                e.stopPropagation(); imageEditBase64 = null; document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('dropzoneText').style.display = 'block'; document.getElementById('clearImageBtn').style.display = 'none';
                document.getElementById('aiImageInput').value = '';
            });
            document.getElementById('generateImageBtn').addEventListener('click', async () => {
                const prompt = document.getElementById('aiImagePrompt').value; if (!prompt) { uiManager.showToast("Please enter a prompt."); return; }
                const loader = document.getElementById('aiImageLoader'); const imageEl = document.getElementById('aiGeneratedImage');
                const addBtn = document.getElementById('addAiImageToCanvasBtn'); loader.style.display = 'block'; imageEl.style.display = 'none'; addBtn.style.display = 'none';
                generateImageBtn.disabled = true; generateImageBtn.textContent = "Generating...";
                const apiKey = "AIzaSyAStXuhKO8Dc7gJjvvC26unsZyvhCwGf0E"; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                const parts = [{ text: prompt }]; if (imageEditBase64) { parts.push({ inlineData: { mimeType: "image/png", data: imageEditBase64 } }); }
                const payload = { contents: [{ parts: parts }], generationConfig: { responseModalities: ['IMAGE'] }, };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if(!response.ok) {
                        let errorMessage = `API request failed with status ${response.status}`;
                        try {
                            const errorData = await response.json();
                            errorMessage = errorData?.error?.message || errorMessage;
                        } catch (jsonError) {
                            const errorText = await response.text().catch(() => "Could not read error response.");
                            errorMessage = errorText || errorMessage;
                        }
                        throw new Error(errorMessage);
                    }
                    const result = await response.json();
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                    if (base64Data) {
                        const imageUrl = `data:image/png;base64,${base64Data}`; imageEl.src = imageUrl;
                        imageEl.style.display = 'block'; addBtn.style.display = 'block';
                    } else { throw new Error(result?.promptFeedback?.blockReason || "No image data found in response."); }
                } catch (error) { console.error('Image generation failed:', error); uiManager.showToast(`Error: ${error.message}`); 
                } finally { loader.style.display = 'none'; generateImageBtn.disabled = false; generateImageBtn.textContent = "Generate"; }
            });
            document.getElementById('addAiImageToCanvasBtn').addEventListener('click', () => {
                const imageUrl = document.getElementById('aiGeneratedImage').src; if(imageUrl) cm.addImage(imageUrl);
                aiImageModal.style.display = 'none';
            });
        };
    </script>
</body>
</html>




