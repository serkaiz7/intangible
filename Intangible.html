<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kai Sticker Maker - Pro AI</title>
    <!-- External Libraries -->
    <script src="https://unpkg.com/konva@9.3.14/konva.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
    <!-- Fonts and Icons -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lobster&family=Pacifico&family=Playfair+Display:wght@700&family=Roboto+Slab:wght@400;700&family=Montserrat:wght@400;700&family=Lato:wght@400;700&family=Oswald:wght@400;700&family=Raleway:wght@400;700&family=Poppins:wght@400;600&family=Merriweather:wght@400;700&family=Dancing+Script:wght@400;700&family=Caveat&family=Bebas+Neue&family=Anton&family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- STYLES -->
    <style>
        /* CSS Reset and Global Styles */
        :root {
            --bg-light: #f0f2f5;
            --bg-dark: #121212;
            --surface-light: #ffffff;
            --surface-dark: #1e1e1e;
            --primary: #4a90e2;
            --primary-light: #6aaaf2;
            --accent: #e91e63;
            --text-light: #212529;
            --text-dark: #e9ecef;
            --border-light: #dee2e6;
            --border-dark: #444444;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-family: 'Inter', sans-serif;
        }

        html { box-sizing: border-box; }
        *, *:before, *:after { box-sizing: inherit; }

        body {
            margin: 0; padding: 0; font-family: var(--font-family); background-color: var(--bg-light);
            color: var(--text-light); display: flex; flex-direction: column; height: 100vh;
            overflow: hidden; transition: background-color 0.3s, color 0.3s;
            overscroll-behavior: none;
        }
        body.magic-wand-active .konvajs-content,
        body.crop-tool-active .konvajs-content,
        body.selection-tool-active .konvajs-content { cursor: crosshair; }
        body.multi-select-active .konvajs-content { cursor: crosshair; }
        body.magic-wand-active .konvajs-content { cursor: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L9 9l-7 3 7 3 3 7 3-7 7-3-7-3-3-7z"/><path d="M22 22L12 12"/></svg>') 12 12, auto; }
        
        body.dark {
            --bg-light: var(--bg-dark); --surface-light: var(--surface-dark); --text-light: var(--text-dark);
            --border-light: var(--border-dark); --shadow-color: rgba(0, 0, 0, 0.4);
        }
        
        /* App Views */
        #home-screen { display: block; height: 100vh; overflow-y: auto; }
        #editor-view { display: none; }
        body.editor-active #home-screen { display: block; } /* Keep home screen technically in DOM */
        body.editor-active #home-screen > * { display: none; } /* Hide its children */
        body.editor-active #editor-view { display: block; }
        body { cursor: none; }

        /* Rainbow Cursor Trail */
        .trail-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            pointer-events: none;
            transform: translate(-50%, -50%);
            transition: transform 0.1s ease-out, opacity 0.3s ease-out;
            opacity: 0;
            z-index: 10000;
        }

        /* Home Screen Artistic Styles */
        #home-screen {
            background: linear-gradient(135deg, #a8edea 0%, #fed6e3 100%);
            animation: gradient-animation 15s ease infinite;
            background-size: 200% 200%;
        }
        body.dark #home-screen {
            background: linear-gradient(135deg, #232526 0%, #414345 100%);
        }
        @keyframes gradient-animation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .home-container { max-width: 1200px; margin: 0 auto; padding: 40px 20px; }
        .home-header { text-align: center; margin-bottom: 40px; }
        .home-header h1 {
            font-family: 'Pacifico', cursive;
            font-size: 4rem;
            font-weight: 400;
            margin: 0;
            background: -webkit-linear-gradient(45deg, #e91e63, #4a90e2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 10px rgba(0,0,0,0.1);
        }
        body.dark .home-header h1 {
             background: -webkit-linear-gradient(45deg, #ff80ab, #6aaaf2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .home-header p { font-size: 1.1rem; color: var(--text-light); opacity: 0.7; }
        
        .category-drawer { 
            margin-bottom: 16px; 
            border: none;
            border-radius: 12px; 
            overflow: hidden; 
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            transition: all 0.3s ease;
        }
        body.dark .category-drawer {
            background: rgba(30, 30, 30, 0.5);
        }

        .drawer-header { display: flex; justify-content: space-between; align-items: center; padding: 16px 20px; cursor: pointer; user-select: none; }
        .drawer-header h2 { font-size: 1.25rem; margin: 0; font-weight: 600; }
        .drawer-arrow { transition: transform 0.3s ease; }
        .category-drawer.open .drawer-arrow { transform: rotate(180deg); }
        .drawer-content { display: none; padding: 20px; border-top: 1px solid rgba(255,255,255,0.2); grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 20px; }
        .category-drawer.open .drawer-content { display: grid; }

        .preset-card {
            background: rgba(255, 255, 255, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.18);
            border-radius: 10px; padding: 16px;
            text-align: center; transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1); cursor: pointer;
            display: flex; flex-direction: column; justify-content: space-between;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        body.dark .preset-card {
             background: rgba(40, 40, 40, 0.6);
        }
        .preset-card:hover { 
            transform: translateY(-8px) scale(1.03); 
            box-shadow: 0 10px 20px rgba(0,0,0,0.2); 
            background: white;
        }
        body.dark .preset-card:hover {
            background: var(--surface-dark);
        }

        .preset-card-icon { height: 60px; display: flex; align-items: center; justify-content: center; margin-bottom: 12px; }
        .preset-card-icon svg { width: 48px; height: 48px; color: var(--primary); }
        .preset-card-title { font-weight: 600; font-size: 1rem; margin-bottom: 8px; }
        .preset-card-dims { font-size: 0.8rem; opacity: 0.7; }


        /* Top Bar */
        .top-bar {
            position: fixed; top: 0; left: 0; width: 100%; height: 42px; background-color: var(--surface-light);
            border-bottom: 1px solid var(--border-light); z-index: 999; display: flex; align-items: center; padding: 0 16px;
        }
        .top-bar-group { display: flex; align-items: center; gap: 8px; }
        #backToHomeBtn { border-right: 1px solid var(--border-light); padding-right: 16px; margin-right: 8px; }

        .tabs-container { flex-grow: 1; display: flex; flex-wrap: nowrap; overflow-x: auto; height: 100%; align-items: flex-end; padding: 0 5px; }
        .tab {
            display: flex; align-items: center; padding: 8px 12px; background-color: transparent;
            border: 1px solid transparent; border-bottom: none; border-radius: 8px 8px 0 0;
            margin-right: 4px; cursor: pointer; font-size: 14px; white-space: nowrap;
            transition: all 0.2s ease; position: relative; max-width: 150px;
            color: var(--text-light); opacity: 0.7; border-color: var(--border-light);
        }
        .tab:hover { background-color: var(--bg-light); opacity: 1;}
        .tab.active { background-color: var(--bg-light); font-weight: 600; opacity: 1; border-color: var(--border-light); }
        .tab-name { text-overflow: ellipsis; overflow: hidden; }
        .tab-close { margin-left: 8px; border-radius: 50%; width: 18px; height: 18px; display: flex; align-items: center; justify-content: center; font-size: 14px; line-height: 1; transition: background-color 0.2s; }
        .tab-close:hover { background-color: #ff5f57; color: white; }
        .new-tab-btn { padding: 8px; border: none; background: none; cursor: pointer; font-size: 20px; color: var(--text-light); line-height: 1;}
        
        /* Main Content Area */
        #main-content { display: flex; position: relative; height: calc(100vh - 42px); padding-top: 42px; margin-top: -42px; }

        .canvas-area {
            flex-grow: 1; height: 100%;
            display: flex; justify-content: center; align-items: center;
            padding: 80px; overflow: hidden; background-color: var(--bg-light);
            cursor: none; transition: padding 0.3s ease;
        }
        #container { transition: transform 0.2s ease-out; will-change: transform; }
        .konvajs-content { box-shadow: 0 5px 20px rgba(0,0,0,0.15); background-color: white; }
        body.dark .konvajs-content { background-color: #2a2a2a; }

        /* Fullscreen Mode */
        body.fullscreen .top-bar, body.fullscreen .sidebar, body.fullscreen #propertiesSidebar { display: none; }
        body.fullscreen .canvas-area { padding: 0; width: 100% !important; }
        body.fullscreen #main-content { padding-top: 0; }
        
        /* UI container for floating buttons */
        .ui-container { position: fixed; top: 52px; right: 20px; z-index: 9999; display: flex; gap: 10px; }
        body.sidebar-visible .ui-container { right: 300px; }
        body.fullscreen .ui-container { top: 20px; }

        .ui-button {
            width: 44px; height: 44px; border-radius: 50%; background: var(--surface-light);
            border: 1px solid var(--border-light); box-shadow: 0 2px 8px var(--shadow-color);
            display: flex; align-items: center; justify-content: center; cursor: pointer;
            color: var(--text-light); transition: all 0.2s ease;
        }
        .ui-button:hover, .ui-button.active { background: var(--primary); color: white; }
        .ui-button svg { width: 22px; height: 22px; stroke: currentColor; fill: none; stroke-width: 2; }
        .ui-button:disabled { cursor: not-allowed; opacity: 0.5; background: var(--surface-light); color: var(--text-light); }
        .ui-button:disabled:hover { background: var(--surface-light); color: var(--text-light); }
        
        /* Top Bar Controls */
        .top-controls { display: flex; align-items: center; gap: 16px; margin-left: auto; }
        .top-controls .control-wrapper { font-size: 14px; font-weight: 500; display: flex; align-items: center; gap: 8px;}
        .top-controls input[type="range"] { -webkit-appearance: none; appearance: none; width: 100px; height: 4px; background: var(--border-light); border-radius: 5px; outline: none; cursor: pointer; }
        .top-controls input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; appearance: none; width: 16px; height: 16px; background: var(--primary); border-radius: 50%; cursor: pointer; }
        .zoom-btn {
            width: 24px; height: 24px; border-radius: 50%; border: 1px solid var(--border-light);
            background-color: var(--surface-light); color: var(--text-light);
            font-weight: bold; cursor: pointer; display: flex; align-items: center;
            justify-content: center; line-height: 1; font-size: 18px; padding-bottom: 2px;
        }
        .zoom-btn:hover { background-color: var(--bg-light); }

        /* Sidebar Drawer (Left) */
        .sidebar {
            position: fixed; left: 0; top: 42px; height: calc(100% - 42px); width: 280px; background-color: var(--surface-light);
            box-shadow: 4px 0 15px rgba(0,0,0,0.1); transform: translateX(-100%);
            transition: transform 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94); z-index: 1000;
            padding: 20px; overflow-y: auto;
        }
        .sidebar.open { transform: translateX(0); }
        .sidebar h3 { font-size: 16px; font-weight: 600; margin-top: 0; margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid var(--border-light); }
        .sidebar-section { margin-bottom: 25px; }
        .sidebar label { display: block; margin-bottom: 8px; font-size: 14px; font-weight: 500; }
        .sidebar input, .sidebar select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); background-color: var(--bg-light); color: var(--text-light); font-family: inherit; }
        .sidebar .button-group { display: flex; gap: 8px; }
        .sidebar .button-group button { flex: 1; padding: 8px; background: var(--bg-light); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .sidebar .button-group button:hover { background-color: var(--primary-light); color: white; border-color: var(--primary-light); }
        .sidebar-button { width: 100%; padding: 10px; margin-bottom: 10px; background: var(--bg-light); border: 1px solid var(--border-light); border-radius: 6px; color: var(--text-light); font-weight: 500; font-size: 14px; text-align: left; cursor: pointer; display: flex; align-items: center; gap: 10px; transition: all 0.2s ease; }
        .sidebar-button:hover, .sidebar-button.active { background-color: var(--primary); color: white; border-color: var(--primary); }
        .sidebar-button svg { width: 20px; height: 20px; stroke-width: 2; }
        .sidebar-button.ai-button { background-color: var(--accent); color: white; border-color: var(--accent); }
        .sidebar-button.ai-button:hover { opacity: 0.9; }

        /* Properties Sidebar (Right) */
        #propertiesSidebar {
            width: 0; flex-shrink: 0; height: 100%; background-color: var(--surface-light);
            overflow: hidden; transition: width 0.3s ease;
            box-shadow: -2px 0 10px var(--shadow-color); display: flex; flex-direction: column;
        }
        #propertiesSidebar.visible { width: 280px; }
        #sidebarPlaceholder { padding: 20px; text-align: center; color: #aaa; font-style: italic; }
        #propertiesSidebar.visible #sidebarPlaceholder { display: none; }
        #propertiesSidebar:not(.visible) .menu-tabs, #propertiesSidebar:not(.visible) .menu-content { display: none; }

        .menu-tabs { display: flex; border-bottom: 1px solid var(--border-light); padding: 0 12px; flex-wrap: wrap;}
        .menu-tab { padding: 10px 12px; cursor: pointer; color: var(--text-light); opacity: 0.6; font-weight: 500; border-bottom: 2px solid transparent; }
        .menu-tab.active { opacity: 1; border-bottom: 2px solid var(--primary); }
        .menu-content { padding: 16px; overflow-y: auto; flex-grow: 1; font-size: 14px;}
        .tab-pane { display: none; }
        .tab-pane.active { display: block; animation: fadeIn 0.3s ease; }
        .control-group { margin-bottom: 16px; }
        .control-group label { font-weight: 500; margin-bottom: 8px; display: block; }
        .control-group input, .control-group select, .control-group textarea { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); background-color: var(--bg-light); color: var(--text-light); font-size: 14px; font-family: inherit; }
        .control-group textarea { min-height: 80px; resize: vertical; }
        .control-row { display: flex; align-items: center; gap: 8px; }
        .control-row input[type="color"] { padding: 0; height: 36px; border: none; background: none; }
        .control-row input[type="number"] { width: 70px; }
        .control-group .button-group { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; }
        .control-group .button-group button { padding: 8px; background: var(--bg-light); border: 1px solid var(--border-light); border-radius: 4px; cursor: pointer; transition: all 0.2s; }
        .control-group .button-group button.active { background-color: var(--primary); color: white; }
        
        /* Adjust Pane New Styles */
        .control-group.collapsible { margin-bottom: 8px; border: 1px solid var(--border-light); border-radius: 4px; overflow: hidden; }
        .collapsible-header { display: flex; justify-content: space-between; align-items: center; padding: 8px 12px; cursor: pointer; background-color: var(--bg-light); transition: background-color 0.2s; }
        .collapsible-header:hover { background-color: var(--border-light); }
        .collapsible-header label { margin-bottom: 0; flex-grow: 1; font-weight: 500; font-size: 13px; }
        .collapsible-header .value-display { font-weight: normal; color: #888; }
        body.dark .collapsible-header .value-display { color: #aaa; }
        .collapsible-header .reset-btn { background: none; border: none; cursor: pointer; padding: 2px; line-height: 1; opacity: 0.5; }
        .collapsible-header .reset-btn:hover { opacity: 1; color: var(--accent); }
        .collapsible-header .reset-btn svg { width: 14px; height: 14px; }
        .collapsible-content { display: none; padding: 12px; background-color: var(--surface-light); border-top: 1px solid var(--border-light); }
        .collapsible.active .collapsible-content { display: block; }
        .slider-container { display: flex; align-items: center; gap: 8px; }
        .adjust-btn { width: 28px; height: 28px; border: 1px solid var(--border-light); background-color: var(--bg-light); border-radius: 4px; font-weight: bold; cursor: pointer; }

        /* Floating Image Toolbar */
        .image-toolbar {
            position: absolute;
            display: flex;
            align-items: center;
            gap: 4px;
            background-color: var(--surface-light);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            padding: 6px;
            z-index: 1001;
            transform: translate(-50%, -50%); /* Center on the calculated point */
            transition: opacity 0.2s ease, transform 0.2s ease;
            opacity: 0;
            pointer-events: none;
            user-select: none;
        }
        .image-toolbar.visible {
            opacity: 1;
            pointer-events: auto;
        }
        .toolbar-btn {
            width: 32px;
            height: 32px;
            border: none;
            background-color: transparent;
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-light);
            transition: background-color 0.2s;
        }
        .toolbar-btn:hover {
            background-color: var(--bg-light);
        }
        .toolbar-btn svg {
            width: 20px;
            height: 20px;
        }
        .toolbar-divider {
            width: 1px;
            height: 20px;
            background-color: var(--border-light);
            margin: 0 4px;
        }
        .more-drawer-container {
            position: relative;
        }
        .more-drawer {
            position: absolute;
            bottom: calc(100% + 8px); /* Position above the 'more' button */
            right: 0;
            background-color: var(--surface-light);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow-color);
            padding: 6px;
            width: 200px;
            z-index: 1002;
            display: none;
            flex-direction: column;
            gap: 4px;
            animation: fadeIn 0.15s ease-out;
        }
        .more-drawer.visible {
            display: flex;
        }
        .drawer-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s;
        }
        .drawer-item:hover {
            background-color: var(--bg-light);
        }
        .drawer-item span:first-child {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .drawer-shortcut {
            font-size: 12px;
            color: var(--text-light);
            opacity: 0.6;
        }


        /* Modal Styles */
        .modal { display: none; position: fixed; z-index: 1001; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.6); backdrop-filter: blur(5px); justify-content: center; align-items: center; animation: fadeIn 0.3s ease; }
        .modal-content { background-color: var(--surface-light); padding: 24px; border-radius: 12px; box-shadow: 0 10px 30px var(--shadow-color); width: 90%; max-width: 600px; max-height: 90vh; position: relative; display: flex; flex-direction: column; align-items: center; }
        .modal-content h2 { margin: 0 0 16px 0; font-weight: 600; color: var(--text-light); }
        #previewImage { max-width: 100%; max-height: calc(90vh - 100px); border: 1px solid var(--border-light); border-radius: 8px; background-color: white; }
        .close-modal { position: absolute; top: 15px; right: 20px; font-size: 28px; font-weight: bold; cursor: pointer; transition: color 0.2s; color: #aaa; }
        .close-modal:hover { color: var(--text-light); }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* AI Modal Specific Styles */
        .ai-output-options { display: none; width: 100%; margin-top: 16px; }
        .ai-output-options label { display: block; margin-bottom: 8px; font-size: 14px; font-weight: 500; }
        .ai-output-options select { width: 100%; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); background-color: var(--bg-light); color: var(--text-light); font-family: inherit; }

        .ai-prompt-container { width: 100%; }
        #aiImagePrompt { width: 100%; min-height: 80px; padding: 8px; border-radius: 4px; border: 1px solid var(--border-light); margin-bottom: 8px; }
        #generateImageBtn { width: 100%; padding: 10px; border-radius: 6px; border: none; background-color: var(--accent); color: white; font-weight: 600; cursor: pointer; }
        #aiImageResultContainer { margin-top: 16px; min-height: 100px; width: 100%; display: flex; justify-content: center; align-items: center; border: 1px dashed var(--border-light); border-radius: 8px; padding: 10px; }
        #aiGeneratedImage { max-width: 100%; max-height: 300px; border-radius: 4px; }
        #addAiImageToCanvasBtn { width: 100%; padding: 10px; border: none; background-color: var(--primary); color: white; border-radius: 6px; font-weight: 600; cursor: pointer; margin-top: 16px; }
        #imageDropzone { border: 2px dashed var(--border-light); border-radius: 8px; padding: 10px; text-align: center; cursor: pointer; transition: border-color 0.2s; min-height: 80px; display: flex; justify-content: center; align-items: center; margin-top: 16px; position: relative; }
        #imageDropzone:hover { border-color: var(--primary); }
        #imagePreview { max-width: 100%; max-height: 100px; border-radius: 4px; display: none; }
        #clearImageBtn { position: absolute; top: -10px; right: -10px; width: 24px; height: 24px; border-radius: 50%; background-color: var(--accent); color: white; border: none; cursor: pointer; font-weight: bold; display: none; }

        /* Toast Notification */
        .toast { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); background-color: #333; color: white; padding: 12px 20px; border-radius: 8px; z-index: 2000; visibility: hidden; opacity: 0; transition: opacity 0.3s, visibility 0.3s; }
        .toast.show { visibility: visible; opacity: 1; }
        .hidden-input { display: none; }

        /* Floating Prompt Generator Drawer */
        #prompt-drawer-toggle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            cursor: pointer;
            border: none;
            display: none; /* Hide by default */
            align-items: center;
            justify-content: center;
            position: fixed;
            bottom: 20px;
            right: 20px;
            z-index: 1002;
            overflow: hidden;
            transition: transform 0.3s ease;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        body.editor-active #prompt-drawer-toggle {
            display: flex;
        }

        #prompt-drawer-toggle:hover {
            transform: scale(1.1);
        }

        #prompt-drawer-toggle::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background:
                radial-gradient(circle at 10% 20%, rgba(255,255,255,0.3) 0%, rgba(255,255,255,0) 25%),
                radial-gradient(circle at 80% 70%, rgba(255,255,255,0.2) 0%, rgba(255,255,255,0) 20%),
                radial-gradient(circle at 50% 50%, #444 0%, #111 100%);
            opacity: 0.8;
        }

        @keyframes rainbow-burn {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        #prompt-drawer-toggle::after {
            content: '';
            position: absolute;
            top: -5px; left: -5px;
            right: -5px; bottom: -5px;
            background: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #8b00ff, #ff0000);
            background-size: 200% 200%;
            z-index: -1;
            animation: rainbow-burn 4s linear infinite;
            filter: blur(5px);
        }

        #prompt-drawer-toggle svg {
            width: 32px;
            height: 32px;
            color: white;
            z-index: 1;
            filter: drop-shadow(0 0 5px rgba(0,0,0,0.5));
        }

        #prompt-generator-content {
            background: rgba(23, 25, 35, 0.6);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 20px;
            width: 90vw;
            max-width: 800px; /* Increased max-width for new layout */
            max-height: 90vh;
            overflow-y: auto;
            position: relative; /* For close button */
        }

        #close-prompt-generator {
            position: absolute;
            top: 10px;
            right: 15px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.2s;
            color: #94a3b8;
            z-index: 1005; /* Ensure it's above bg shapes */
        }
        #close-prompt-generator:hover {
            color: #e2e8f0;
        }

        /* --- New Prompt Generator Styles --- */
         .prompt-gen-body {
            font-family: 'Roboto', sans-serif;
            color: #e2e8f0;
            position: relative;
            z-index: 2;
        }
        .prompt-gen-body .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .prompt-gen-body .glass-card {
            background: rgba(23, 25, 35, 0.6);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .prompt-gen-body .neon-button {
            transition: all 0.3s ease;
            box-shadow: 0 0 5px #0ea5e9, 0 0 15px #0ea5e9, 0 0 25px #0ea5e9;
        }
        .prompt-gen-body .neon-button:hover {
            box-shadow: 0 0 10px #0ea5e9, 0 0 25px #0ea5e9, 0 0 50px #0ea5e9;
            transform: translateY(-2px);
        }
        .prompt-gen-body select {
            -webkit-appearance: none; -moz-appearance: none; appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%230ea5e9" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position-x: 98%;
            background-position-y: 50%;
        }
        .bg-shapes {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            z-index: 1;
        }
        .bg-shapes div { position: absolute; list-style: none; display: block; width: 20px; height: 20px; background: rgba(14, 165, 233, 0.2); bottom: -150px; animation: rise 25s infinite linear; border-radius: 4px; }
        .bg-shapes div:nth-child(1) { left: 25%; width: 80px; height: 80px; animation-delay: 0s; }
        .bg-shapes div:nth-child(2) { left: 10%; width: 20px; height: 20px; animation-delay: 2s; animation-duration: 12s; }
        .bg-shapes div:nth-child(3) { left: 70%; width: 20px; height: 20px; animation-delay: 4s; }
        .bg-shapes div:nth-child(4) { left: 40%; width: 60px; height: 60px; animation-delay: 0s; animation-duration: 18s; }
        .bg-shapes div:nth-child(5) { left: 65%; width: 20px; height: 20px; animation-delay: 0s; }
        .bg-shapes div:nth-child(6) { left: 75%; width: 110px; height: 110px; animation-delay: 3s; }
        .bg-shapes div:nth-child(7) { left: 35%; width: 150px; height: 150px; animation-delay: 7s; }
        .bg-shapes div:nth-child(8) { left: 50%; width: 25px; height: 25px; animation-delay: 15s; animation-duration: 45s; }
        .bg-shapes div:nth-child(9) { left: 20%; width: 15px; height: 15px; animation-delay: 2s; animation-duration: 35s; }
        .bg-shapes div:nth-child(10) { left: 85%; width: 150px; height: 150px; animation-delay: 0s; animation-duration: 11s; }
        @keyframes rise { 0% { transform: translateY(0) rotate(0deg); opacity: 1; border-radius: 4px; } 100% { transform: translateY(-120vh) rotate(720deg); opacity: 0; border-radius: 50%; } }
        
        .prompt-gen-body .toggle-switch { display: inline-flex; background-color: #1e293b; border-radius: 9999px; border: 1px solid rgba(14, 165, 233, 0.3); padding: 4px; }
        .prompt-gen-body .toggle-switch input { display: none; }
        .prompt-gen-body .toggle-switch label { cursor: pointer; padding: 0.5rem 1rem; border-radius: 9999px; transition: all 0.3s ease; color: #94a3b8; font-weight: 600; white-space: nowrap; }
        .prompt-gen-body .toggle-switch input:checked + label { background-color: #0ea5e9; color: #0c0f14; box-shadow: 0 0 10px #0ea5e9; }
        
        .prompt-gen-body input[type="text"], .prompt-gen-body select, .prompt-gen-body textarea, .prompt-gen-body p#prompt-output {
             background-color: #0f172a; /* bg-slate-900/80 */
             border: 1px solid rgba(3, 105, 161, 0.5); /* border-sky-700/50 */
             width: 100%;
             border-radius: 0.5rem;
             padding: 0.75rem 1rem;
             font-size: 1rem;
             color: #e2e8f0;
        }
        .prompt-gen-body input[type="text"]:focus, .prompt-gen-body select:focus, .prompt-gen-body textarea:focus {
             outline: none;
             box-shadow: 0 0 0 2px #0ea5e9;
        }
        .prompt-gen-body .space-y-6 > * + * { margin-top: 1.5rem; }
        .prompt-gen-body .mb-8 { margin-bottom: 2rem; }
        .prompt-gen-body .text-center { text-align: center; }
        .prompt-gen-body h1 { font-size: 1.875rem; font-weight: 700; letter-spacing: 0.05em; color: #38bdf8; }
        @media (min-width: 768px) { .prompt-gen-body h1 { font-size: 2.25rem; } }
        .prompt-gen-body header p { color: #94a3b8; margin-top: 0.5rem; }
        .prompt-gen-body .flex { display: flex; }
        .prompt-gen-body .flex-col { flex-direction: column; }
        .prompt-gen-body .items-center { align-items: center; }
        .prompt-gen-body .mb-4 { margin-bottom: 1rem; }
        .prompt-gen-body label { font-size: 0.875rem; margin-bottom: 0.5rem; display: block; color: #38bdf8;}
        .prompt-gen-body .sm\:flex-row { flex-direction: column; }
        @media (min-width: 640px) { .prompt-gen-body .sm\:flex-row { flex-direction: row; } }
        .prompt-gen-body .gap-4 { gap: 1rem; }
        .prompt-gen-body .flex-grow { flex-grow: 1; }
        .prompt-gen-body .flex-shrink-0 { flex-shrink: 0; }
        .prompt-gen-body .self-end { align-self: flex-end; }
        .prompt-gen-body .gap-2 { gap: 0.5rem; }
        .prompt-gen-body .sm\:w-auto { width: 100%; }
        @media (min-width: 640px) { .prompt-gen-body .sm\:w-auto { width: auto; } }
        .prompt-gen-body button { border-radius: 0.5rem; font-weight: 700; padding: 0.75rem; transition: all 0.3s ease; }
        .prompt-gen-body #generate-btn { padding-left: 1.5rem; padding-right: 1.5rem; background-color: #0ea5e9; color: #0f172a; }
        .prompt-gen-body #shuffle-btn, .prompt-gen-body #shuffle-style-btn { padding: 0.75rem 1rem; }
        .prompt-gen-body #shuffle-btn { background-color: #14b8a6; color: #0f172a;}
        .prompt-gen-body #shuffle-btn:hover { background-color: #2dd4bf; box-shadow: 0 4px 15px rgba(20, 184, 166, 0.4); }
        .prompt-gen-body #shuffle-style-btn { background-color: #6366f1; color: #0f172a;}
        .prompt-gen-body #shuffle-style-btn:hover { background-color: #818cf8; box-shadow: 0 4px 15px rgba(99, 102, 241, 0.4); }
        .prompt-gen-body p#prompt-output { min-height: 100px; color: #cbd5e1; user-select: text; }
        .prompt-gen-body .relative { position: relative; }
        .prompt-gen-body #copy-btn { position: absolute; top: 0.5rem; right: 0.5rem; background-color: rgba(51, 65, 85, 0.5); font-size: 0.875rem; border-radius: 0.375rem; padding: 0.25rem 0.75rem; color: #7dd3fc; }
        .prompt-gen-body #copy-btn:hover { background-color: #0284c7; color: white; }
        .prompt-gen-body #use-prompt-btn { position: absolute; bottom: 0.5rem; right: 0.5rem; background-color: rgba(51, 65, 85, 0.5); font-size: 0.875rem; border-radius: 0.375rem; padding: 0.25rem 0.75rem; color: #f472b6; }
        .prompt-gen-body #use-prompt-btn:hover { background-color: #db2777; color: white; }
    </style>
</head>
<body>
    <div id="cursor-trail-container"></div>
    <div id="home-screen">
        <div class="home-container">
            <div class="home-header">
                <h1>Create your design</h1>
                <p>Start with a blank canvas from our popular presets.</p>
            </div>
            <div id="preset-categories"></div>
        </div>
    </div>

    <div id="editor-view">
        <div class="top-bar">
            <div class="top-bar-group">
                <button id="backToHomeBtn" class="ui-button" title="Back to Presets">
                     <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>
                </button>
                <button id="sidebarToggleBtn" class="ui-button" title="Toggle Menu">
                    <svg viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
                </button>
            </div>
            <div id="tabsContainer" class="tabs-container"></div>
            <div class="top-controls">
                <div class="control-wrapper">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>
                    <button id="zoomOutBtn" class="zoom-btn" title="Zoom Out">-</button>
                    <input type="range" id="zoomSlider" min="0.1" max="5" value="1" step="0.01">
                    <button id="zoomInBtn" class="zoom-btn" title="Zoom In">+</button>
                    <span id="zoomValue">100%</span>
                </div>
                <div class="control-wrapper">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.49 15.01l-3.54 3.54-1.5-1.51"/><path d="M3.51 9a9 9 0 102.13 12.37"/></svg>
                    <button id="rotationOutBtn" class="zoom-btn" title="Rotate Left">-</button>
                    <input type="range" id="rotationSlider" min="-180" max="180" value="0" step="1">
                    <button id="rotationInBtn" class="zoom-btn" title="Rotate Right">+</button>
                    <span id="rotationValue">0°</span>
                </div>
            </div>
        </div>
        
        <div id="main-content">
            <div id="sidebar" class="sidebar"></div>
            <div id="canvas-area" class="canvas-area">
                <div id="container"></div>
            </div>
            <div id="propertiesSidebar">
                <div id="sidebarPlaceholder">Select an item to see its properties.</div>
                <div class="menu-tabs">
                    <div class="menu-tab active" data-tab="transform">Transform</div>
                    <div class="menu-tab" data-tab="text" data-type="text">Text</div>
                    <div class="menu-tab" data-tab="fill" data-type="text">Fill</div>
                    <div class="menu-tab" data-tab="effects" data-type="text">Effects</div>
                    <div class="menu-tab" data-tab="image" data-type="image">Image</div>
                    <div class="menu-tab" data-tab="adjust" data-type="image">Adjust</div>
                </div>
                <div class="menu-content">
                    <div class="tab-pane active" id="pane-transform">
                        <div class="control-group">
                            <div class="control-row" style="justify-content: space-between; margin-bottom: 8px;">
                                <label for="selectionRotationSlider">Rotation</label>
                                <span id="selectionRotationValue">0°</span>
                            </div>
                            <div class="slider-container">
                                <button class="adjust-btn" id="selectionRotationMinusBtn">-</button>
                                <input type="range" id="selectionRotationSlider" min="-180" max="180" value="0" step="1">
                                <button class="adjust-btn" id="selectionRotationPlusBtn">+</button>
                            </div>
                        </div>
                        <div class="control-group">
                             <div class="control-row" style="justify-content: space-between; margin-bottom: 8px;">
                                <label for="selectionZoomSlider">Scale</label>
                                <span id="selectionScaleValue">100%</span>
                            </div>
                            <div class="slider-container">
                                <button class="adjust-btn" id="selectionScaleMinusBtn">-</button>
                                <input type="range" id="selectionZoomSlider" min="0.1" max="10" value="1" step="0.01">
                                <button class="adjust-btn" id="selectionScalePlusBtn">+</button>
                            </div>
                        </div>
                        <div class="control-group"><button id="deleteBtn" class="sidebar-button" style="background-color: #ff5f57; color: white; border-color: #ff5f57;">Delete</button></div>
                    </div>
                    <div class="tab-pane" id="pane-text">
                        <div class="control-group"><label for="text-content">Text Content</label><textarea id="textContent"></textarea></div>
                        <div class="control-group">
                            <label for="fontFamily">Font Family</label>
                            <select id="fontFamily">
                                <optgroup label="Web Safe"><option value="Inter">Inter</option><option value="Arial">Arial</option><option value="Georgia">Georgia</option></optgroup>
                                <optgroup label="Display & Script"><option value="Anton" style="font-family: 'Anton';">Anton</option><option value="Bebas Neue" style="font-family: 'Bebas Neue';">Bebas Neue</option><option value="Caveat" style="font-family: 'Caveat';">Caveat</option><option value="Dancing Script" style="font-family: 'Dancing Script';">Dancing Script</option><option value="Lobster" style="font-family: 'Lobster';">Lobster</option><option value="Oswald" style="font-family: 'Oswald';">Oswald</option><option value="Pacifico" style="font-family: 'Pacifico';">Pacifico</option></optgroup>
                                <optgroup label="Serif"><option value="Merriweather" style="font-family: 'Merriweather';">Merriweather</option><option value="Playfair Display" style="font-family: 'Playfair Display';">Playfair Display</option><option value="Roboto Slab" style="font-family: 'Roboto Slab';">Roboto Slab</option></optgroup>
                                <optgroup label="Sans-Serif"><option value="Lato" style="font-family: 'Lato';">Lato</option><option value="Montserrat" style="font-family: 'Montserrat';">Montserrat</option><option value="Poppins" style="font-family: 'Poppins';">Poppins</option><option value="Raleway" style="font-family: 'Raleway';">Raleway</option></optgroup>
                            </select>
                        </div>
                        <div class="control-row">
                            <div class="control-group"><label for="fontSize">Size</label><input type="number" id="fontSize" value="32" min="1"></div>
                            <div class="control-group"><label>Style</label><div class="button-group"><button id="boldBtn"><b>B</b></button><button id="italicBtn"><i>I</i></button><button id="underlineBtn"><u>U</u></button></div></div>
                        </div>
                    </div>
                    <div class="tab-pane" id="pane-fill">
                        <div class="control-group"><label>Fill Type</label><select id="fillType"><option value="solid">Solid Color</option><option value="gradient">Linear Gradient</option></select></div>
                        <div id="solidFillOptions"><div class="control-group"><label for="fillColor">Color</label><input type="color" id="fillColor" value="#000000"></div></div>
                        <div id="gradientFillOptions" style="display:none;"><div class="control-group"><label>Colors</label><div class="control-row"><input type="color" id="gradientColor1" value="#ff0000"><input type="color" id="gradientColor2" value="#0000ff"></div></div><div class="control-group"><label for="gradientRotation">Angle</label><input type="range" id="gradientRotation" min="0" max="360" value="0" step="1"></div></div>
                    </div>
                    <div class="tab-pane" id="pane-effects">
                         <div class="control-group"><label>Stroke (Outline)</label><div class="control-row"><input type="color" id="strokeColor" value="#000000"><input type="number" id="strokeWidth" value="0" min="0" max="50"></div></div>
                        <div class="control-group"><label>Shadow</label><div class="control-row"><input type="color" id="shadowColor" value="#000000"><input type="number" id="shadowBlur" placeholder="Blur" value="0" min="0" max="50"></div><div class="control-row" style="margin-top: 8px;"><input type="number" id="shadowOffsetX" placeholder="X" value="0"><input type="number" id="shadowOffsetY" placeholder="Y" value="0"></div></div>
                    </div>
                    <div class="tab-pane" id="pane-image">
                        <div class="control-group">
                            <button id="selectionToolBtn" class="sidebar-button"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="16" y2="21"></line><line x1="3" y1="8" x2="21" y2="8"></line><line x1="3" y1="16" x2="21" y2="16"></line></svg><span>Selection Tool</span></button>
                            <button id="magicWandBtn" class="sidebar-button"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor"><path d="M12 2L9 9l-7 3 7 3 3 7 3-7 7-3-7-3-3-7z"/><path d="M22 22L12 12"/></svg><span>Magic Wand</span></button>
                            <button id="cropToolBtn" class="sidebar-button"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path></svg><span>Crop Tool</span></button>
                        </div>
                        <div class="control-group" id="magicWandControls" style="display:none;">
                            <label for="magicWandTolerance">Tolerance: <span id="magicWandToleranceValue">20</span></label>
                            <div class="slider-container">
                                <button class="adjust-btn" id="magicWandToleranceMinus">-</button>
                                <input type="range" id="magicWandTolerance" min="0" max="255" value="20">
                                <button class="adjust-btn" id="magicWandTolerancePlus">+</button>
                            </div>
                            <label for="magicWandFeather" style="margin-top: 8px;">Feather: <span id="magicWandFeatherValue">0</span></label>
                            <div class="slider-container">
                                <button class="adjust-btn" id="magicWandFeatherMinus">-</button>
                                <input type="range" id="magicWandFeather" min="-50" max="50" value="0">
                                <button class="adjust-btn" id="magicWandFeatherPlus">+</button>
                            </div>
                            <div style="display: flex; align-items: center; margin-top: 8px;"><input type="checkbox" id="magicWandContiguous" checked style="width: auto; margin-right: 8px;"><label for="magicWandContiguous" style="margin-bottom: 0;">Contiguous</label></div>
                            <p style="font-size:12px; opacity:0.7; margin-top:8px;">Click a color on the image to remove it. Adjust sliders to refine. Press Esc to cancel.</p>
                        </div>
                    </div>
                    <div class="tab-pane" id="pane-adjust">
                        <div class="control-group"><button id="resetAllAdjustmentsBtn" class="sidebar-button">Reset All Adjustments</button></div>
                        <div id="adjustmentsContainer"></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="ui-container">
            <button id="multiSelectToolBtn" class="ui-button" title="Selection Tool (V)"><svg viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"></path><path d="M9 12l-6 -9l18 6l-10 4l-4 10z"></path></svg></button>
            <button id="undoBtn" class="ui-button" title="Undo (Ctrl+Z)"><svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.38 11.23 17.28 8 12.5 8z"></path></svg></button>
            <button id="redoBtn" class="ui-button" title="Redo (Ctrl+Y)"><svg viewBox="0 0 24 24" fill="currentColor" stroke="none"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.78 0-8.88 3.23-9.87 7.5l-2.37-.78C.22 10.23 4.31 6 9.5 6c2.65 0 5.05.99 6.9 2.6L20 5v9h-9l3.62-3.62z"></path></svg></button>
            <button id="centerViewBtn" class="ui-button" title="Center View"><svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/><circle cx="12" cy="12" r="3"/></svg></button>
            <button id="fullscreenToggleBtn" class="ui-button" title="Toggle Fullscreen"><svg id="maximizeIcon" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg><svg id="minimizeIcon" style="display: none;" viewBox="0 0 24 24"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg></button>
            <button id="themeToggle" class="ui-button" title="Toggle Theme"><svg id="themeIconSun" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg><svg id="themeIconMoon" style="display: none;" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button>
        </div>
    </div>
    
    <input type="file" id="fileInput" accept="image/*" multiple class="hidden-input">
    <input type="file" id="loadProjectInput" accept=".json" class="hidden-input">
    <input type="file" id="aiImageInput" accept="image/*" class="hidden-input">
    
    <!-- Floating Prompt Generator Popup -->
    <div id="prompt-generator-popup" class="modal">
        <div id="prompt-generator-content">
             <div class="bg-shapes"><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div><div></div></div>
            <span id="close-prompt-generator">&times;</span>
            <div class="prompt-gen-body">
                <header class="text-center mb-8">
                    <h1 class="font-orbitron text-3xl md:text-4xl font-bold text-sky-400 tracking-wider">Universal Prompt Generator</h1>
                    <p class="text-slate-400 mt-2">Create unique prompts for characters, scenes, and designs.</p>
                </header>

                <div class="space-y-6 mb-8">
                    <!-- Toggles Section -->
                    <div class="flex flex-col items-center mb-4">
                        <label class="font-orbitron text-sky-400 text-sm mb-2 block">GENERATOR MODE</label>
                        <div class="toggle-switch">
                            <input type="radio" id="single-char" name="prompt-type" value="single" checked>
                            <label for="single-char">Single</label>
                            <input type="radio" id="group-char" name="prompt-type" value="group">
                            <label for="group-char">Group</label>
                            <input type="radio" id="certificate-type" name="prompt-type" value="certificate">
                            <label for="certificate-type">Decorations</label>
                            <input type="radio" id="font-type" name="prompt-type" value="font">
                            <label for="font-type">Fonts</label>
                        </div>
                    </div>


                    <div>
                        <label for="character-input" id="character-label" class="font-orbitron text-sky-400 text-sm mb-2 block">CUSTOM SUBJECT (OPTIONAL)</label>
                        <input type="text" id="character-input" placeholder="e.g., 'a smiling red panda', 'my OC Luna'">
                    </div>

                    <div class="flex flex-col sm:flex-row gap-4">
                        <div id="theme-selector-wrapper" class="flex-grow">
                            <label for="theme-select" class="font-orbitron text-sky-400 text-sm mb-2 block">SELECT THEME</label>
                            <select id="theme-select">
                                <optgroup label="Daily Life">
                                    <option value="House">House</option>
                                    <option value="MorningRoutine">Morning Routine</option>
                                    <option value="Cooking">Cooking</option>
                                    <option value="Hobbies">Hobbies</option>
                                    <option value="Fitness">Fitness</option>
                                    <option value="Bedtime">Bedtime</option>
                                </optgroup>
                                <optgroup label="Places & Activities">
                                    <option value="School">School</option>
                                    <option value="Office">Office</option>
                                    <option value="Canteen">Canteen</option>
                                    <option value="Cafe">Cafe</option>
                                    <option value="Bar">Bar</option>
                                    <option value="Shopping">Shopping</option>
                                    <option value="Game">Gaming</option>
                                    <option value="CityLife">City Life</option>
                                    <option value="BeachDay">Beach Day</option>
                                    <option value="Nature">Nature</option>
                                    <option value="Sports">Sports</option>
                                    <option value="OnTheRoad">On The Road</option>
                                </optgroup>
                                <optgroup label="Fantasy & Sci-Fi">
                                    <option value="Fantasy">Fantasy</option>
                                    <option value="SciFi">Sci-Fi</option>
                                </optgroup>
                            </select>
                        </div>
                        <div class="flex-shrink-0 self-end flex gap-2">
                             <button id="generate-btn" title="Generate New Prompt">
                                 🎲
                             </button>
                             <button id="shuffle-btn" title="Shuffle Elements">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-refresh-cw"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>
                             </button>
                              <button id="shuffle-style-btn" title="Shuffle Style">
                                 <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-edit"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>
                             </button>
                        </div>
                    </div>
                    
                     <div class="flex flex-col sm:flex-row gap-4">
                         <div class="flex-grow">
                             <label for="style-select" class="font-orbitron text-sky-400 text-sm mb-2 block">SELECT STYLE</label>
                             <select id="style-select">
                                 <optgroup label="Font Styles">
                                     <option value="font_vintage">Vintage Script</option>
                                     <option value="font_futuristic">Futuristic Digital</option>
                                     <option value="font_playful">Playful Hand-drawn</option>
                                     <option value="font_elegant">Elegant Serif</option>
                                     <option value="font_graffiti">Urban Graffiti</option>
                                     <option value="font_artnouveau">Art Nouveau</option>
                                     <option value="font_blackletter">Gothic Blackletter</option>
                                     <option value="font_3d">3D Block</option>
                                     <option value="font_liquid">Liquid Chrome</option>
                                     <option value="font_woodcut">Woodcut Print</option>
                                     <option value="font_neon">Neon Sign</option>
                                     <option value="font_stitch">Stitched Fabric</option>
                                     <option value="font_bubble">Bubble Letters</option>
                                     <option value="font_floral">Floral & Vine</option>
                                 </optgroup>
                                 <optgroup label="Decorative Styles">
                                     <option value="certificate_classic">Elegant Classic</option>
                                     <option value="certificate_modern">Clean Modern</option>
                                     <option value="certificate_vintage">Aged Vintage</option>
                                     <option value="certificate_playful">Playful & Colorful</option>
                                 </optgroup>
                                 <optgroup label="Character & Scene Styles">
                                     <option value="sticker">Kawaii Sticker</option>
                                     <option value="popart">Futuristic Pop Art</option>
                                     <option value="watercolor">Soft Watercolor</option>
                                     <option value="pixel">Pixel Art</option>
                                     <option value="retro">Retro Cartoon</option>
                                     <option value="gothic">Gothic Cute</option>
                                     <option value="minimalist">Minimalist Line Art</option>
                                     <option value="storybook">Storybook Illustration</option>
                                     <option value="clay">Claymation Style</option>
                                     <option value="vaporwave">Vaporwave Aesthetic</option>
                                     <option value="nouveau">Art Nouveau Cute</option>
                                     <option value="ukiyo">Ukiyo-e Chibi</option>
                                     <option value="steampunk">Steampunk Cutout</option>
                                     <option value="cyberpunk">Cyberpunk Chibi</option>
                                     <option value="doodle">Doodle Art</option>
                                     <option value="stainedglass">Stained Glass</option>
                                 </optgroup>
                                 <option value="custom">Custom</option>
                             </select>
                         </div>
                     </div>

                    <div>
                        <label for="custom-style-input" class="font-orbitron text-sky-400 text-sm mb-2 block">PROMPT STYLE EDITOR</label>
                        <textarea id="custom-style-input" rows="5" placeholder="Edit the selected style or write your own..."></textarea>
                    </div>
                </div>

                <div>
                    <label for="prompt-output" class="font-orbitron text-sky-400 text-sm mb-2 block">GENERATED PROMPT</label>
                    <div class="relative">
                        <p id="prompt-output"></p>
                        <button id="copy-btn">Copy</button>
                        <button id="use-prompt-btn">Use</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <button id="prompt-drawer-toggle" title="Toggle Prompt Generator">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 20h9"></path><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4Z"></path><path d="m15 5 3 3"></path></svg>
    </button>

    <div id="previewModal" class="modal"><div class="modal-content"><span id="closePreview" class="close-modal">&times;</span><h2>Finished Product Preview</h2><img id="previewImage" src="" alt="Preview of your design"></div></div>
    <div id="aiImageModal" class="modal"><div class="modal-content"><span id="closeAiImageModal" class="close-modal">&times;</span><h2>✨ AI Image Studio</h2><div class="ai-prompt-container"><textarea id="aiImagePrompt" placeholder="Describe the image you want to create..."></textarea><button id="generateImageBtn">Generate</button></div><div id="imageDropzone"><span id="dropzoneText">Optional: Drop image to edit</span><img id="imagePreview" src="" alt="Preview"/><button id="clearImageBtn">&times;</button></div><div id="aiImageResultContainer"><div id="aiImageLoader" style="display: none;">Generating...</div><img id="aiGeneratedImage" src="" alt="AI Generated Image" style="display:none;"></div><div id="aiOutputOptions" class="ai-output-options"><label for="aiOutputCanvasSize">Create New Canvas For Output</label><select id="aiOutputCanvasSize"></select></div><button id="addAiImageToCanvasBtn" style="display:none;">Add to Canvas</button></div></div>
    <div id="toast" class="toast"></div>
    
    <!-- JAVASCRIPT LOGIC -->
    <script type="module">
        window.onload = function() {
            function debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => { clearTimeout(timeout); func(...args); };
                    clearTimeout(timeout); timeout = setTimeout(later, wait);
                };
            }
            
            function initCursorTrail() {
                const trailContainer = document.getElementById('cursor-trail-container');
                const trailCount = 15;
                const dots = [];
                const colors = ['#ff0000', '#ff7f00', '#ffff00', '#00ff00', '#0000ff', '#4b0082', '#8b00ff'];

                for (let i = 0; i < trailCount; i++) {
                    const dot = document.createElement('div');
                    dot.classList.add('trail-dot');
                    dot.style.backgroundColor = colors[i % colors.length];
                    trailContainer.appendChild(dot);
                    dots.push(dot);
                }

                const coords = { x: 0, y: 0 };
                const positions = Array.from({ length: trailCount }, () => ({ x: 0, y: 0 }));

                window.addEventListener('mousemove', (e) => {
                    coords.x = e.clientX;
                    coords.y = e.clientY;
                });

                function animateDots() {
                    // Move the first dot towards the cursor using easing
                    positions[0].x += (coords.x - positions[0].x) * 0.3;
                    positions[0].y += (coords.y - positions[0].y) * 0.3;

                    // Move subsequent dots towards the previous dot's position
                    for (let i = 1; i < trailCount; i++) {
                        positions[i].x += (positions[i - 1].x - positions[i].x) * 0.3;
                        positions[i].y += (positions[i - 1].y - positions[i].y) * 0.3;
                    }

                    // Apply the new positions and styles to the DOM elements
                    dots.forEach((dot, index) => {
                        const scale = (dots.length - index) / dots.length;
                        dot.style.transform = `translate(${positions[index].x}px, ${positions[index].y}px) scale(${scale})`;
                        dot.style.opacity = scale;
                    });
                    
                    requestAnimationFrame(animateDots);
                }
                animateDots();
            }

            const canvasPresets = {
                'printing_formats': {
                    name: 'Printing Formats',
                    presets: [
                        { name: 'A0 Poster', w_cm: 84.1, h_cm: 118.9, w_in: 33.1, h_in: 46.8 },
                        { name: 'A1 Poster', w_cm: 59.4, h_cm: 84.1, w_in: 23.4, h_in: 33.1 },
                        { name: 'A2 Poster', w_cm: 42, h_cm: 59.4, w_in: 16.5, h_in: 23.4 },
                        { name: 'A3 Document/Poster', w_cm: 29.7, h_cm: 42, w_in: 11.7, h_in: 16.5 },
                        { name: 'A4 Document', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7 },
                        { name: 'A5 Document', w_cm: 14.8, h_cm: 21, w_in: 5.8, h_in: 8.3 },
                        { name: 'A6 Document/Postcard', w_cm: 10.5, h_cm: 14.8, w_in: 4.1, h_in: 5.8 },
                        { name: 'Letter Document', w_cm: 21.6, h_cm: 27.9, w_in: 8.5, h_in: 11 },
                        { name: 'Legal Document', w_cm: 21.6, h_cm: 35.6, w_in: 8.5, h_in: 14 },
                        { name: 'Tabloid/Ledger', w_cm: 27.9, h_cm: 43.2, w_in: 11, h_in: 17 },
                        { name: 'Half Letter', w_cm: 14, h_cm: 21.6, w_in: 5.5, h_in: 8.5 },
                        { name: 'Business Card', w_cm: 8.9, h_cm: 5.1, w_in: 3.5, h_in: 2 },
                        { name: 'Postcard', w_cm: 10.2, h_cm: 15.2, w_in: 4, h_in: 6 },
                        { name: 'Invitation Card', w_cm: 12.7, h_cm: 17.8, w_in: 5, h_in: 7 },
                        { name: 'Greeting Card', w_cm: 17.8, h_cm: 12.7, w_in: 7, h_in: 5 },
                        { name: 'Brochure (Tri-fold)', w_cm: 21.6, h_cm: 27.9, w_in: 8.5, h_in: 11 },
                        { name: 'Flyer (US)', w_cm: 21.6, h_cm: 27.9, w_in: 8.5, h_in: 11 },
                        { name: 'Flyer (ISO)', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7 },
                        { name: 'Menu', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7, note: "A4, A3, or Tabloid" },
                        { name: 'Certificate', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7, note: "A4 or Letter" },
                        { name: 'Calendar', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7, note: "A4, A3, or Tabloid" },
                        { name: 'Bookmark', w_cm: 5, h_cm: 15, w_in: 2, h_in: 6 },
                        { name: 'Ticket', w_cm: 21.6, h_cm: 7, w_in: 8.5, h_in: 2.75 },
                        { name: 'CD/DVD Cover', w_cm: 12, h_cm: 12, w_in: 4.724, h_in: 4.724 },
                        { name: 'Book Cover (Standard)', w_cm: 15.2, h_cm: 22.9, w_in: 6, h_in: 9 },
                        { name: 'Resume/CV', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7, note: "A4 or Letter" },
                        { name: 'Recipe Card', w_px: 800, h_px: 1200 },
                        { name: 'Magazine Cover', w_cm: 21, h_cm: 29.7, w_in: 8.3, h_in: 11.7 },
                        { name: 'Yearbook', w_cm: 21.6, h_cm: 27.9, w_in: 8.5, h_in: 11, note: "A4 or Letter" },
                        { name: 'Wedding Invitation', w_cm: 12.7, h_cm: 17.8, w_in: 5, h_in: 7 },
                    ]
                },
                'stickers': {
                    name: 'Stickers',
                    presets: [
                        { name: 'Round Sticker', w_in: 2, h_in: 2, note: "1-4 in diameter" },
                        { name: 'Square Sticker', w_in: 3, h_in: 3, note: "2x2, 3x3, 4x4 in" },
                        { name: 'Rectangle Sticker', w_in: 3, h_in: 2, note: "2x3, 3x4, 4x6 in" },
                        { name: 'Oval Sticker', w_in: 3, h_in: 2, note: "1.5x2.5, 2x3, 3x4 in" },
                        { name: 'Die-cut Sticker', w_in: 4, h_in: 4, note: "Custom size" },
                        { name: 'Sticker Sheet', w_in: 8.5, h_in: 11, note: "Letter or A4" },
                    ]
                },
                'print_on_demand': {
                    name: 'Print-on-Demand & Tarpaulin',
                    presets: [
                        { name: 'Mug (Wrap Design)', w_px: 2550, h_px: 900 },
                        { name: 'Mug (Single Side)', w_in: 3, h_in: 3 },
                        { name: 'T-shirt Design (Front)', w_px: 3600, h_px: 4800 },
                        { name: 'Tote Bag', w_px: 4200, h_px: 4800 },
                        { name: 'Pillow/Cushion Cover', w_px: 5400, h_px: 5400 },
                        { name: 'Notebook Cover', w_in: 6, h_in: 9 },
                        { name: 'Phone Case', w_px: 900, h_px: 1800, note: "Varies" },
                        { name: 'Canvas Print (Wall Art)', w_in: 12, h_in: 16, note: "8x10, 12x16, etc." },
                        { name: 'Poster Print (Premium)', w_cm: 29.7, h_cm: 42, note: "A3, A2, etc." },
                        { name: 'Tarpaulin: 2 ft × 3 ft', w_in: 24, h_in: 36, w_px: 7200, h_px: 10800 },
                        { name: 'Tarpaulin: 3 ft × 4 ft', w_in: 36, h_in: 48, w_px: 10800, h_px: 14400 },
                        { name: 'Tarpaulin: 3 ft × 6 ft', w_in: 36, h_in: 72, w_px: 10800, h_px: 21600 },
                        { name: 'Tarpaulin: 4 ft × 8 ft', w_in: 48, h_in: 96, w_px: 14400, h_px: 28800 },
                        { name: 'Tarpaulin: 6 ft × 9 ft', w_in: 72, h_in: 108, w_px: 21600, h_px: 32400 },
                        { name: 'Tarpaulin: 6 ft × 12 ft', w_in: 72, h_in: 144, w_px: 21600, h_px: 43200 },
                        { name: 'Tarpaulin: 8 ft × 12 ft', w_in: 96, h_in: 144, w_px: 28800, h_px: 43200 },
                        { name: 'Tarpaulin: 10 ft × 20 ft', w_in: 120, h_in: 240, w_px: 36000, h_px: 72000 },
                    ]
                },
                'digital_social_media': {
                    name: 'Digital & Social Media',
                    presets: [
                        { name: 'Logo', w_px: 500, h_px: 500 },
                        { name: 'Instagram Post', w_px: 1080, h_px: 1080 },
                        { name: 'Instagram Story', w_px: 1080, h_px: 1920 },
                        { name: 'Facebook Post', w_px: 1200, h_px: 630 },
                        { name: 'Facebook Cover', w_px: 820, h_px: 312 },
                        { name: 'Facebook Event Cover', w_px: 1920, h_px: 1080 },
                        { name: 'Pinterest Pin', w_px: 1000, h_px: 1500 },
                        { name: 'LinkedIn Post', w_px: 1200, h_px: 1200 },
                        { name: 'LinkedIn Banner', w_px: 1584, h_px: 396 },
                        { name: 'Twitter Post (X)', w_px: 1200, h_px: 675 },
                        { name: 'Twitter Header (X)', w_px: 1500, h_px: 500 },
                        { name: 'YouTube Thumbnail', w_px: 1280, h_px: 720 },
                        { name: 'YouTube Channel Art', w_px: 2560, h_px: 1440 },
                        { name: 'Podcast Cover', w_px: 3000, h_px: 3000 },
                        { name: 'Blog Banner', w_px: 1200, h_px: 628 },
                        { name: 'Email Header', w_px: 600, h_px: 200 },
                        { name: 'Desktop Wallpaper', w_px: 1920, h_px: 1080 },
                        { name: 'Mobile Wallpaper', w_px: 1080, h_px: 1920 },
                        { name: 'Infographic', w_px: 800, h_px: 2000 },
                    ]
                },
                'hd_screens': {
                    name: 'HD & Higher Quality Screens',
                    presets: [
                        { name: 'HD (720p)', w_px: 1280, h_px: 720 },
                        { name: 'Full HD (1080p)', w_px: 1920, h_px: 1080 },
                        { name: '2K', w_px: 2560, h_px: 1440 },
                        { name: '4K Ultra HD', w_px: 3840, h_px: 2160 },
                        { name: '5K', w_px: 5120, h_px: 2880 },
                        { name: '8K Ultra HD', w_px: 7680, h_px: 4320 },
                    ]
                }
            };
            
            class CanvasManager {
                constructor(containerId) {
                    this.containerId = containerId;
                    this.container = document.getElementById(containerId);
                    this.stage = null; this.layer = null; this.gridLayer = null; this.watermarkLayer = null; this.tr = null;
                    this.selectedNodes = []; this.clipboardNodes = []; this.history = []; this.historyStep = -1;
                    this.isMagicWandActive = false; this.isCropToolActive = false; this.isSelectionToolActive = false;
                    this.isMultiSelectActive = false; this.selectionRectangle = null; this.cropRect = null; this.selectionRect = null; this.drawingLayer = null;
                    this.gridSize = 20; this.DPI = 300; this.isLandscape = true;
                    this.rotation = 0; this.zoom = 1; this.offsetX = 0; this.offsetY = 0;
                    this.floatingToolbar = null; this.moreDrawer = null;
                    this._transformState = { node: null, lastDist: 0, startTouchAngle: 0, startNodeRotation: 0 };
                    this._panState = { isPanning: false, startX: 0, startY: 0, initialOffsetX: 0, initialOffsetY: 0, initialRotation: 0, initialZoom: 1, mode: '' };
                    this.debouncedApplyAdjustments = debounce(this.applyAdjustments.bind(this), 250);
                    this.debouncedUpdateMagicWand = debounce(this.updateMagicWandLive.bind(this), 200);
                    this._initGlobalCanvasMouseListeners();
                }

                _initGlobalCanvasMouseListeners() {
                    const canvasArea = document.getElementById('canvas-area');
                    this._boundStartCanvasInteraction = this._startCanvasInteraction.bind(this);
                    this._boundMoveCanvasInteraction = this._moveCanvasInteraction.bind(this);
                    this._boundEndCanvasInteraction = this._endCanvasInteraction.bind(this);
                    canvasArea.addEventListener('mousedown', (e) => { if (e.target === canvasArea) this._boundStartCanvasInteraction(e); });
                    canvasArea.addEventListener('touchstart', (e) => { if (e.target === canvasArea) this._boundStartCanvasInteraction(e); }, { passive: false });
                    window.addEventListener('mousemove', this._boundMoveCanvasInteraction);
                    window.addEventListener('mouseup', this._boundEndCanvasInteraction);
                    window.addEventListener('touchmove', this._boundMoveCanvasInteraction, { passive: false });
                    window.addEventListener('touchend', this._boundEndCanvasInteraction);
                }

                _startCanvasInteraction(e) {
                    if (this.isCropToolActive || this.isSelectionToolActive || this.isMultiSelectActive) return;
                    const nativeEvent = e.evt || e;
                    nativeEvent.preventDefault();
                    const touches = nativeEvent.touches;
                    if (touches) {
                        if (touches.length === 1) { this._panState.mode = 'pan'; this._panState.startX = touches[0].clientX; this._panState.startY = touches[0].clientY; this._panState.initialOffsetX = this.offsetX; this._panState.initialOffsetY = this.offsetY; } 
                        else if (touches.length >= 2) { this._panState.mode = 'zoom-rotate'; this._transformState.lastDist = this.getTouchDistance(touches); this._transformState.startTouchAngle = this.getTouchAngle(touches); this._transformState.startNodeRotation = this.rotation; }
                    } else {
                        this._panState.mode = nativeEvent.altKey ? 'rotate-zoom' : 'pan'; this._panState.startX = nativeEvent.clientX; this._panState.startY = nativeEvent.clientY;
                        this._panState.initialOffsetX = this.offsetX; this._panState.initialOffsetY = this.offsetY; this._panState.initialRotation = this.rotation; this._panState.initialZoom = this.zoom;
                        document.getElementById('canvas-area').style.cursor = 'grabbing';
                    }
                    this._panState.isPanning = true;
                }

                _moveCanvasInteraction(e) {
                    if (!this._panState.isPanning) return;
                    const nativeEvent = e.evt || e; nativeEvent.preventDefault();
                    const touches = nativeEvent.touches;
                    if (touches) {
                        if (touches.length === 1 && this._panState.mode === 'pan') { const dx = touches[0].clientX - this._panState.startX; const dy = touches[0].clientY - this._panState.startY; this.offsetX = this._panState.initialOffsetX + dx; this.offsetY = this._panState.initialOffsetY + dy; } 
                        else if (touches.length >= 2 && this._panState.mode === 'zoom-rotate') { const newDist = this.getTouchDistance(touches); const newAngle = this.getTouchAngle(touches); this.setZoom(this.zoom * (newDist / this._transformState.lastDist)); this.setRotation(this._transformState.startNodeRotation + (newAngle - this._transformState.startTouchAngle)); this._transformState.lastDist = newDist; }
                    } else {
                        const dx = nativeEvent.clientX - this._panState.startX; const dy = nativeEvent.clientY - this._panState.startY;
                        if (this._panState.mode === 'pan') { this.offsetX = this._panState.initialOffsetX + dx; this.offsetY = this._panState.initialOffsetY + dy; } 
                        else if (this._panState.mode === 'rotate-zoom') { this.setRotation(this._panState.initialRotation - dy * 0.1); this.setZoom(this._panState.initialZoom + dx * 0.005); }
                    }
                    this.updateContainerTransform();
                }

                _endCanvasInteraction() { if (this._panState.isPanning) { this._panState.isPanning = false; this._panState.mode = ''; document.getElementById('canvas-area').style.cursor = 'none'; } }
                getTouchDistance(touches) { const [t1, t2] = touches; return Math.sqrt(Math.pow(t2.clientX - t1.clientX, 2) + Math.pow(t2.clientY - t1.clientY, 2)); }
                getTouchAngle(touches) { const [t1, t2] = touches; return Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX) * 180 / Math.PI; }

                _createTransformer() {
                    return new Konva.Transformer({
                        anchorStroke: '#4a90e2', anchorFill: 'white', anchorSize: 12, borderStroke: '#4a90e2',
                        borderDash: [4, 4], rotateAnchorOffset: 30, centeredScaling: true
                    });
                }

                initStage(width, height) {
                    if(this.stage) this.stage.destroy();
                    this.canvasWidth = width; this.canvasHeight = height;
                    this.stage = new Konva.Stage({ container: this.containerId, width: width, height: height });
                    this.stage.container().style.backgroundColor = document.body.classList.contains('dark') ? '#2a2a2a' : 'white';
                    this.layer = new Konva.Layer({ id: 'main-layer' }); this.gridLayer = new Konva.Layer({ id: 'grid-layer' });
                    this.watermarkLayer = new Konva.Layer({ id: 'watermark-layer', listening: false });
                    this.controlsLayer = new Konva.Layer({ id: 'controls-layer' });
                    this.stage.add(this.gridLayer, this.layer, this.watermarkLayer, this.controlsLayer);
                    this.tr = this._createTransformer();
                    this.layer.add(this.tr); this.drawGrid(); this.addWatermark(); this.attachStageListeners(); this.centerView();
                    this.saveHistory();
                }

                attachStageListeners() { 
                    this.stage.on('click tap', (e) => this.handleSelect(e)); 
                    document.getElementById('canvas-area').addEventListener('wheel', (e) => this.handleWheelZoom(e), { passive: false });
                    this.stage.on('mousedown touchstart', (e) => { if (e.target === this.stage) this._startCanvasInteraction(e); });
                    this.stage.on('touchstart', (e) => {
                        e.evt.preventDefault(); const touches = e.evt.touches;
                        if (touches.length >= 2) {
                            const target = e.target.getDraggable() ? e.target : e.target.getParent();
                            if (target && target !== this.stage && this.selectedNodes.includes(target)) {
                                 this._transformState.node = target; this.tr.hide(); this.layer.draw();
                                 this._transformState.startNodeRotation = this._transformState.node.rotation();
                                 this._transformState.startTouchAngle = this.getTouchAngle(touches);
                            } else { this._transformState.node = null; }
                            this._transformState.lastDist = this.getTouchDistance(touches);
                        }
                    });
                    this.stage.on('touchmove', (e) => {
                        e.evt.preventDefault(); const touches = e.evt.touches; if (touches.length < 2) return;
                        if (this._transformState.node) {
                            const node = this._transformState.node; const newDist = this.getTouchDistance(touches);
                            const scaleRatio = newDist / this._transformState.lastDist; node.scale({ x: node.scaleX() * scaleRatio, y: node.scaleY() * scaleRatio });
                            const newAngle = this.getTouchAngle(touches); const angleDelta = newAngle - this._transformState.startTouchAngle;
                            node.rotation(this._transformState.startNodeRotation + angleDelta); this.layer.batchDraw();
                            this._transformState.lastDist = newDist;
                        }
                    });
                    this.stage.on('touchend', (e) => { if (this._transformState.node) { this.tr.nodes([this._transformState.node]); this.tr.show(); this.layer.draw(); } this._transformState.node = null; });
                }
                
                setCanvasSizeFromPreset(preset, isLandscape) {
                    this.isLandscape = isLandscape;
                    let w, h;
                    if (preset.w_px) { w = preset.w_px; h = preset.h_px; } 
                    else if (preset.w_in) { w = Math.round(preset.w_in * this.DPI); h = Math.round(preset.h_in * this.DPI); }
                    else if (preset.w_cm) { w = Math.round((preset.w_cm / 2.54) * this.DPI); h = Math.round((preset.h_cm / 2.54) * this.DPI); }
                    const finalW = isLandscape ? Math.max(w,h) : Math.min(w,h);
                    const finalH = isLandscape ? Math.min(w,h) : Math.max(w,h);
                    this.initStage(finalW, finalH);
                }

                drawGrid() {
                    this.gridLayer.destroyChildren(); const stroke = document.body.classList.contains('dark') ? '#495057' : '#e9ecef';
                    for (let i = 0; i < this.canvasWidth / this.gridSize; i++) { this.gridLayer.add(new Konva.Line({ points: [Math.round(i * this.gridSize) + 0.5, 0, Math.round(i * this.gridSize) + 0.5, this.canvasHeight], stroke: stroke, strokeWidth: 1, listening: false })); }
                    for (let j = 0; j < this.canvasHeight / this.gridSize; j++) { this.gridLayer.add(new Konva.Line({ points: [0, Math.round(j * this.gridSize) + 0.5, this.canvasWidth, Math.round(j * this.gridSize) + 0.5], stroke: stroke, strokeWidth: 1, listening: false })); }
                    this.gridLayer.batchDraw();
                }

                addWatermark() {
                    this.watermarkLayer.destroyChildren(); const text = 'Kaiser'; const fontSize = 60; const fontFamily = 'Georgia, serif';
                    const fill = document.body.classList.contains('dark') ? '#ffffff' : '#000000';
                    const textNode = new Konva.Text({ text, fontSize, fontFamily });
                    const textWidth = textNode.width(); const textHeight = textNode.height();
                    const gapX = textWidth * 1.5; const gapY = textHeight * 2;
                    for (let y = -textHeight; y < this.stage.height() + gapY; y += gapY) {
                        for (let x = -textWidth; x < this.stage.width() + gapX; x += gapX) {
                            this.watermarkLayer.add(new Konva.Text({ x: x, y: y, text, fontSize, fontFamily, fill, opacity: 0.08, rotation: -20, }));
                        }
                    } this.watermarkLayer.batchDraw();
                }

                _bindNodeEvents(node) {
                    if (!node) return;
                    node.off('.events');
                    if (node.draggable()) {
                        node.on('dragmove.events transform.events', () => {
                            this.snapToGrid(node);
                            this._updateControlsPosition(node);
                            this._updateFloatingToolbarPosition(node);
                        });
                        node.on('dragend.events transformend.events', () => {
                            this._updateControlsPosition(node);
                            this._updateFloatingToolbarPosition(node);
                            this.saveHistory();
                        });
                    }
                    if (node instanceof Konva.Text) { node.on('dblclick.events dbltap.events', () => this.editText(node)); }
                }

                addImage(src, index = 0, attrs = {}) {
                    Konva.Image.fromURL(src, (img) => {
                        const defaultAttrs = { x: this.stage.width()/2, y: this.stage.height()/2, draggable: true, name: 'image', id: 'img_' + crypto.randomUUID() };
                        const finalAttrs = { ...defaultAttrs, ...attrs };
                        img.setAttrs(finalAttrs);
                         if (!attrs.width && !attrs.height) {
                            const maxDim = Math.min(this.canvasWidth, this.canvasHeight) * 0.4;
                            const scale = maxDim / Math.max(img.width(), img.height());
                            if (scale < 1) img.scale({ x: scale, y: scale });
                        }
                        img.offsetX(img.width() / 2); img.offsetY(img.height() / 2);
                        img.x(finalAttrs.x); img.y(finalAttrs.y);
                        this.layer.add(img);
                        this._bindNodeEvents(img);
                        this.applyAdjustments(img);
                        this.saveHistory();
                    }, { crossOrigin: 'Anonymous' });
                }

                addText(text = 'Double-click to edit') {
                    const textNode = new Konva.Text({ text, x: 50, y: 50, fontSize: 32, fontFamily: 'Inter', fill: document.body.classList.contains('dark') ? '#e9ecef' : '#212529', draggable: true, });
                    textNode.offsetX(textNode.width() / 2); textNode.offsetY(textNode.height() / 2);
                    textNode.x(textNode.x() + textNode.width() / 2); textNode.y(textNode.y() + textNode.height() / 2);
                    this.layer.add(textNode);
                    this._bindNodeEvents(textNode);
                    this.layer.draw(); 
                    this.saveHistory();
                    return textNode;
                }

                editText(textNode) {
                    textNode.hide(); this.tr.hide(); this.layer.draw(); uiManager.hidePropertiesSidebar();
                    const textPosition = textNode.absolutePosition(); const stageBox = this.stage.container().getBoundingClientRect();
                    const areaPosition = { x: stageBox.left + textPosition.x, y: stageBox.top + textPosition.y, };
                    const textarea = document.createElement('textarea'); document.body.appendChild(textarea);
                    Object.assign(textarea.style, { position: 'absolute', top: areaPosition.y + 'px', left: areaPosition.x + 'px', width: textNode.width() * textNode.scaleX() + 'px', height: textNode.height() * textNode.scaleY() + 'px', fontSize: textNode.fontSize() * textNode.scaleY() + 'px', border: '1px solid #4a90e2', padding: '0px', margin: '0px', overflow: 'hidden', background: 'white', outline: 'none', resize: 'none', lineHeight: textNode.lineHeight(), fontFamily: textNode.fontFamily(), transformOrigin: 'left top', transform: `rotateZ(${this.rotation + textNode.rotation()}deg) scale(${this.zoom})`, textAlign: textNode.align(), color: textNode.fill(), zIndex: 1002, });
                    textarea.value = textNode.text(); textarea.focus();
                    const removeTextarea = () => { if(document.body.contains(textarea)) { 
                        textNode.text(textarea.value); textNode.offsetX(textNode.width() / 2); textNode.offsetY(textNode.height() / 2); textNode.show(); 
                        this.tr.show(); this.layer.draw(); uiManager.showPropertiesSidebar(textNode); document.body.removeChild(textarea); 
                        this.saveHistory(); window.removeEventListener('click', handleOutsideClick); 
                    } };
                    textarea.addEventListener('keydown', (e) => { if (e.key === 'Escape' || (e.key === 'Enter' && !e.shiftKey)) {e.preventDefault(); removeTextarea();} });
                    const handleOutsideClick = (e) => { if (e.target !== textarea) { removeTextarea(); } };
                    setTimeout(() => window.addEventListener('click', handleOutsideClick), 0);
                }

                snapToGrid(node) { node.position({ x: Math.round(node.x() / this.gridSize) * this.gridSize, y: Math.round(node.y() / this.gridSize) * this.gridSize }); this.layer.batchDraw(); }
                
                handleSelect(e) {
                    if (this.isMultiSelectActive || this.isCropToolActive || this.isSelectionToolActive) { return; }
                    const target = e.target;
                    if (this.isMagicWandActive) { if (target === this.selectedNodes[0]) { this.applyMagicWand(target); return; } else { this.exitMagicWandMode(); } }
                    if (target.getParent() instanceof Konva.Transformer) return;
                    const isCtrlPressed = e.evt.ctrlKey || e.evt.metaKey;
                    if (target === this.stage) {
                        this.selectedNodes.forEach(node => this.commitMagicWand(node));
                        this.tr.nodes([]); this.selectedNodes = []; uiManager.hidePropertiesSidebar();
                        this._destroyControls();
                        this._destroyFloatingToolbar();
                    } else {
                        const node = target.getDraggable() ? target : target.getParent();
                        if (node && !(node instanceof Konva.Transformer)) {
                             const isSelected = this.selectedNodes.includes(node);
                             if (isCtrlPressed) { if (isSelected) { this.selectedNodes = this.selectedNodes.filter(n => n !== node); } else { this.selectedNodes.push(node); } } 
                             else { if (!isSelected) { this.selectedNodes.forEach(oldNode => this.commitMagicWand(oldNode)); this.selectedNodes = [node]; } }
                            this.selectedNodes.forEach(n => n.moveToTop());
                            this._destroyFloatingToolbar();
                            if (this.selectedNodes.length === 1) {
                                if (this.selectedNodes[0] instanceof Konva.Image) { this.tr.keepRatio(true); this.tr.rotateEnabled(false); this.tr.enabledAnchors(['top-left', 'top-right', 'bottom-left', 'bottom-right']); this._createControls(this.selectedNodes[0]); this._createFloatingToolbar(this.selectedNodes[0]); } 
                                else { this.tr.keepRatio(false); this.tr.rotateEnabled(true); this.tr.enabledAnchors(undefined); this._destroyControls(); }
                                uiManager.showPropertiesSidebar(this.selectedNodes[0]);
                            } else {
                                this.tr.keepRatio(true); this.tr.rotateEnabled(true); this.tr.enabledAnchors(undefined);
                                this._destroyControls();
                                if (this.selectedNodes.length > 1) { uiManager.hidePropertiesSidebar(); } else { uiManager.showPropertiesSidebar(this.selectedNodes[0]); }
                            } this.tr.nodes(this.selectedNodes);
                            this.tr.moveToTop(); // Ensure transformer is always on top
                        }
                    } this.layer.draw();
                }
                
                handleWheelZoom(e) { e.preventDefault(); this.setZoom(e.deltaY > 0 ? this.zoom / 1.05 : this.zoom * 1.05); }
                centerView() { this.setZoom(1); this.setRotation(0); this.offsetX = 0; this.offsetY = 0; this.updateContainerTransform(); }
                zoomToFit() {
                    requestAnimationFrame(() => {
                        const canvasArea = document.getElementById('canvas-area');
                        const padding = 80 * 2 + 40; // 80px css padding on each side + 20px extra margin each side
                        const availableWidth = canvasArea.clientWidth - padding;
                        const availableHeight = canvasArea.clientHeight - padding;
                        
                        if (!this.stage || availableWidth <= 0 || availableHeight <= 0) {
                            this.centerView();
                            return;
                        }

                        const canvasWidth = this.stage.width();
                        const canvasHeight = this.stage.height();
                        
                        if (canvasWidth <= 0 || canvasHeight <= 0) {
                            this.centerView();
                            return;
                        }
                        
                        const scaleX = availableWidth / canvasWidth;
                        const scaleY = availableHeight / canvasHeight;
                        
                        const newZoom = Math.min(scaleX, scaleY, 5);

                        this.setZoom(newZoom);
                        this.setRotation(0);
                        this.offsetX = 0;
                        this.offsetY = 0;
                        this.updateContainerTransform();
                    });
                }
                updateContainerTransform() { this.container.style.transform = `translateX(${this.offsetX}px) translateY(${this.offsetY}px) rotate(${this.rotation}deg) scale(${this.zoom})`; }
                setRotation(deg) { this.rotation = Math.max(-180, Math.min(deg, 180)); this.updateContainerTransform(); uiManager.updateRotationSlider(this.rotation); }
                setZoom(scale) { this.zoom = Math.max(0.1, Math.min(scale, 5)); this.updateContainerTransform(); uiManager.updateZoomSlider(this.zoom); }
                zoomByStep(direction) {
                    const step = 0.1;
                    const newZoom = this.zoom + (step * direction);
                    this.setZoom(newZoom);
                }
                rotateByStep(direction) {
                    const step = 1;
                    const newRotation = this.rotation + (step * direction);
                    this.setRotation(newRotation);
                }

                updateNodeProperty(prop, value) {
                    if (this.selectedNodes.length !== 1) return;
                    const node = this.selectedNodes[0];
                    if (prop === 'scale') { node.scale({ x: value, y: value }); } 
                    else if (prop === 'rotation') { node.rotation(value); }
                    else if (node instanceof Konva.Text) {
                        let fontStyle = node.fontStyle() || '';
                        switch (prop) {
                            case 'text': node.text(value); break;
                            case 'fontFamily': node.fontFamily(value); break;
                            case 'fontSize': node.fontSize(parseInt(value)); break;
                            case 'fill': node.fill(value); node.fillPriority('color'); break;
                            case 'bold': fontStyle = fontStyle.includes('bold') ? fontStyle.replace('bold', '').trim() : `bold ${fontStyle}`.trim(); node.fontStyle(fontStyle); break;
                            case 'italic': fontStyle = fontStyle.includes('italic') ? fontStyle.replace('italic', '').trim() : `italic ${fontStyle}`.trim(); node.fontStyle(fontStyle); break;
                            case 'underline': node.textDecoration(node.textDecoration() === 'underline' ? '' : 'underline'); break;
                            case 'stroke': node.stroke(value); break;
                            case 'strokeWidth': node.strokeWidth(parseInt(value)); break;
                            case 'shadowColor': node.shadowColor(value); break;
                            case 'shadowBlur': node.shadowBlur(parseInt(value)); break;
                            case 'shadowOffsetX': node.shadowOffsetX(parseInt(value)); break;
                            case 'shadowOffsetY': node.shadowOffsetY(parseInt(value)); break;
                            case 'gradient':
                                node.fillPriority('linear-gradient');
                                const angle = value.angle * (Math.PI / 180);
                                const radius = Math.max(node.width(), node.height()) / 2;
                                node.fillLinearGradientStartPoint({ x: -Math.cos(angle) * radius, y: -Math.sin(angle) * radius });
                                node.fillLinearGradientEndPoint({ x: Math.cos(angle) * radius, y: Math.sin(angle) * radius });
                                node.fillLinearGradientColorStops([0, value.color1, 1, value.color2]);
                                break;
                        } node.offsetX(node.width() / 2); node.offsetY(node.height() / 2);
                    } this.layer.batchDraw();
                }
                
                _createControls(node) {
                    this._destroyControls();

                    const moveIconPath = 'M10 9h4v-4h-4v4zm-6 0h4v-4h-4v4zm12 0h4v-4h-4v4zm-6 6h4v-4h-4v4zm-6 0h4v-4h-4v4zm12 0h4v-4h-4v4zm-6 6h4v-4h-4v4zm-6 0h4v-4h-4v4zm12 0h4v-4h-4v4z';
                    this.moveIcon = new Konva.Path({
                        data: moveIconPath,
                        fill: '#fff',
                        stroke: '#4a90e2',
                        strokeWidth: 1,
                        scale: { x: 0.8, y: 0.8 },
                        draggable: true,
                        hitStrokeWidth: 30, // Increase hit area
                    });
                    this.controlsLayer.add(this.moveIcon);

                    this.moveIcon.on('mouseenter', () => { this.stage.container().style.cursor = 'move'; });
                    this.moveIcon.on('mouseleave', () => { this.stage.container().style.cursor = 'none'; });
                    
                    let initialNodePos = { x: 0, y: 0 };
                    let initialPointerPos = { x: 0, y: 0 };
                    
                    this.moveIcon.on('dragstart', (e) => {
                        this.stage.container().style.cursor = 'grabbing';
                        initialNodePos = node.position();
                        initialPointerPos = this.stage.getPointerPosition();
                        node.draggable(false);
                    });

                    this.moveIcon.on('dragmove', (e) => {
                        const currentPointerPos = this.stage.getPointerPosition();
                        const dx = currentPointerPos.x - initialPointerPos.x;
                        const dy = currentPointerPos.y - initialPointerPos.y;
                        node.position({ x: initialNodePos.x + dx, y: initialNodePos.y + dy });
                        this._updateControlsPosition(node);
                    });

                    this.moveIcon.on('dragend', () => {
                        this.stage.container().style.cursor = 'move';
                        node.draggable(true);
                        this.snapToGrid(node);
                        this.saveHistory();
                    });


                    const rotateIconPath = 'M9 12l-4-4h2.986c1.164-2.463 3.535-4.225 6.224-4.656.74-.117 1.487.132 2.029.674.542.542.791 1.289.674 2.029-1.229 2.74-3.255 4.909-5.908 6.131l2.995-2.995-4 4zM15 12l4 4h-2.986c-1.164 2.463-3.535 4.225-6.224 4.656-.74.117-1.487-.132-2.029-.674s-.791-1.289-.674-2.029c1.229-2.74 3.255-4.909 5.908-6.131l-2.995 2.995 4-4z';
                    this.rotateIcon = new Konva.Path({
                        data: rotateIconPath,
                        fill: '#fff',
                        stroke: '#4a90e2',
                        strokeWidth: 1,
                        draggable: true,
                        scale: { x: 0.9, y: 0.9 },
                        hitStrokeWidth: 30, // Increase hit area
                    });
                    
                    this.rotateIcon.on('mouseenter', () => { this.stage.container().style.cursor = 'grab'; });
                    this.rotateIcon.on('mouseleave', () => { this.stage.container().style.cursor = 'none'; });

                    let startAngleRad = 0;
                    let startNodeRotation = 0;

                    this.rotateIcon.on('dragstart', (e) => {
                        this.stage.container().style.cursor = 'grabbing';
                        node.draggable(false);
                        const center = { x: node.x(), y: node.y() };
                        const pos = this.stage.getPointerPosition();
                        startAngleRad = Math.atan2(pos.y - center.y, pos.x - center.x);
                        startNodeRotation = node.rotation();
                    });

                    this.rotateIcon.on('dragmove', (e) => {
                        const center = { x: node.x(), y: node.y() };
                        const pos = this.stage.getPointerPosition();
                        const currentAngleRad = Math.atan2(pos.y - center.y, pos.x - center.x);
                        const angleDiffRad = currentAngleRad - startAngleRad;
                        const newRotation = startNodeRotation + Konva.Util.radToDeg(angleDiffRad);
                        
                        node.rotation(newRotation);
                        this._updateControlsPosition(node);
                        uiManager.showPropertiesSidebar(node); // Update sidebar in real-time
                    });
                    
                    this.rotateIcon.on('dragend', () => {
                        this.stage.container().style.cursor = 'grab';
                        node.draggable(true);
                        this.saveHistory();
                    });

                    this.controlsLayer.add(this.rotateIcon);
                    this._updateControlsPosition(node);
                }

                _updateControlsPosition(node) {
                    if (!this.moveIcon || !this.rotateIcon || !node.getStage()) return;

                    const rotationRad = Konva.Util.degToRad(node.rotation());
                    const cos = Math.cos(rotationRad);
                    const sin = Math.sin(rotationRad);
                    
                    // Use scaled dimensions for accurate positioning relative to the transformed shape
                    const width = node.width() * node.scaleX();
                    const height = node.height() * node.scaleY();
                    const nodePos = { x: node.x(), y: node.y() };

                    // Helper function to calculate the final position of a point rotated around the node's center
                    const getRotatedPosition = (offsetX, offsetY) => {
                        return {
                            x: nodePos.x + offsetX * cos - offsetY * sin,
                            y: nodePos.y + offsetX * sin + offsetY * cos
                        };
                    };

                    // Position icons diagonally, anchored to the BOTTOM-left corner, outside the image
                    const baseOffsetX = -width / 2;
                    const baseOffsetY = height / 2;

                    const moveIconOffsetX = baseOffsetX - 50;
                    const moveIconOffsetY = baseOffsetY - 70;

                    const rotateIconOffsetX = baseOffsetX - 90;
                    const rotateIconOffsetY = baseOffsetY - 30;


                    // Move Icon position
                    const moveIconCenter = getRotatedPosition(moveIconOffsetX, moveIconOffsetY);
                    this.moveIcon.position({
                        x: moveIconCenter.x - this.moveIcon.width() * this.moveIcon.scaleX() / 2,
                        y: moveIconCenter.y - this.moveIcon.height() * this.moveIcon.scaleY() / 2
                    });
                    
                    // Rotate Icon position
                    const rotateIconCenter = getRotatedPosition(rotateIconOffsetX, rotateIconOffsetY);
                    this.rotateIcon.position({
                        x: rotateIconCenter.x - this.rotateIcon.width() * this.rotateIcon.scaleX() / 2,
                        y: rotateIconCenter.y - this.rotateIcon.height() * this.rotateIcon.scaleY() / 2
                    });
                    
                    this.controlsLayer.draw();
                }

                _destroyControls() {
                    if (this.controlsLayer) {
                        this.controlsLayer.destroyChildren();
                        this.controlsLayer.draw();
                    }
                    this.moveIcon = null;
                    this.rotateIcon = null;
                }

                _createFloatingToolbar(node) {
                    this._destroyFloatingToolbar(); 

                    const toolbar = document.createElement('div');
                    toolbar.className = 'image-toolbar';
                    toolbar.id = 'floating-image-toolbar';
                    toolbar.innerHTML = `
                        <button class="toolbar-btn" id="toolbar-copy" title="Copy (Ctrl+C)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg></button>
                        <button class="toolbar-btn" id="toolbar-cut" title="Cut (Ctrl+X)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg></button>
                        <button class="toolbar-btn" id="toolbar-duplicate" title="Duplicate (Ctrl+D)"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg></button>
                        <button class="toolbar-btn" id="toolbar-autocutout" title="AI Background Cutout"><svg viewBox="0 0 24 24" stroke="currentColor"><path d="M10 3L8 8l-5 2 5 2 2 5 2-5 5-2-5-2-2-5zM18 13l-2 5-5-2 5-2 2-5 2 5z"/></svg></button>
                        <div class="toolbar-divider"></div>
                        <button class="toolbar-btn" id="toolbar-delete" title="Delete"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg></button>
                    `;
                    document.body.appendChild(toolbar);
                    this.floatingToolbar = toolbar;

                    document.getElementById('toolbar-copy').addEventListener('click', () => this.copySelected());
                    document.getElementById('toolbar-cut').addEventListener('click', () => { this.copySelected(); this.deleteSelected(); });
                    document.getElementById('toolbar-duplicate').addEventListener('click', () => this.duplicateSelected());
                    document.getElementById('toolbar-autocutout').addEventListener('click', () => this.autoCutoutBackground());
                    document.getElementById('toolbar-delete').addEventListener('click', () => this.deleteSelected());

                    this._updateFloatingToolbarPosition(node);
                    
                    requestAnimationFrame(() => {
                        if (this.floatingToolbar) this.floatingToolbar.classList.add('visible');
                    });
                }

                _destroyFloatingToolbar() {
                    if (this.floatingToolbar) {
                        this.floatingToolbar.remove();
                        this.floatingToolbar = null;
                    }
                }

                _updateFloatingToolbarPosition(node) {
                    if (!this.floatingToolbar || !node || !node.getStage()) {
                        this._destroyFloatingToolbar();
                        return;
                    }

                    const stage = this.stage;
                    const stageContainer = stage.container();

                    // Replicate logic from _updateControlsPosition for consistent placement
                    const rotationRad = Konva.Util.degToRad(node.rotation());
                    const cos = Math.cos(rotationRad);
                    const sin = Math.sin(rotationRad);
                    
                    const width = node.width() * node.scaleX();
                    const height = node.height() * node.scaleY();
                    const nodePos = { x: node.x(), y: node.y() };

                    const getRotatedPosition = (offsetX, offsetY) => {
                        return {
                            x: nodePos.x + offsetX * cos - offsetY * sin,
                            y: nodePos.y + offsetX * sin + offsetY * cos
                        };
                    };

                    // Position toolbar near the BOTTOM-right corner, symmetrically to the rotate icon
                    const baseOffsetX = width / 2; // right edge
                    const baseOffsetY = height / 2; // bottom edge
                    
                    const toolbarOffsetX = baseOffsetX + 90; // Symmetrical to rotate icon's -90 from left edge
                    const toolbarOffsetY = baseOffsetY - 30;  // Symmetrical to rotate icon's -30 from bottom edge
                    
                    // Get the final stage position of the toolbar's center point
                    const stagePoint = getRotatedPosition(toolbarOffsetX, toolbarOffsetY);

                    // Use a temporary DOM element to find the final screen coordinates,
                    // accounting for canvas pan, zoom, and rotation.
                    const dot = document.createElement('div');
                    dot.style.position = 'absolute';
                    dot.style.left = `${stagePoint.x}px`;
                    dot.style.top = `${stagePoint.y}px`;
                    stageContainer.appendChild(dot);

                    const screenRect = dot.getBoundingClientRect();
                    
                    stageContainer.removeChild(dot);

                    // Position the toolbar using the calculated screen coordinates.
                    this.floatingToolbar.style.left = `${screenRect.left}px`;
                    this.floatingToolbar.style.top = `${screenRect.top}px`;
                }

                _showFloatingToolbar() {
                    if(this.floatingToolbar) this.floatingToolbar.classList.add('visible');
                }

                _hideFloatingToolbar() {
                    if(this.floatingToolbar) this.floatingToolbar.classList.remove('visible');
                }

                toggleMagicWandMode() {
                    if (this.isMagicWandActive) {
                        this.isMagicWandActive = false; document.body.classList.remove('magic-wand-active');
                        document.getElementById('magicWandBtn').classList.remove('active');
                        this.selectedNodes.forEach(node => this.commitMagicWand(node));
                        if (this.selectedNodes.length > 0 && this.selectedNodes[0].draggable() === false) {
                            this.selectedNodes[0].draggable(true); this.tr.nodes(this.selectedNodes);
                            this.tr.show(); this._showFloatingToolbar(); this.layer.draw();
                        }
                    } else {
                        this.exitAllToolModes();
                        if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) { uiManager.showToast('Please select a single image first.'); return; }
                        this.isMagicWandActive = true; document.body.classList.add('magic-wand-active');
                        document.getElementById('magicWandBtn').classList.add('active');
                        uiManager.showToast('Magic Wand active. Click a color to remove.');
                        this.tr.hide(); this._hideFloatingToolbar(); this.selectedNodes[0].draggable(false); this.layer.draw();
                    }
                }

                exitMagicWandMode() { if (this.isMagicWandActive) { this.toggleMagicWandMode(); } }
                commitMagicWand(node) { if (node && node.getAttr('originalImage')) { node.setAttr('originalImage', null); node.setAttr('magicWandParams', null); this.saveHistory(); } }

                updateMagicWandLive() {
                    if (this.selectedNodes.length !== 1) return;
                    const node = this.selectedNodes[0]; const params = node.getAttr('magicWandParams'); if (!params) return;
                    params.tolerance = parseInt(document.getElementById('magicWandTolerance').value, 10);
                    params.feather = parseInt(document.getElementById('magicWandFeather').value, 10);
                    params.isContiguous = document.getElementById('magicWandContiguous').checked;
                    node.setAttr('magicWandParams', params); this._performMagicWandProcessing(node);
                }

                _getMagicWandSelection(imageData, width, height, tolerance, isContiguous, startX, startY) {
                    const { data } = imageData; const pixelsToRemove = new Array(width * height).fill(false);
                    const startIndex = (startY * width + startX) * 4;
                    const startR = data[startIndex]; const startG = data[startIndex + 1]; const startB = data[startIndex + 2];
                    if (isContiguous) {
                        const pixelStack = [[startX, startY]]; const visited = new Array(width * height).fill(false);
                        while (pixelStack.length > 0) {
                            const [x, y] = pixelStack.pop(); const index = y * width + x;
                            if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) { continue; }
                            const dataIndex = index * 4;
                            const r = data[dataIndex]; const g = data[dataIndex + 1]; const b = data[dataIndex + 2];
                            const colorDistance = Math.sqrt(Math.pow(r - startR, 2) + Math.pow(g - startG, 2) + Math.pow(b - startB, 2));
                            visited[index] = true;
                            if (colorDistance <= tolerance) { pixelsToRemove[index] = true; pixelStack.push([x + 1, y]); pixelStack.push([x - 1, y]); pixelStack.push([x, y + 1]); pixelStack.push([x, y - 1]); }
                        }
                    } else { for (let i = 0; i < data.length; i += 4) { const r = data[i]; const g = data[i + 1]; const b = data[i + 2]; const colorDistance = Math.sqrt(Math.pow(r - startR, 2) + Math.pow(g - startG, 2) + Math.pow(b - startB, 2)); if (colorDistance <= tolerance) { pixelsToRemove[i / 4] = true; } } }
                    return pixelsToRemove;
                }
                
                async _performMagicWandProcessing(node) {
                    const originalImage = node.getAttr('originalImage'); const params = node.getAttr('magicWandParams');
                    if (!originalImage || !params) return;
                    const { startX, startY, tolerance, isContiguous, feather } = params;
                    const imageEl = originalImage; const width = imageEl.naturalWidth || imageEl.width; const height = imageEl.naturalHeight || imageEl.height;
                    const tempCanvas = document.createElement('canvas'); tempCanvas.width = width; tempCanvas.height = height;
                    const tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(imageEl, 0, 0, width, height);
                    const imageData = tempCtx.getImageData(0, 0, width, height);
                    const pixelsToRemove = this._getMagicWandSelection(imageData, width, height, tolerance, isContiguous, startX, startY);
                    const { data } = imageData;

                    if (feather > 0) {
                        const distanceMap = new Array(width * height).fill(-1); const queue = [];
                        for (let i = 0; i < pixelsToRemove.length; i++) { if (!pixelsToRemove[i]) { distanceMap[i] = 0; queue.push([i % width, Math.floor(i / width)]); } }
                        let head = 0; const dx = [0, 0, 1, -1]; const dy = [1, -1, 0, 0];
                        while(head < queue.length) {
                            const [x, y] = queue[head++]; const dist = distanceMap[y * width + x]; if (dist >= feather) continue;
                            for(let i = 0; i < 4; i++) {
                                const nx = x + dx[i]; const ny = y + dy[i];
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const nIndex = ny * width + nx; if (distanceMap[nIndex] === -1) { distanceMap[nIndex] = dist + 1; queue.push([nx, ny]); } }
                            }
                        }
                        for (let i = 0; i < pixelsToRemove.length; i++) { if (pixelsToRemove[i]) { const dist = distanceMap[i]; const dataIndex = i * 4; if (dist === -1 || dist > feather) { data[dataIndex + 3] = 0; } else { data[dataIndex + 3] = Math.floor(data[dataIndex + 3] * (dist / feather)); } } }
                    } else if (feather < 0) {
                        const chokeAmount = Math.abs(feather); const distanceMap = new Array(width * height).fill(-1); const queue = [];
                        for (let i = 0; i < pixelsToRemove.length; i++) { if (pixelsToRemove[i]) { distanceMap[i] = 0; queue.push([i % width, Math.floor(i / width)]); } }
                        let head = 0; const dx = [0, 0, 1, -1]; const dy = [1, -1, 0, 0];
                        while (head < queue.length) {
                            const [x, y] = queue[head++]; const dist = distanceMap[y * width + x]; if (dist >= chokeAmount) continue;
                            for (let i = 0; i < 4; i++) {
                                const nx = x + dx[i]; const ny = y + dy[i];
                                if (nx >= 0 && nx < width && ny >= 0 && ny < height) { const nIndex = ny * width + nx; if (distanceMap[nIndex] === -1) { distanceMap[nIndex] = dist + 1; pixelsToRemove[nIndex] = true; queue.push([nx, ny]); } }
                            }
                        }
                         for (let i = 0; i < pixelsToRemove.length; i++) { if (pixelsToRemove[i]) { data[i * 4 + 3] = 0; } }
                    } else { for (let i = 0; i < pixelsToRemove.length; i++) { if (pixelsToRemove[i]) { data[i * 4 + 3] = 0; } } }

                    tempCtx.putImageData(imageData, 0, 0);
                    const newImage = new Image(); newImage.crossOrigin = 'Anonymous'; newImage.src = tempCanvas.toDataURL();
                    return new Promise((resolve) => { newImage.onload = () => { node.image(newImage); node.clearCache(); this.layer.batchDraw(); resolve(); }; });
                }

                async applyMagicWand(target) {
                    if (!this.isMagicWandActive || !(target instanceof Konva.Image)) return;
                    const node = target; this.commitMagicWand(node); node.setAttr('originalImage', node.image());
                    const pos = node.getRelativePointerPosition(); const imageEl = node.image();
                    const naturalWidth = imageEl.naturalWidth || imageEl.width; const naturalHeight = imageEl.naturalHeight || imageEl.height;
                    const startX = Math.floor(pos.x * (naturalWidth / node.width())); const startY = Math.floor(pos.y * (naturalHeight / node.height()));
                    if (startX < 0 || startX >= naturalWidth || startY < 0 || startY >= naturalHeight) { uiManager.showToast('Please click inside the image.'); return; }
                    const tolerance = parseInt(document.getElementById('magicWandTolerance').value, 10);
                    const isContiguous = document.getElementById('magicWandContiguous').checked;
                    const feather = parseInt(document.getElementById('magicWandFeather').value, 10);
                    node.setAttr('magicWandParams', { startX, startY, tolerance, isContiguous, feather });
                    uiManager.showToast('Processing... Adjust sliders to refine.');
                    await this._performMagicWandProcessing(node);
                }

                toggleCropToolMode() {
                    if (this.isCropToolActive) { this.exitCropToolMode(); return; }
                    this.exitAllToolModes();
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) { uiManager.showToast('Please select a single image to crop.'); return; }
                    this.isCropToolActive = true; document.body.classList.add('crop-tool-active');
                    document.getElementById('cropToolBtn').classList.add('active'); uiManager.showToast('Crop Tool active. Draw a rectangle to crop.'); this.tr.hide(); this._hideFloatingToolbar(); this.selectedNodes[0].draggable(false);
                    this.drawingLayer = new Konva.Layer(); this.stage.add(this.drawingLayer);
                    let x1, y1, x2, y2;
                    this.stage.on('mousedown.crop touchstart.crop', (e) => { const pos = this.stage.getPointerPosition(); x1 = pos.x; y1 = pos.y; x2 = pos.x; y2 = pos.y; this.cropRect = new Konva.Rect({ x: x1, y: y1, width: 0, height: 0, stroke: 'rgba(74, 144, 226, 0.8)', strokeWidth: 2, dash: [4, 4], }); this.drawingLayer.add(this.cropRect); });
                    this.stage.on('mousemove.crop touchmove.crop', (e) => { if (!this.cropRect) return; const pos = this.stage.getPointerPosition(); x2 = pos.x; y2 = pos.y; this.cropRect.setAttrs({ x: Math.min(x1, x2), y: Math.min(y1, y2), width: Math.abs(x2 - x1), height: Math.abs(y2 - y1), }); });
                    this.stage.on('mouseup.crop touchend.crop', () => { if (!this.cropRect || this.cropRect.width() < 5) { this.exitCropToolMode(); return; } this.applyCrop(this.selectedNodes[0], this.cropRect.getClientRect()); this.exitCropToolMode(); });
                }

                exitCropToolMode() {
                    if (!this.isCropToolActive) return;
                    this.isCropToolActive = false; document.body.classList.remove('crop-tool-active');
                    document.getElementById('cropToolBtn').classList.remove('active');
                    if (this.drawingLayer) { this.drawingLayer.destroy(); this.drawingLayer = null; }
                    this.cropRect = null; this.stage.off('.crop');
                    if (this.selectedNodes.length > 0) { this.selectedNodes.forEach(n => n.draggable(true)); this.tr.nodes(this.selectedNodes); this.tr.show(); this._showFloatingToolbar(); this.layer.draw(); }
                }
                
                applyCrop(node, cropArea) { const dataURL = node.toDataURL({ ...cropArea, pixelRatio: 3 }); this.addImage(dataURL, 0, { x: cropArea.x + cropArea.width / 2, y: cropArea.y + cropArea.height / 2 }); uiManager.showToast('Image cropped and pasted!'); }

                toggleSelectionToolMode() {
                     if (this.isSelectionToolActive) { this.exitSelectionToolMode(); return; }
                    this.exitAllToolModes();
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) { uiManager.showToast('Please select a single image first.'); return; }
                    this.isSelectionToolActive = true; document.body.classList.add('selection-tool-active');
                    document.getElementById('selectionToolBtn').classList.add('active'); uiManager.showToast('Draw a rectangle, then press Ctrl+C to copy selection.'); this.tr.hide(); this._hideFloatingToolbar(); this.selectedNodes[0].draggable(false);
                    this.drawingLayer = new Konva.Layer(); this.stage.add(this.drawingLayer);
                    let x1, y1; let isDrawingSelection = false;
                    this.stage.on('mousedown.selection touchstart.selection', (e) => {
                        isDrawingSelection = true; if(this.selectionRect) { this.selectionRect.destroy(); }
                        if(this.startPointMarker) { this.startPointMarker.destroy(); }
                        const pos = this.stage.getPointerPosition(); x1 = pos.x; y1 = pos.y;
                        this.startPointMarker = new Konva.Circle({ x: x1, y: y1, radius: 5, fill: 'white', stroke: '#e91e63', strokeWidth: 2 });
                        this.drawingLayer.add(this.startPointMarker);
                        this.selectionRect = new Konva.Rect({ x: x1, y: y1, width: 0, height: 0, stroke: 'rgba(233, 30, 99, 0.9)', strokeWidth: 2, dash: [4, 4], });
                        this.drawingLayer.add(this.selectionRect);
                    });
                    this.stage.on('mousemove.selection touchmove.selection', (e) => { if (!isDrawingSelection) return; const pos = this.stage.getPointerPosition(); this.selectionRect.setAttrs({ x: Math.min(x1, pos.x), y: Math.min(y1, pos.y), width: Math.abs(pos.x - x1), height: Math.abs(pos.y - y1), }); });
                    this.stage.on('mouseup.selection touchend.selection', (e) => { isDrawingSelection = false; });
                }

                exitSelectionToolMode() {
                    if (!this.isSelectionToolActive) return;
                    this.isSelectionToolActive = false; document.body.classList.remove('selection-tool-active');
                    document.getElementById('selectionToolBtn').classList.remove('active');
                    if (this.drawingLayer) { this.drawingLayer.destroy(); this.drawingLayer = null; }
                    this.selectionRect = null; this.startPointMarker = null; this.stage.off('.selection');
                    if (this.selectedNodes.length > 0) { this.selectedNodes.forEach(n => n.draggable(true)); this.tr.nodes(this.selectedNodes); this.tr.show(); this._showFloatingToolbar(); this.layer.draw(); }
                }
                
                toggleMultiSelectMode() {
                    this.isMultiSelectActive = !this.isMultiSelectActive;
                    document.body.classList.toggle('multi-select-active', this.isMultiSelectActive);
                    document.getElementById('multiSelectToolBtn').classList.toggle('active', this.isMultiSelectActive);
                    if (this.isMultiSelectActive) {
                        this.exitAllToolModes(true); this.tr.nodes([]);
                        this.selectionRectangle = new Konva.Rect({ fill: 'rgba(74, 144, 226, 0.3)', visible: false });
                        this.layer.add(this.selectionRectangle);
                        let x1, y1, x2, y2;
                        this.stage.on('mousedown.multiselect', (e) => { if (e.target !== this.stage) { return; } e.evt.preventDefault(); x1 = this.stage.getPointerPosition().x; y1 = this.stage.getPointerPosition().y; x2 = x1; y2 = y1; this.selectionRectangle.visible(true); this.selectionRectangle.width(0); this.selectionRectangle.height(0); });
                        this.stage.on('mousemove.multiselect', (e) => { if (!this.selectionRectangle.visible()) { return; } e.evt.preventDefault(); x2 = this.stage.getPointerPosition().x; y2 = this.stage.getPointerPosition().y; this.selectionRectangle.setAttrs({ x: Math.min(x1, x2), y: Math.min(y1, y2), width: Math.abs(x2 - x1), height: Math.abs(y2 - y1) }); });
                        this.stage.on('mouseup.multiselect', (e) => { if (!this.selectionRectangle.visible()) { return; } e.evt.preventDefault(); this.selectionRectangle.visible(false); const shapes = this.stage.find('.image, Konva.Text'); const box = this.selectionRectangle.getClientRect(); const selected = shapes.filter((shape) => Konva.Util.haveIntersection(box, shape.getClientRect())); this.selectedNodes = selected; this.tr.nodes(selected); this.layer.draw(); });
                    } else { this.stage.off('.multiselect'); if (this.selectionRectangle) { this.selectionRectangle.destroy(); this.selectionRectangle = null; } }
                }

                exitAllToolModes(keepMultiSelect = false) {
                    if (!keepMultiSelect) { if (this.isMultiSelectActive) this.toggleMultiSelectMode(); }
                    if (this.isMagicWandActive) this.exitMagicWandMode(); if (this.isCropToolActive) this.exitCropToolMode();
                    if (this.isSelectionToolActive) this.exitSelectionToolMode();
                }

                copySelectionToClipboard() {
                    if (!this.isSelectionToolActive || this.selectedNodes.length !== 1 || !this.selectionRect || this.selectionRect.width() < 1) { return; }
                    const node = this.selectedNodes[0]; const cropArea = this.selectionRect.getClientRect();
                    const dataURL = node.toDataURL({ ...cropArea, pixelRatio: 3 });
                    this.clipboardNodes = [{ type: 'imageURL', src: dataURL }];
                    uiManager.showToast("Selection copied to clipboard!"); this.exitSelectionToolMode();
                }

                cutSelectionFromImage() {
                    if (!this.isSelectionToolActive || this.selectedNodes.length !== 1 || !this.selectionRect || this.selectionRect.width() < 1) { return; }
                    const node = this.selectedNodes[0]; const cropArea = this.selectionRect.getClientRect();
                    const dataURL = node.toDataURL({ ...cropArea, pixelRatio: 3 });
                    this.clipboardNodes = [{ type: 'imageURL', src: dataURL }]; uiManager.showToast("Selection cut!");
                    const imageElement = node.image(); const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = imageElement.naturalWidth; tempCanvas.height = imageElement.naturalHeight;
                    const tempCtx = tempCanvas.getContext('2d'); tempCtx.drawImage(imageElement, 0, 0);
                    const transform = node.getAbsoluteTransform().copy().invert();
                    const p1 = transform.point({ x: cropArea.x, y: cropArea.y });
                    const p2 = transform.point({ x: cropArea.x + cropArea.width, y: cropArea.y });
                    const p3 = transform.point({ x: cropArea.x + cropArea.width, y: cropArea.y + cropArea.height });
                    const p4 = transform.point({ x: cropArea.x, y: cropArea.y + cropArea.height });
                    tempCtx.save(); tempCtx.beginPath(); tempCtx.moveTo(p1.x, p1.y); tempCtx.lineTo(p2.x, p2.y);
                    tempCtx.lineTo(p3.x, p3.y); tempCtx.lineTo(p4.x, p4.y); tempCtx.closePath();
                    tempCtx.globalCompositeOperation = 'destination-out'; tempCtx.fill(); tempCtx.restore();
                    const newImage = new Image(); newImage.src = tempCanvas.toDataURL();
                    newImage.onload = () => { node.image(newImage); this.layer.batchDraw(); this.saveHistory(); };
                    this.exitSelectionToolMode();
                }

                getPreviewDataURL() { this.tr.hide(); this.gridLayer.hide(); uiManager.hidePropertiesSidebar(); const tempTransform = this.container.style.transform; this.container.style.transform = ''; const dataURL = this.stage.toDataURL({ pixelRatio: 0.5 }); this.container.style.transform = tempTransform; this.tr.show(); this.gridLayer.show(); if(this.selectedNodes.length) uiManager.showPropertiesSidebar(this.selectedNodes[0]); return dataURL; }
                getExportDataURL() { this.tr.hide(); this.gridLayer.hide(); this.watermarkLayer.hide(); uiManager.hidePropertiesSidebar(); const tempTransform = this.container.style.transform; this.container.style.transform = ''; const dataURL = this.stage.toDataURL({ pixelRatio: 2 }); this.container.style.transform = tempTransform; this.tr.show(); this.gridLayer.show(); this.watermarkLayer.show(); if(this.selectedNodes.length) uiManager.showPropertiesSidebar(this.selectedNodes[0]); return dataURL; }
                exportToPNG() { saveAs(this.getExportDataURL(), 'design.png'); }
                exportToPDF() { const pdf = new jspdf.jsPDF({ orientation: this.canvasWidth > this.canvasHeight ? 'landscape' : 'portrait', unit: 'px', format: [this.canvasWidth, this.canvasHeight] }); pdf.addImage(this.getExportDataURL(), 'PNG', 0, 0, this.canvasWidth, this.canvasHeight); pdf.save('design.pdf'); }
                deleteSelected() { if (this.selectedNodes.length === 0) return; uiManager.hidePropertiesSidebar(); this._destroyFloatingToolbar(); this._destroyControls(); this.selectedNodes.forEach(node => node.destroy()); this.tr.nodes([]); this.selectedNodes = []; this.layer.draw(); this.saveHistory(); }
                copySelected() { if (this.selectedNodes.length > 0) { this.clipboardNodes = this.selectedNodes.map(node => node.clone()); uiManager.showToast(`${this.selectedNodes.length} item(s) copied!`); } }
                pasteFromClipboard() {
                    if (!this.clipboardNodes || this.clipboardNodes.length === 0) { uiManager.showToast('Nothing to paste.'); return; }
                     if (this.clipboardNodes[0].type === 'imageURL') { this.addImage(this.clipboardNodes[0].src); this.clipboardNodes = []; return; }
                    const newNodes = [];
                    this.clipboardNodes.forEach(nodeToClone => {
                        const newNode = nodeToClone.clone(); if (newNode instanceof Konva.Image) { newNode.id('img_' + crypto.randomUUID()); }
                        newNode.x(newNode.x() + 20); newNode.y(newNode.y() + 20); newNode.draggable(true);
                        this.layer.add(newNode); this._bindNodeEvents(newNode); newNodes.push(newNode);
                    });
                    this.tr.nodes(newNodes); this.selectedNodes = newNodes; this.layer.draw(); this.saveHistory();
                }

                duplicateSelected() {
                    if (this.selectedNodes.length !== 1) return;
                    const node = this.selectedNodes[0];
                    const clone = node.clone();
                    clone.x(node.x() + 20);
                    clone.y(node.y() + 20);
                    if (clone instanceof Konva.Image) {
                        clone.id('img_' + crypto.randomUUID());
                    }
                    this.layer.add(clone);
                    this._bindNodeEvents(clone);

                    if (clone instanceof Konva.Image) {
                        // Re-apply adjustments and cache the new cloned node.
                        // This is necessary because the cache is not cloned.
                        this.applyAdjustments(clone);
                    }

                    this.handleSelect({ target: clone, evt: { ctrlKey: false, metaKey: false } });
                    this.saveHistory();
                }

                async autoCutoutBackground() {
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) {
                        uiManager.showToast('Please select a single image for background removal.');
                        return;
                    }

                    const node = this.selectedNodes[0];
                    uiManager.showToast('✨ AI processing... Removing background.');

                    // Hide controls during processing to prevent user interaction
                    this._hideFloatingToolbar();
                    this.tr.hide();
                    this.layer.draw();

                    await this._performAutoCutout(node);

                    // Show controls again
                    this.tr.show();
                    this._showFloatingToolbar();
                    this.layer.batchDraw();
                    this.saveHistory();
                    uiManager.showToast('Background removed!');
                }

                _performAutoCutout(node) {
                    return new Promise((resolve) => {
                        const imageEl = node.image();
                        const width = imageEl.naturalWidth || imageEl.width;
                        const height = imageEl.naturalHeight || imageEl.height;

                        const tempCanvas = document.createElement('canvas');
                        tempCanvas.width = width;
                        tempCanvas.height = height;
                        const tempCtx = tempCanvas.getContext('2d');
                        tempCtx.drawImage(imageEl, 0, 0, width, height);

                        const imageData = tempCtx.getImageData(0, 0, width, height);
                        const data = imageData.data;

                        // --- Smart Background Detection Logic ---

                        // 1. Sample all border pixels to get a good guess of the background color.
                        const borderSamples = [];
                        const borderThickness = Math.min(5, Math.floor(width / 10), Math.floor(height / 10));
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (y < borderThickness || y >= height - borderThickness || x < borderThickness || x >= width - borderThickness) {
                                    const index = (y * width + x) * 4;
                                    borderSamples.push({ r: data[index], g: data[index + 1], b: data[index + 2] });
                                }
                            }
                        }

                        // 2. Find the most common (dominant) color in the border samples using quantization.
                        const colorCounts = {};
                        const quantizeFactor = 16; // Group similar colors together.
                        borderSamples.forEach(c => {
                            const key = `${Math.floor(c.r / quantizeFactor)}-${Math.floor(c.g / quantizeFactor)}-${Math.floor(c.b / quantizeFactor)}`;
                            colorCounts[key] = (colorCounts[key] || 0) + 1;
                        });

                        if (Object.keys(colorCounts).length === 0) { // Handle tiny images or errors
                             uiManager.showToast('Could not determine background.');
                             return resolve();
                        }

                        let dominantKey = Object.keys(colorCounts).reduce((a, b) => colorCounts[a] > colorCounts[b] ? a : b);
                        const [rKey, gKey, bKey] = dominantKey.split('-').map(Number);
                        const bgColor = {
                            r: rKey * quantizeFactor + (quantizeFactor / 2),
                            g: gKey * quantizeFactor + (quantizeFactor / 2),
                            b: bKey * quantizeFactor + (quantizeFactor / 2),
                        };

                        // 3. Flood-fill from the image borders to remove the background.
                        const tolerance = 45; // How similar colors must be to be removed.
                        const pixelsToRemove = new Array(width * height).fill(false);
                        const visited = new Array(width * height).fill(false);
                        const pixelStack = [];

                        // Add border pixels that match the background color as starting points.
                        for (let y = 0; y < height; y++) {
                            for (let x = 0; x < width; x++) {
                                if (y === 0 || y === height - 1 || x === 0 || x === width - 1) {
                                    const index = (y * width + x);
                                    if(visited[index]) continue;
                                    const dataIndex = index * 4;
                                    const r = data[dataIndex]; const g = data[dataIndex + 1]; const b = data[dataIndex + 2];
                                    const colorDistance = Math.sqrt(Math.pow(r - bgColor.r, 2) + Math.pow(g - bgColor.g, 2) + Math.pow(b - bgColor.b, 2));
                                    if (colorDistance < tolerance) {
                                        pixelStack.push([x, y]);
                                    }
                                }
                            }
                        }

                        // Perform the flood fill algorithm.
                        while (pixelStack.length > 0) {
                            const [x, y] = pixelStack.pop();
                            const index = y * width + x;
                            if (x < 0 || x >= width || y < 0 || y >= height || visited[index]) {
                                continue;
                            }
                            visited[index] = true;
                            const dataIndex = index * 4;
                            const r = data[dataIndex]; const g = data[dataIndex + 1]; const b = data[dataIndex + 2];
                            const colorDistance = Math.sqrt(Math.pow(r - bgColor.r, 2) + Math.pow(g - bgColor.g, 2) + Math.pow(b - bgColor.b, 2));

                            if (colorDistance < tolerance) {
                                pixelsToRemove[index] = true;
                                pixelStack.push([x + 1, y]); pixelStack.push([x - 1, y]);
                                pixelStack.push([x, y + 1]); pixelStack.push([x, y - 1]);
                            }
                        }

                        // 4. Apply a feathering effect for a smoother, more professional edge.
                        const featherAmount = 3; // Blur radius in pixels.
                        const alphaMask = new Uint8ClampedArray(width * height);
                        const tempMask = new Uint8ClampedArray(width * height);
                        for (let i = 0; i < pixelsToRemove.length; i++) { tempMask[i] = pixelsToRemove[i] ? 0 : 255; }
                        
                        for(let pass = 0; pass < featherAmount; pass++) {
                           alphaMask.set(tempMask);
                             for (let y = 1; y < height - 1; y++) {
                                for (let x = 1; x < width - 1; x++) {
                                    const i = y * width + x;
                                    const avg = (alphaMask[i-1] + alphaMask[i+1] + alphaMask[i-width] + alphaMask[i+width]) / 4;
                                    tempMask[i] = avg;
                                }
                            }
                        }
                        for (let i = 0; i < tempMask.length; i++) { data[i * 4 + 3] = tempMask[i]; }

                        tempCtx.putImageData(imageData, 0, 0);

                        const newImage = new Image();
                        newImage.crossOrigin = 'Anonymous';
                        newImage.src = tempCanvas.toDataURL();
                        newImage.onload = () => {
                            node.image(newImage);
                            node.clearCache();
                            this.applyAdjustments(node);
                            resolve();
                        };
                        newImage.onerror = () => {
                            uiManager.showToast('Error processing image.');
                            resolve();
                        }
                    });
                }

                handleKeyboard(e) {
                    if (this.isMagicWandActive && e.key === 'Escape') { this.toggleMagicWandMode(); }
                    if (this.isCropToolActive && e.key === 'Escape') { this.exitCropToolMode(); }
                    if (this.isSelectionToolActive && e.key === 'Escape') { this.exitSelectionToolMode(); }
                    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) return;
                    if (e.ctrlKey || e.metaKey) {
                        switch (e.key.toLowerCase()) {
                            case 'c': e.preventDefault(); if(this.isSelectionToolActive) this.copySelectionToClipboard(); else this.copySelected(); break;
                            case 'x': e.preventDefault(); if (this.isSelectionToolActive) { this.cutSelectionFromImage(); } else { this.copySelected(); this.deleteSelected(); } break;
                            case 'v': e.preventDefault(); this.pasteFromClipboard(); break;
                            case 'd': e.preventDefault(); this.duplicateSelected(); break;
                            case 'z': e.preventDefault(); this.undo(); break;
                            case 'y': e.preventDefault(); this.redo(); break;
                        }
                    } if (e.key === 'Delete' || e.key === 'Backspace') { this.deleteSelected(); }
                }

                saveHistory() {
                    this.history = this.history.slice(0, this.historyStep + 1); const imagesData = {};
                    this.layer.find('Image').forEach(imgNode => { if (imgNode.id() && imgNode.image() && imgNode.image().src) { imagesData[imgNode.id()] = imgNode.image().src; } });
                    const state = { layerJSON: this.layer.toJSON(), images: imagesData };
                    this.history.push(state); this.historyStep++; uiManager.updateUndoRedoButtons();
                }

                async undo() { if (this.historyStep > 0) { this.historyStep--; await this.loadLayerState(this.history[this.historyStep]); } uiManager.updateUndoRedoButtons(); }
                async redo() { if (this.historyStep < this.history.length - 1) { this.historyStep++; await this.loadLayerState(this.history[this.historyStep]); } uiManager.updateUndoRedoButtons(); }

                async loadLayerState(historyEntry) {
                    const { layerJSON, images: imagesData } = historyEntry;
                    try {
                        const imageElements = {};
                        const imageLoadPromises = Object.keys(imagesData || {}).map(imageId => {
                            return new Promise((resolve, reject) => { const img = new window.Image(); img.onload = () => { imageElements[imageId] = img; resolve(); }; img.onerror = (err) => reject(new Error(`Could not load history image ${imageId}`)); img.src = imagesData[imageId]; });
                        });
                        await Promise.all(imageLoadPromises);
                        const oldLayer = this.stage.findOne('#main-layer'); if (oldLayer) { oldLayer.destroy(); }
                        this.layer = Konva.Node.create(layerJSON); this.layer.setAttrs({ id: 'main-layer' }); this.stage.add(this.layer);
                        this.layer.find('Image').forEach(imgNode => { if (imgNode.id() && imageElements[imgNode.id()]) { imgNode.image(imageElements[imgNode.id()]); this.applyAdjustments(imgNode); } });
                        const oldTr = this.layer.findOne('Transformer'); if(oldTr) oldTr.destroy();
                        this.tr = this._createTransformer(); this.layer.add(this.tr);
                        this.tr.nodes([]); this.selectedNodes = []; uiManager.hidePropertiesSidebar();
                        this.gridLayer.moveToBottom(); this.watermarkLayer.moveToTop();
                        this.rebindListeners(this.layer); this.stage.draw();
                    } catch (error) { console.error("Failed to load history state:", error); uiManager.showToast("Error: Could not perform undo/redo."); }
                }

                saveState() {
                    this.tr.nodes([]); this.layer.draw(); const stageObject = this.stage.toObject(); const imagesData = {};
                    this.stage.find('Image').forEach(imgNode => { if (imgNode.id() && imgNode.image() && imgNode.image().src) { imagesData[imgNode.id()] = imgNode.image().src; } });
                    return JSON.stringify({ stage: stageObject, images: imagesData });
                }

                async loadState(jsonString) {
                    let projectData; try { projectData = JSON.parse(jsonString); } catch (e) { uiManager.showToast('Error: Invalid project file format.'); console.error("JSON Parse Error:", e); return; }
                    if (projectData.stage && projectData.images) {
                        try {
                            const imageElements = {};
                            const imageLoadPromises = Object.keys(projectData.images).map(imageId => {
                                return new Promise((resolve, reject) => { const img = new window.Image(); img.onload = () => { imageElements[imageId] = img; resolve(); }; img.onerror = (err) => reject(new Error(`Could not load image ${imageId}`)); img.src = projectData.images[imageId]; });
                            });
                            await Promise.all(imageLoadPromises); if (this.stage) { this.stage.destroy(); }
                            this.stage = Konva.Node.create(projectData.stage, this.containerId);
                            this.stage.find('Image').forEach(imgNode => { if (imgNode.id() && imageElements[imgNode.id()]) { imgNode.image(imageElements[imgNode.id()]); this.applyAdjustments(imgNode); } });
                        } catch (error) { console.error("Failed to load project assets:", error); uiManager.showToast("Error: Could not load project images."); return; }
                    } else { if (this.stage) { this.stage.destroy(); } this.stage = Konva.Node.create(projectData, this.containerId); }
                    this.canvasWidth = this.stage.width();
                    this.canvasHeight = this.stage.height();
                    this.layer = this.stage.findOne('#main-layer'); this.gridLayer = this.stage.findOne('#grid-layer'); this.watermarkLayer = this.stage.findOne('#watermark-layer');
                    if (!this.layer) { this.layer = new Konva.Layer({ id: 'main-layer' }); this.stage.add(this.layer); }
                    if (!this.gridLayer) { this.gridLayer = new Konva.Layer({ id: 'grid-layer' }); this.stage.add(this.gridLayer); }
                    if (!this.watermarkLayer) { this.watermarkLayer = new Konva.Layer({ id: 'watermark-layer', listening: false }); this.stage.add(this.watermarkLayer); }
                    const oldTr = this.stage.findOne('Transformer'); if (oldTr) oldTr.destroy();
                    this.tr = this._createTransformer(); this.layer.add(this.tr); 
                    this.stage.container().style.backgroundColor = document.body.classList.contains('dark') ? '#2a2a2a' : 'white';
                    this.rebindListeners(this.stage); this.drawGrid(); this.addWatermark(); this.attachStageListeners();
                    this.stage.draw(); this.centerView(); this.history = []; this.historyStep = -1; this.saveHistory();
                }
                rebindListeners(node) { this._bindNodeEvents(node); if (node.hasChildren()) { node.getChildren().forEach(child => this.rebindListeners(child)); } }

                updateImageAdjustments(property, value) {
                    if (this.selectedNodes.length !== 1 || !(this.selectedNodes[0] instanceof Konva.Image)) return;
                    const node = this.selectedNodes[0]; let adjustments = node.getAttr('adjustments') || {};
                    adjustments[property] = parseFloat(value); node.setAttr('adjustments', adjustments);
                    this.debouncedApplyAdjustments(node);
                }

                applyAdjustments(node) {
                    if (!(node instanceof Konva.Image)) return;
                    const adjustments = node.getAttr('adjustments') || {}; const hasAdjustments = Object.values(adjustments).some(v => v !== 0);
                    if (!hasAdjustments) { node.filters([]); node.cache(); return; }
                    node.filters([this.masterAdjustmentFilter]);
                    const adjustSliders = ['Lightness', 'Contrast', 'Saturation', 'Warmth', 'Tint', 'Hue', 'Highlight', 'Shadow', 'Vignette', 'Sharpen', 'Grain', 'Fade'];
                    adjustSliders.forEach(name => { const key = name.toLowerCase(); node.setAttr(key, adjustments[key] || 0); });
                    node.cache();
                }

                masterAdjustmentFilter(imageData) {
                    const adj = this.getAttrs(); const d = imageData.data; const w = imageData.width; const h = imageData.height;
                    const lightness = (adj.lightness || 0) / 100; const contrast = (adj.contrast || 0) / 100; const saturation = (adj.saturation || 0) / 100;
                    const warmth = (adj.warmth || 0) / 100; const tint = (adj.tint || 0) / 100; const hue = adj.hue || 0; const highlight = (adj.highlight || 0) / 100;
                    const shadow = (adj.shadow || 0) / 100; const vignette = (adj.vignette || 0) / 100; const sharpen = (adj.sharpen || 0) / 100;
                    const grain = (adj.grain || 0) / 100; const fade = (adj.fade || 0) / 100; const contrastFactor = 1.0 + contrast; const intercept = 128 * (1.0 - contrastFactor);
                    const sharpenKernel = [0, -sharpen, 0, -sharpen, 1 + 4 * sharpen, -sharpen, 0, -sharpen, 0];
                    const src = new Uint8ClampedArray(d);
                    for (let i = 0; i < d.length; i += 4) {
                        let r = src[i], g = src[i+1], b = src[i+2];
                        r += lightness * 255; g += lightness * 255; b += lightness * 255;
                        r = r * contrastFactor + intercept; g = g * contrastFactor + intercept; b = b * contrastFactor + intercept;
                        r += warmth * 50; b -= warmth * 50; g += tint * 50;
                        if (saturation !== 0 || hue !== 0) { const hsv = rgbToHsv(r, g, b); hsv.h = (hsv.h + hue) % 360; hsv.s = Math.max(0, Math.min(1, hsv.s * (1 + saturation))); const newRgb = hsvToRgb(hsv.h, hsv.s, hsv.v); r = newRgb.r; g = newRgb.g; b = newRgb.b; }
                        const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                        if (highlight > 0) { const highlightFactor = luminance / 255; r += highlight * highlightFactor * 255; g += highlight * highlightFactor * 255; b += highlight * highlightFactor * 255; } 
                        else if (highlight < 0) { const highlightFactor = luminance / 255; r += highlight * highlightFactor * 255; g += highlight * highlightFactor * 255; b += highlight * highlightFactor * 255; }
                         if (shadow > 0) { const shadowFactor = 1.0 - (luminance / 255); r += shadow * shadowFactor * 255; g += shadow * shadowFactor * 255; b += shadow * shadowFactor * 255; } 
                         else if (shadow < 0) { const shadowFactor = 1.0 - (luminance / 255); r += shadow * shadowFactor * 255; g += shadow * shadowFactor * 255; b += shadow * shadowFactor * 255; }
                        if (fade > 0) { const fadeAmount = fade * 50; r = (r * (1 - fade)) + (fadeAmount); g = (g * (1 - fade)) + (fadeAmount); b = (b * (1 - fade)) + (fadeAmount); }
                        d[i] = Math.max(0, Math.min(255, r)); d[i+1] = Math.max(0, Math.min(255, g)); d[i+2] = Math.max(0, Math.min(255, b));
                    }
                    if (sharpen > 0) {
                        for (let y = 1; y < h - 1; y++) {
                            for (let x = 1; x < w - 1; x++) {
                                let r = 0, g = 0, b = 0;
                                for (let ky = -1; ky <= 1; ky++) {
                                    for (let kx = -1; kx <= 1; kx++) {
                                        const kernelIndex = (ky + 1) * 3 + (kx + 1); const pixelIndex = ((y + ky) * w + (x + kx)) * 4;
                                        r += src[pixelIndex] * sharpenKernel[kernelIndex]; g += src[pixelIndex + 1] * sharpenKernel[kernelIndex]; b += src[pixelIndex + 2] * sharpenKernel[kernelIndex];
                                    }
                                } const destIndex = (y * w + x) * 4;
                                d[destIndex] = Math.max(0, Math.min(255, r)); d[destIndex + 1] = Math.max(0, Math.min(255, g)); d[destIndex + 2] = Math.max(0, Math.min(255, b));
                            }
                        }
                    }
                     for (let y = 0; y < h; y++) {
                        for (let x = 0; x < w; x++) {
                            const index = (y * w + x) * 4;
                            if (vignette > 0) { const dx = (x - w / 2) / (w/2); const dy = (y - h / 2) / (h/2); const dist = Math.sqrt(dx * dx + dy * dy); const darken = Math.pow(dist, 2.5) * vignette; d[index] *= (1 - darken); d[index + 1] *= (1 - darken); d[index + 2] *= (1 - darken); }
                            if (grain > 0) { const grainAmount = (Math.random() - 0.5) * grain * 50; d[index] += grainAmount; d[index + 1] += grainAmount; d[index + 2] += grainAmount; }
                             d[index] = Math.max(0, Math.min(255, d[index])); d[index+1] = Math.max(0, Math.min(255, d[index+1])); d[index+2] = Math.max(0, Math.min(255, d[index+2]));
                        }
                    }
                    function rgbToHsv(r, g, b) { r /= 255; g /= 255; b /= 255; let max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, v = max; let d = max - min; s = max === 0 ? 0 : d / max; if (max === min) { h = 0; } else { switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return { h: h * 360, s: s, v: v }; }
                    function hsvToRgb(h, s, v) { let r, g, b, i, f, p, q, t; h /= 360; i = Math.floor(h * 6); f = h * 6 - i; p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s); switch (i % 6) { case 0: r = v; g = t; b = p; break; case 1: r = q; g = v; b = p; break; case 2: r = p; g = v; b = t; break; case 3: r = p; g = q; b = v; break; case 4: r = t; g = p; b = v; break; case 5: r = v; g = p; b = q; break; } return { r: r * 255, g: g * 255, b: b * 255 }; }
                }
            }

            class UIManager {
                constructor(canvasManager) {
                    this.cm = canvasManager; 
                    this.sidebar = document.getElementById('sidebar');
                    this.propertiesSidebar = document.getElementById('propertiesSidebar');
                    this.tabsContainer = document.getElementById('tabsContainer'); 
                    this.projects = [];
                    this.activeProjectId = null; this.projectCounter = 1;
                }
                init() {
                    this.buildHomeScreen(); this.buildSidebar(); this.setupEventListeners(); 
                    this.setInitialTheme(); this.initPropertiesSidebar();
                    this.populateAiOutputSelector();
                }

                buildSidebar() {
                    this.sidebar.innerHTML = `
                        <div class="sidebar-section"><h3>Add Content</h3>
                            <button id="uploadBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg><span>Upload Image</span></button>
                            <button id="addTextBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg><span>Add Text</span></button>
                            <button id="aiImageBtn" class="sidebar-button ai-button"><svg viewBox="0 0 24 24" stroke="currentColor"><path d="M10 3L8 8l-5 2 5 2 2 5 2-5 5-2-5-2-2-5zM18 13l-2 5-5-2 5-2 2-5 2 5z"/></svg><span>AI Studio</span></button>
                        </div>
                        <div class="sidebar-section"><h3>Project Actions</h3>
                            <button id="saveProjectBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg><span>Save Project</span></button>
                            <button id="loadProjectBtn" class="sidebar-button"><svg viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg><span>Load Project</span></button>
                        </div>
                        <div class="sidebar-section"><h3>View & Export</h3>
                            <div class="button-group"><button id="previewBtn">Preview</button><button id="exportPngBtn">PNG</button><button id="exportPdfBtn">PDF</button></div>
                        </div>`;
                }
                
                buildHomeScreen() {
                    const container = document.getElementById('preset-categories'); container.innerHTML = '';
                    const iconMap = {
                        'document': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>`,
                        'poster': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>`,
                        'card': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line></svg>`,
                        'social': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>`,
                        'screen': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>`,
                        'product': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg>`,
                        'sticker': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>`,
                        'tarpaulin': `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>`
                    };
                    const getIcon = (name) => {
                        const lowerName = name.toLowerCase();
                        if (lowerName.includes('ft')) return iconMap['tarpaulin'];
                        if (lowerName.includes('sticker')) return iconMap['sticker'];
                        if (['mug', 't-shirt', 'tote', 'pillow', 'phone', 'notebook'].some(p => lowerName.includes(p))) return iconMap['product'];
                        if (['instagram', 'facebook', 'pinterest', 'linkedin', 'twitter', 'youtube', 'snapchat', 'podcast', 'blog', 'email'].some(s => lowerName.includes(s))) return iconMap['social'];
                        if (lowerName.includes('poster')) return iconMap['poster'];
                        if (['card', 'invitation', 'greeting'].some(c => lowerName.includes(c))) return iconMap['card'];
                        if (['wallpaper', 'hd', '2k', '4k', '5k', '8k'].some(c => lowerName.includes(c))) return iconMap['screen'];
                        return iconMap['document'];
                    }

                    Object.entries(canvasPresets).forEach(([key, category]) => {
                        const drawer = document.createElement('div'); drawer.className = 'category-drawer';
                        drawer.innerHTML = `<div class="drawer-header"><h2>${category.name}</h2><span class="drawer-arrow"><svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg></span></div>`;
                        const content = document.createElement('div'); content.className = 'drawer-content';
                        category.presets.forEach(preset => {
                            const card = document.createElement('div'); card.className = 'preset-card';
                            let dims = preset.w_px ? `${preset.w_px} × ${preset.h_px} px` : (preset.w_in ? `${preset.w_in} × ${preset.h_in} in` : `${preset.w_cm} × ${preset.h_cm} cm`);
                            card.innerHTML = `<div class="preset-card-icon">${getIcon(preset.name)}</div><div class="preset-card-title">${preset.name}</div><div class="preset-card-dims">${dims}</div>`;
                            
                            let isDefaultLandscape = false;
                            if (preset.w_px) { isDefaultLandscape = preset.w_px >= preset.h_px; } 
                            else if (preset.w_in) { isDefaultLandscape = preset.w_in >= preset.h_in; } 
                            else if (preset.w_cm) { isDefaultLandscape = preset.w_cm >= preset.h_cm; }
                            
                            card.onclick = () => {
                                this.startEditorWithPreset(preset, isDefaultLandscape);
                                drawer.classList.remove('open');
                            };
                            
                            content.appendChild(card);
                        });
                        drawer.appendChild(content); container.appendChild(drawer);
                        drawer.querySelector('.drawer-header').addEventListener('click', () => {
                            const currentlyOpen = container.querySelector('.category-drawer.open');
                            if (currentlyOpen && currentlyOpen !== drawer) {
                                currentlyOpen.classList.remove('open');
                                currentlyOpen.querySelector('.drawer-content').style.display = 'none';
                            }
                            drawer.classList.toggle('open');
                            content.style.display = drawer.classList.contains('open') ? 'grid' : 'none';
                        });
                    });
                }
                
                populateAiOutputSelector() {
                    const select = document.getElementById('aiOutputCanvasSize');
                    select.innerHTML = `<option value="current">Add to Current Canvas</option>`;
                    const categoriesToInclude = ['stickers', 'hd_screens'];

                    categoriesToInclude.forEach(categoryKey => {
                        const category = canvasPresets[categoryKey];
                        if(category) {
                            const optgroup = document.createElement('optgroup');
                            optgroup.label = category.name;
                            category.presets.forEach(preset => {
                                const option = document.createElement('option');
                                let dims = preset.w_px ? `${preset.w_px}x${preset.h_px}px` : (preset.w_in ? `${preset.w_in}x${preset.h_in}in` : `${preset.w_cm}x${preset.h_cm}cm`);
                                option.textContent = `${preset.name} (${dims})`;
                                option.value = JSON.stringify(preset);
                                optgroup.appendChild(option);
                            });
                            select.appendChild(optgroup);
                        }
                    });
                }

                startEditorWithPreset(preset, isLandscape, imageUrlToAdd = null) {
                    this.saveCurrentProjectState(); // Save state of the current tab before creating a new one
                    document.body.classList.add('editor-active');
                    this.cm.setCanvasSizeFromPreset(preset, isLandscape);
                    this.createNewProject(preset.name, imageUrlToAdd);
                    this.cm.zoomToFit();
                }

                setupEventListeners() {
                    document.getElementById('backToHomeBtn').addEventListener('click', () => document.body.classList.remove('editor-active'));
                    document.getElementById('sidebarToggleBtn').addEventListener('click', (e) => { e.stopPropagation(); this.toggleSidebar(); });
                    document.getElementById('fullscreenToggleBtn').addEventListener('click', () => this.toggleFullscreen());
                    document.getElementById('themeToggle').addEventListener('click', () => this.toggleTheme());
                    document.getElementById('centerViewBtn').addEventListener('click', () => this.cm.centerView());
                    document.getElementById('undoBtn').addEventListener('click', () => this.cm.undo());
                    document.getElementById('redoBtn').addEventListener('click', () => this.cm.redo());
                    document.getElementById('multiSelectToolBtn').addEventListener('click', () => this.cm.toggleMultiSelectMode());
                    document.getElementById('zoomSlider').addEventListener('input', (e) => this.cm.setZoom(parseFloat(e.target.value)));
                    document.getElementById('zoomInBtn').addEventListener('click', () => this.cm.zoomByStep(1));
                    document.getElementById('zoomOutBtn').addEventListener('click', () => this.cm.zoomByStep(-1));
                    document.getElementById('rotationSlider').addEventListener('input', (e) => this.cm.setRotation(parseInt(e.target.value, 10)));
                    document.getElementById('rotationInBtn').addEventListener('click', () => this.cm.rotateByStep(1));
                    document.getElementById('rotationOutBtn').addEventListener('click', () => this.cm.rotateByStep(-1));
                    document.getElementById('canvas-area').addEventListener('click', () => { if (this.sidebar.classList.contains('open')) { this.sidebar.classList.remove('open'); }});
                    document.getElementById('saveProjectBtn').addEventListener('click', () => this.saveProject());
                    document.getElementById('loadProjectBtn').addEventListener('click', () => document.getElementById('loadProjectInput').click());
                    document.getElementById('loadProjectInput').addEventListener('change', (e) => this.loadProjectFromFile(e));
                    document.getElementById('uploadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
                    document.getElementById('addTextBtn').addEventListener('click', () => this.cm.addText());
                    document.getElementById('aiImageBtn').addEventListener('click', () => { document.getElementById('aiImageModal').style.display = 'flex'; this.sidebar.classList.remove('open'); });
                    document.getElementById('previewBtn').addEventListener('click', () => { document.getElementById('previewModal').style.display = 'flex'; document.getElementById('previewImage').src = this.cm.getPreviewDataURL(); });
                    document.getElementById('exportPngBtn').addEventListener('click', () => this.cm.exportToPNG());
                    document.getElementById('exportPdfBtn').addEventListener('click', () => this.cm.exportToPDF());
                }
                
                renderTabs() {
                    this.tabsContainer.innerHTML = '';
                    this.projects.forEach(project => {
                        const tab = document.createElement('div');
                        tab.className = 'tab' + (project.id === this.activeProjectId ? ' active' : ''); tab.dataset.id = project.id;
                        const tabName = document.createElement('span'); tabName.className = 'tab-name'; tabName.textContent = project.name; tab.appendChild(tabName);
                        const closeBtn = document.createElement('span'); closeBtn.className = 'tab-close'; closeBtn.innerHTML = '&times;';
                        closeBtn.addEventListener('click', (e) => { e.stopPropagation(); this.closeProject(project.id); });
                        tab.appendChild(closeBtn); tab.addEventListener('click', async () => await this.switchProject(project.id)); this.tabsContainer.appendChild(tab);
                    });
                    const newTabBtn = document.createElement('button'); newTabBtn.className = 'new-tab-btn'; newTabBtn.textContent = '+';
                    newTabBtn.title = 'New Project'; newTabBtn.addEventListener('click', () => document.body.classList.remove('editor-active')); this.tabsContainer.appendChild(newTabBtn);
                }
                saveCurrentProjectState() {
                    if (!this.activeProjectId) return;
                    const project = this.projects.find(p => p.id === this.activeProjectId);
                    if (project && this.cm.stage) { project.state = this.cm.saveState(); project.zoom = this.cm.zoom; project.rotation = this.cm.rotation; project.offsetX = this.cm.offsetX; project.offsetY = this.cm.offsetY; }
                }
                createNewProject(name = `Project ${this.projectCounter++}`, imageUrlToAdd = null) {
                    if (imageUrlToAdd) {
                        this.cm.addImage(imageUrlToAdd);
                    }
                    const newProject = { id: Date.now(), name, state: this.cm.saveState() };
                    this.projects.push(newProject);
                    this.activeProjectId = newProject.id;
                    this.renderTabs();
                    this.updateUndoRedoButtons();
                }
                async switchProject(projectId) {
                    if (projectId === this.activeProjectId) return;
                    this.saveCurrentProjectState(); this.activeProjectId = projectId;
                    const project = this.projects.find(p => p.id === this.activeProjectId);
                    if (project && project.state) { await this.cm.loadState(project.state); }
                    if (project && typeof project.zoom !== 'undefined') { this.cm.setZoom(project.zoom); this.cm.setRotation(project.rotation); this.cm.offsetX = project.offsetX; this.cm.offsetY = project.offsetY; this.cm.updateContainerTransform(); }
                    this.renderTabs(); this.updateUndoRedoButtons();
                }
                async closeProject(projectId) {
                    const indexToRemove = this.projects.findIndex(p => p.id === projectId);
                    if (indexToRemove === -1) return;
                    const wasActive = this.activeProjectId === projectId;

                    this.projects.splice(indexToRemove, 1);
                    this.cm._destroyControls(); // Fix: Call method on canvasManager instance

                    if (this.projects.length === 0) {
                        document.body.classList.remove('editor-active');
                        this.activeProjectId = null;
                        if (this.cm.stage) {
                            this.cm.stage.destroy();
                            // Cleanup all references to prevent memory leaks and errors
                            this.cm.stage = null; this.cm.layer = null; this.cm.gridLayer = null;
                            this.cm.watermarkLayer = null; this.cm.controlsLayer = null; this.cm.tr = null;
                        }
                        this.projectCounter = 1;
                    } else if (wasActive) {
                        // If the closed tab was active, switch to a new one. More robustly select next tab.
                        const newActiveIndex = Math.min(indexToRemove, this.projects.length - 1);
                        this.activeProjectId = this.projects[newActiveIndex].id;
                        const project = this.projects.find(p => p.id === this.activeProjectId);
                        if (project && project.state) {
                            await this.cm.loadState(project.state);
                        }
                    }

                    this.renderTabs();
                    this.updateUndoRedoButtons();
                }
                saveProject() {
                    this.saveCurrentProjectState(); const project = this.projects.find(p => p.id === this.activeProjectId); if (!project) return;
                    const blob = new Blob([project.state], { type: 'application/json' }); saveAs(blob, `${project.name}.json`);
                }
                loadProjectFromFile(e) {
                    const file = e.target.files[0]; if (!file) return;
                    const reader = new FileReader();
                    reader.onload = async (event) => {
                        try {
                            const jsonString = event.target.result; this.saveCurrentProjectState();
                            const newProject = { id: Date.now(), name: file.name.replace('.json', ''), state: jsonString };
                            this.projects.push(newProject); this.activeProjectId = newProject.id;
                            await this.cm.loadState(jsonString); this.renderTabs();
                            this.updateUndoRedoButtons(); document.body.classList.add('editor-active');
                        } catch (err) { this.showToast("Error: Invalid project file."); console.error(err);
                        } finally { e.target.value = ''; }
                    };
                    reader.readAsText(file);
                }

                toggleSidebar() { this.sidebar.classList.toggle('open'); }
                updateZoomSlider(scale) { document.getElementById('zoomSlider').value = scale; document.getElementById('zoomValue').textContent = `${Math.round(scale * 100)}%`; }
                updateRotationSlider(deg) { const roundedDeg = Math.round(deg); document.getElementById('rotationSlider').value = roundedDeg; document.getElementById('rotationValue').textContent = `${roundedDeg}°`; }
                updateUndoRedoButtons() {
                    document.getElementById('undoBtn').disabled = this.cm.historyStep <= 0;
                    document.getElementById('redoBtn').disabled = this.cm.historyStep >= this.cm.history.length - 1;
                }
                
                adjustSelectionProperty(prop, delta) {
                    if (this.cm.selectedNodes.length !== 1) return;
                    const node = this.cm.selectedNodes[0];
                    if (prop === 'rotation') {
                        const slider = document.getElementById('selectionRotationSlider');
                        const currentValue = parseFloat(slider.value);
                        const newValue = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), currentValue + delta));
                        slider.value = newValue;
                        this.cm.updateNodeProperty('rotation', newValue);
                        document.getElementById('selectionRotationValue').textContent = `${Math.round(newValue)}°`;
                    } else if (prop === 'scale') {
                        const slider = document.getElementById('selectionZoomSlider');
                        const currentValue = parseFloat(slider.value);
                        const newValue = parseFloat(Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), currentValue + delta)).toFixed(2));
                        slider.value = newValue;
                        this.cm.updateNodeProperty('scale', newValue);
                        document.getElementById('selectionScaleValue').textContent = `${Math.round(newValue * 100)}%`;
                    }
                }
                
                // ... (rest of UIManager methods are the same)
                initPropertiesSidebar() {
                    const menu = this.propertiesSidebar;
                    menu.querySelectorAll('.menu-tab').forEach(tab => { tab.addEventListener('click', () => { menu.querySelector('.menu-tab.active').classList.remove('active'); menu.querySelector('.tab-pane.active').classList.remove('active'); tab.classList.add('active'); menu.querySelector(`#pane-${tab.dataset.tab}`).classList.add('active'); }); });
                    const controlsToTrack = [ 'selectionRotationSlider', 'selectionZoomSlider', 'textContent', 'fontFamily', 'fontSize', 'fillColor', 'strokeColor', 'strokeWidth', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'gradientColor1', 'gradientColor2', 'gradientRotation', 'fillType' ];
                    controlsToTrack.forEach(id => {
                        const el = document.getElementById(id);
                        if (el) { el.addEventListener('change', () => this.cm.saveHistory()); if (el.type === 'range' || el.type === 'number') { el.addEventListener('input', (e) => this.cm.updateNodeProperty(el.id.replace('selection', '').replace('Slider','').toLowerCase(), e.target.value)); } }
                    });
                    const buttonsToTrack = ['boldBtn', 'italicBtn', 'underlineBtn']; buttonsToTrack.forEach(id => { document.getElementById(id).addEventListener('click', () => this.cm.saveHistory()); });
                    document.getElementById('selectionRotationSlider').addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.cm.updateNodeProperty('rotation', value);
                        document.getElementById('selectionRotationValue').textContent = `${Math.round(value)}°`;
                    });
                    document.getElementById('selectionZoomSlider').addEventListener('input', (e) => {
                        const value = parseFloat(e.target.value);
                        this.cm.updateNodeProperty('scale', value);
                        document.getElementById('selectionScaleValue').textContent = `${Math.round(value * 100)}%`;
                    });

                    document.getElementById('selectionRotationMinusBtn').addEventListener('click', () => this.adjustSelectionProperty('rotation', -1));
                    document.getElementById('selectionRotationPlusBtn').addEventListener('click', () => this.adjustSelectionProperty('rotation', 1));
                    document.getElementById('selectionScaleMinusBtn').addEventListener('click', () => this.adjustSelectionProperty('scale', -0.1));
                    document.getElementById('selectionScalePlusBtn').addEventListener('click', () => this.adjustSelectionProperty('scale', 0.1));

                    ['selectionRotationMinusBtn', 'selectionRotationPlusBtn', 'selectionScaleMinusBtn', 'selectionScalePlusBtn'].forEach(id => {
                        const btn = document.getElementById(id);
                        btn.addEventListener('mouseup', () => this.cm.saveHistory());
                        btn.addEventListener('touchend', () => this.cm.saveHistory());
                    });
                    
                    document.getElementById('deleteBtn').addEventListener('click', () => this.cm.deleteSelected());
                    document.getElementById('textContent').addEventListener('input', (e) => this.cm.updateNodeProperty('text', e.target.value));
                    document.getElementById('fontFamily').addEventListener('change', (e) => this.cm.updateNodeProperty('fontFamily', e.target.value));
                    document.getElementById('fontSize').addEventListener('input', (e) => this.cm.updateNodeProperty('fontSize', e.target.value));
                    document.getElementById('boldBtn').addEventListener('click', (e) => { this.cm.updateNodeProperty('bold'); e.currentTarget.classList.toggle('active'); });
                    document.getElementById('italicBtn').addEventListener('click', (e) => { this.cm.updateNodeProperty('italic'); e.currentTarget.classList.toggle('active'); });
                    document.getElementById('underlineBtn').addEventListener('click', (e) => { this.cm.updateNodeProperty('underline'); e.currentTarget.classList.toggle('active'); });
                    document.getElementById('fillColor').addEventListener('input', (e) => this.cm.updateNodeProperty('fill', e.target.value));
                    document.getElementById('strokeColor').addEventListener('input', (e) => this.cm.updateNodeProperty('stroke', e.target.value));
                    document.getElementById('strokeWidth').addEventListener('input', (e) => this.cm.updateNodeProperty('strokeWidth', e.target.value));
                    document.getElementById('shadowColor').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowColor', e.target.value));
                    document.getElementById('shadowBlur').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowBlur', e.target.value));
                    document.getElementById('shadowOffsetX').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowOffsetX', e.target.value));
                    document.getElementById('shadowOffsetY').addEventListener('input', (e) => this.cm.updateNodeProperty('shadowOffsetY', e.target.value));
                    document.getElementById('selectionToolBtn').addEventListener('click', () => this.cm.toggleSelectionToolMode());
                    document.getElementById('magicWandBtn').addEventListener('click', () => this.cm.toggleMagicWandMode());
                    document.getElementById('cropToolBtn').addEventListener('click', () => this.cm.toggleCropToolMode());
                    const toleranceSlider = document.getElementById('magicWandTolerance'); const toleranceValue = document.getElementById('magicWandToleranceValue');
                    toleranceSlider.addEventListener('input', (e) => { toleranceValue.textContent = e.target.value; this.cm.debouncedUpdateMagicWand(); });
                    toleranceSlider.addEventListener('change', () => this.cm.saveHistory());
                    const featherSlider = document.getElementById('magicWandFeather'); const featherValue = document.getElementById('magicWandFeatherValue');
                    featherSlider.addEventListener('input', (e) => { featherValue.textContent = e.target.value; this.cm.debouncedUpdateMagicWand(); });
                    featherSlider.addEventListener('change', () => this.cm.saveHistory());

                    const adjustMagicWand = (slider, amount) => {
                        const currentValue = parseFloat(slider.value);
                        const step = parseFloat(slider.step) || 1;
                        const newValue = Math.max(parseFloat(slider.min), Math.min(parseFloat(slider.max), currentValue + (amount * step) ));
                        slider.value = newValue;
                        // Dispatch input event to trigger UI update and debounced processing
                        slider.dispatchEvent(new Event('input', { bubbles:true }));
                    };
                    
                    document.getElementById('magicWandToleranceMinus').addEventListener('click', () => adjustMagicWand(toleranceSlider, -1));
                    document.getElementById('magicWandTolerancePlus').addEventListener('click', () => adjustMagicWand(toleranceSlider, 1));
                    document.getElementById('magicWandFeatherMinus').addEventListener('click', () => adjustMagicWand(featherSlider, -1));
                    document.getElementById('magicWandFeatherPlus').addEventListener('click', () => adjustMagicWand(featherSlider, 1));


                    document.getElementById('magicWandContiguous').addEventListener('change', () => { this.cm.updateMagicWandLive(); this.cm.saveHistory(); });
                    this.buildAdjustmentsUI();
                    document.getElementById('resetAllAdjustmentsBtn').addEventListener('click', () => { if (this.cm.selectedNodes.length === 1) { const node = this.cm.selectedNodes[0]; node.setAttr('adjustments', {}); this.cm.applyAdjustments(node); this.showPropertiesSidebar(node); this.cm.saveHistory(); } });
                    const updateGradient = () => { this.cm.updateNodeProperty('gradient', { color1: document.getElementById('gradientColor1').value, color2: document.getElementById('gradientColor2').value, angle: document.getElementById('gradientRotation').value }); };
                    document.getElementById('gradientColor1').addEventListener('input', updateGradient); document.getElementById('gradientColor2').addEventListener('input', updateGradient); document.getElementById('gradientRotation').addEventListener('input', updateGradient);
                    document.getElementById('fillType').addEventListener('change', (e) => { const isSolid = e.target.value === 'solid'; document.getElementById('solidFillOptions').style.display = isSolid ? 'block' : 'none'; document.getElementById('gradientFillOptions').style.display = isSolid ? 'none' : 'block'; if(isSolid) { this.cm.updateNodeProperty('fill', document.getElementById('fillColor').value); } else { updateGradient(); } });
                }
                buildAdjustmentsUI() {
                    const container = document.getElementById('adjustmentsContainer'); container.innerHTML = '';
                    const adjustments = [ { name: 'Lightness', min: -100, max: 100, step: 1 }, { name: 'Contrast', min: -100, max: 100, step: 1 }, { name: 'Saturation', min: -100, max: 100, step: 1 }, { name: 'Warmth', min: -100, max: 100, step: 1 }, { name: 'Tint', min: -100, max: 100, step: 1 }, { name: 'Hue', min: -180, max: 180, step: 1 }, { name: 'Highlight', min: -100, max: 100, step: 1 }, { name: 'Shadow', min: -100, max: 100, step: 1 }, { name: 'Vignette', min: 0, max: 100, step: 1 }, { name: 'Sharpen', min: 0, max: 100, step: 1 }, { name: 'Grain', min: 0, max: 100, step: 1 }, { name: 'Fade', min: 0, max: 100, step: 1 }, ];
                    adjustments.forEach(({ name, min, max, step }) => {
                        const key = name.toLowerCase(); const controlGroup = document.createElement('div'); controlGroup.className = 'control-group collapsible';
                        controlGroup.innerHTML = ` <div class="collapsible-header"> <label>${name}</label> <span class="value-display" id="adjust${name}Value">0</span> <button class="reset-btn" data-target="adjust${name}" title="Reset"> <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 11a8.1 8.1 0 0 0-7.5-6.5C7.2 4.5 3.1 8.6 3 14a8.1 8.1 0 0 0 7.5 6.5c4.7 0 8.5-3.8 8.5-8.5v-1" /><polyline points="16 7 20 7 20 11" /></svg> </button> </div> <div class="collapsible-content"> <div class="slider-container"> <button class="adjust-btn minus" data-target="adjust${name}" data-amount="-${step}">-</button> <input type="range" id="adjust${name}" min="${min}" max="${max}" value="0" step="${step}"> <button class="adjust-btn plus" data-target="adjust${name}" data-amount="${step}">+</button> </div> </div> `;
                        container.appendChild(controlGroup);
                        const slider = controlGroup.querySelector(`#adjust${name}`); const valueLabel = controlGroup.querySelector(`#adjust${name}Value`); const header = controlGroup.querySelector('.collapsible-header'); const resetBtn = controlGroup.querySelector('.reset-btn'); const minusBtn = controlGroup.querySelector('.minus'); const plusBtn = controlGroup.querySelector('.plus');
                        header.addEventListener('click', () => controlGroup.classList.toggle('active'));
                        const updateValue = (newValue) => { slider.value = newValue; valueLabel.textContent = newValue; this.cm.updateImageAdjustments(key, newValue); };
                        slider.addEventListener('input', (e) => { valueLabel.textContent = e.target.value; this.cm.updateImageAdjustments(key, e.target.value); });
                        slider.addEventListener('change', () => { this.cm.applyAdjustments(this.cm.selectedNodes[0]); this.cm.saveHistory(); });
                        resetBtn.addEventListener('click', (e) => { e.stopPropagation(); updateValue(0); this.cm.applyAdjustments(this.cm.selectedNodes[0]); this.cm.saveHistory(); });
                        const adjustValue = (amount) => { const currentValue = parseFloat(slider.value); const newValue = Math.max(min, Math.min(max, currentValue + amount)); updateValue(newValue); };
                        minusBtn.addEventListener('click', () => adjustValue(-step)); plusBtn.addEventListener('click', () => adjustValue(step));
                        minusBtn.addEventListener('mouseup', () => {this.cm.applyAdjustments(this.cm.selectedNodes[0]); this.cm.saveHistory()});
                        plusBtn.addEventListener('mouseup', () => {this.cm.applyAdjustments(this.cm.selectedNodes[0]); this.cm.saveHistory()});
                    });
                }
                showPropertiesSidebar(node) {
                    if (!node) { this.hidePropertiesSidebar(); return; }
                     this.propertiesSidebar.classList.add('visible'); document.body.classList.add('sidebar-visible');
                    const isText = node instanceof Konva.Text; const isImage = node instanceof Konva.Image;
                    this.propertiesSidebar.querySelectorAll('[data-type]').forEach(el => el.style.display = 'none');
                    this.propertiesSidebar.querySelectorAll('.menu-tab').forEach(tab => { if (tab.dataset.tab === "transform") tab.style.display = 'flex';});
                     document.getElementById('magicWandControls').style.display = 'none';
                    if (isText) this.propertiesSidebar.querySelectorAll('[data-type="text"]').forEach(el => el.style.display = 'flex');
                    if (isImage) { this.propertiesSidebar.querySelectorAll('[data-type="image"]').forEach(el => el.style.display = 'flex'); document.getElementById('magicWandControls').style.display = 'block'; }
                    const firstVisibleTab = this.propertiesSidebar.querySelector('.menu-tab[style*="display: flex"]');
                    if(firstVisibleTab && !this.propertiesSidebar.querySelector('.menu-tab.active[style*="display: flex"]')) { this.propertiesSidebar.querySelectorAll('.menu-tab, .tab-pane').forEach(el => el.classList.remove('active')); firstVisibleTab.classList.add('active'); document.getElementById(`pane-${firstVisibleTab.dataset.tab}`).classList.add('active'); }
                    document.getElementById('selectionRotationSlider').value = node.rotation(); document.getElementById('selectionZoomSlider').value = node.scaleX();
                    document.getElementById('selectionRotationValue').textContent = `${Math.round(node.rotation())}°`;
                    document.getElementById('selectionScaleValue').textContent = `${Math.round(node.scaleX() * 100)}%`;
                    if(isText) {
                        document.getElementById('textContent').value = node.text(); document.getElementById('fontFamily').value = node.fontFamily();
                        document.getElementById('fontSize').value = node.fontSize(); document.getElementById('boldBtn').classList.toggle('active', node.fontStyle().includes('bold'));
                        document.getElementById('italicBtn').classList.toggle('active', node.fontStyle().includes('italic')); document.getElementById('underlineBtn').classList.toggle('active', node.textDecoration() === 'underline');
                        const isGradient = node.fillPriority() === 'linear-gradient'; document.getElementById('fillType').value = isGradient ? 'gradient' : 'solid';
                        document.getElementById('solidFillOptions').style.display = isGradient ? 'none' : 'block'; document.getElementById('gradientFillOptions').style.display = isGradient ? 'block' : 'none';
                        document.getElementById('fillColor').value = node.fill();
                        if(isGradient && node.fillLinearGradientColorStops()){ document.getElementById('gradientColor1').value = node.fillLinearGradientColorStops()[1]; document.getElementById('gradientColor2').value = node.fillLinearGradientColorStops()[3]; }
                        document.getElementById('strokeColor').value = node.stroke() || '#000000'; document.getElementById('strokeWidth').value = node.strokeWidth() || 0;
                        document.getElementById('shadowColor').value = node.shadowColor() || '#000000'; document.getElementById('shadowBlur').value = node.shadowBlur() || 0;
                        document.getElementById('shadowOffsetX').value = node.shadowOffsetX() || 0; document.getElementById('shadowOffsetY').value = node.shadowOffsetY() || 0;
                    }
                    if (isImage) {
                        const magicParams = node.getAttr('magicWandParams');
                        if (magicParams) { document.getElementById('magicWandTolerance').value = magicParams.tolerance; document.getElementById('magicWandToleranceValue').textContent = magicParams.tolerance; document.getElementById('magicWandFeather').value = magicParams.feather; document.getElementById('magicWandFeatherValue').textContent = magicParams.feather; document.getElementById('magicWandContiguous').checked = magicParams.isContiguous; }
                        const adjustments = node.getAttr('adjustments') || {};
                        const adjustSliders = ['Lightness', 'Contrast', 'Saturation', 'Warmth', 'Tint', 'Hue', 'Highlight', 'Shadow', 'Vignette', 'Sharpen', 'Grain', 'Fade'];
                        adjustSliders.forEach(name => { const key = name.toLowerCase(); const value = adjustments[key] || 0; const slider = document.getElementById(`adjust${name}`); const valueLabel = document.getElementById(`adjust${name}Value`); if (slider) slider.value = value; if (valueLabel) valueLabel.textContent = value; });
                    }
                }
                hidePropertiesSidebar() { this.propertiesSidebar.classList.remove('visible'); document.body.classList.remove('sidebar-visible'); }
                toggleFullscreen() { const isFullscreen = document.body.classList.toggle('fullscreen'); document.getElementById('maximizeIcon').style.display = isFullscreen ? 'none' : 'block'; document.getElementById('minimizeIcon').style.display = isFullscreen ? 'block' : 'none'; }
                toggleTheme() { document.body.classList.toggle('dark'); localStorage.setItem('theme', document.body.classList.contains('dark') ? 'dark' : 'light'); this.updateTheme(); if(this.cm.stage){this.cm.stage.container().style.backgroundColor = document.body.classList.contains('dark') ? '#2a2a2a' : 'white'; this.cm.drawGrid(); this.cm.addWatermark();} }
                updateTheme() { const isDark = document.body.classList.contains('dark'); document.getElementById('themeIconSun').style.display = isDark ? 'none' : 'block'; document.getElementById('themeIconMoon').style.display = isDark ? 'block' : 'none'; }
                setInitialTheme() { document.body.classList.add('dark'); this.updateTheme(); }
                showToast(message) { const toast = document.getElementById('toast'); toast.textContent = message; toast.classList.add('show'); setTimeout(() => { toast.classList.remove('show'); }, 3000); }
            }

            const cm = new CanvasManager('container');
            const uiManager = new UIManager(cm);
            uiManager.init();
            initCursorTrail(); // Initialize the new cursor effect
            let imageEditBase64 = null;

            document.getElementById('fileInput').addEventListener('change', (e) => { if (e.target.files.length > 0) { Array.from(e.target.files).forEach((file, index) => { const reader = new FileReader(); reader.onload = (event) => cm.addImage(event.target.result, index); reader.readAsDataURL(file); }); e.target.value = ''; } });
            document.getElementById('closePreview').addEventListener('click', () => { document.getElementById('previewModal').style.display = 'none'; document.getElementById('previewImage').src = ''; });
            document.addEventListener('keydown', (e) => cm.handleKeyboard(e));
            
            window.addEventListener('click', (e) => {
                const isModalOpen = !!document.querySelector('.modal[style*="display: flex"]'); if (isModalOpen) return;
                const isOnCanvasPadding = e.target.id === 'canvas-area';
                if (isOnCanvasPadding) { cm.tr.nodes([]); cm.selectedNodes = []; cm.layer.draw(); uiManager.hidePropertiesSidebar(); }
            });

            const aiImageModal = document.getElementById('aiImageModal');
            document.getElementById('closeAiImageModal').addEventListener('click', () => { aiImageModal.style.display = 'none'; });
            function handleImageFile(file) {
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (e) => { document.getElementById('imagePreview').src = e.target.result; document.getElementById('imagePreview').style.display = 'block'; document.getElementById('dropzoneText').style.display = 'none'; document.getElementById('clearImageBtn').style.display = 'block'; imageEditBase64 = e.target.result.split(',')[1]; }; reader.readAsDataURL(file);
                } else { uiManager.showToast('Please upload a valid image file.'); }
            }
            const dropzone = document.getElementById('imageDropzone');
            dropzone.addEventListener('click', () => document.getElementById('aiImageInput').click());
            dropzone.addEventListener('dragover', (e) => { e.preventDefault(); dropzone.style.borderColor = 'var(--primary)'; });
            dropzone.addEventListener('dragleave', () => { dropzone.style.borderColor = 'var(--border-light)'; });
            dropzone.addEventListener('drop', (e) => { e.preventDefault(); handleImageFile(e.dataTransfer.files[0]); });
            document.getElementById('aiImageInput').addEventListener('change', (e) => handleImageFile(e.target.files[0]));
            document.getElementById('clearImageBtn').addEventListener('click', (e) => { e.stopPropagation(); imageEditBase64 = null; document.getElementById('imagePreview').style.display = 'none'; document.getElementById('dropzoneText').style.display = 'block'; document.getElementById('clearImageBtn').style.display = 'none'; document.getElementById('aiImageInput').value = ''; });
            document.getElementById('generateImageBtn').addEventListener('click', async () => {
                const prompt = document.getElementById('aiImagePrompt').value; if (!prompt) { uiManager.showToast("Please enter a prompt."); return; }
                const loader = document.getElementById('aiImageLoader'); const imageEl = document.getElementById('aiGeneratedImage');
                const addBtn = document.getElementById('addAiImageToCanvasBtn'); const outputOptions = document.getElementById('aiOutputOptions');
                loader.style.display = 'block'; imageEl.style.display = 'none'; addBtn.style.display = 'none'; outputOptions.style.display = 'none';
                generateImageBtn.disabled = true; generateImageBtn.textContent = "Generating...";
                const apiKey = "AIzaSyAStXuhKO8Dc7gJjvvC26unsZyvhCwGf0E"; const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-image-preview:generateContent?key=${apiKey}`;
                const parts = [{ text: prompt }]; if (imageEditBase64) { parts.push({ inlineData: { mimeType: "image/png", data: imageEditBase64 } }); }
                const payload = { contents: [{ parts: parts }], generationConfig: { responseModalities: ['IMAGE'] }, };
                try {
                    const response = await fetch(apiUrl, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    if(!response.ok) { let errorMessage = `API request failed with status ${response.status}`; try { const errorData = await response.json(); errorMessage = errorData?.error?.message || errorMessage; } catch (jsonError) { const errorText = await response.text().catch(() => "Could not read error response."); errorMessage = errorText || errorMessage; } throw new Error(errorMessage); }
                    const result = await response.json();
                    const base64Data = result?.candidates?.[0]?.content?.parts?.find(p => p.inlineData)?.inlineData?.data;
                    if (base64Data) { const imageUrl = `data:image/png;base64,${base64Data}`; imageEl.src = imageUrl; imageEl.style.display = 'block'; addBtn.style.display = 'block'; outputOptions.style.display = 'block'; } else { throw new Error(result?.promptFeedback?.blockReason || "No image data found in response."); }
                } catch (error) { console.error('Image generation failed:', error); uiManager.showToast(`Error: ${error.message}`); 
                } finally { loader.style.display = 'none'; generateImageBtn.disabled = false; generateImageBtn.textContent = "Generate"; }
            });
            document.getElementById('addAiImageToCanvasBtn').addEventListener('click', () => {
                const imageUrl = document.getElementById('aiGeneratedImage').src;
                if(!imageUrl) return;

                const sizeSelector = document.getElementById('aiOutputCanvasSize');
                const selectedValue = sizeSelector.value;
                
                if (selectedValue === 'current') {
                     if(uiManager.activeProjectId) {
                        cm.addImage(imageUrl);
                     } else {
                        uiManager.showToast("No active canvas. Please create a project first.");
                        return;
                     }
                } else {
                    try {
                        const preset = JSON.parse(selectedValue);
                        let isDefaultLandscape = false;
                        if (preset.w_px) { isDefaultLandscape = preset.w_px >= preset.h_px; } 
                        else if (preset.w_in) { isDefaultLandscape = preset.w_in >= preset.h_in; } 
                        else if (preset.w_cm) { isDefaultLandscape = preset.w_cm >= preset.h_cm; }
                        
                        uiManager.startEditorWithPreset(preset, isDefaultLandscape, imageUrl);
                    } catch(e) {
                        console.error("Error parsing preset value:", e);
                        uiManager.showToast("Could not create new canvas from selection.");
                        return;
                    }
                }
                
                aiImageModal.style.display = 'none';
            });

            // --- Floating Prompt Generator Logic ---
            const promptGeneratorPopup = document.getElementById('prompt-generator-popup');
            const promptDrawerToggle = document.getElementById('prompt-drawer-toggle');
            const closePromptGenerator = document.getElementById('close-prompt-generator');

            if (promptDrawerToggle) {
                promptDrawerToggle.addEventListener('click', () => {
                    promptGeneratorPopup.style.display = 'flex';
                });
            }
            if (closePromptGenerator) {
                closePromptGenerator.addEventListener('click', () => {
                    promptGeneratorPopup.style.display = 'none';
                });
            }
            if (promptGeneratorPopup) {
                // Close when clicking the overlay background
                promptGeneratorPopup.addEventListener('click', (e) => {
                    if (e.target === promptGeneratorPopup) {
                        promptGeneratorPopup.style.display = 'none';
                    }
                });
            }

            function initPromptGenerator() {
                // --- DATA LISTS ---
                const prompts = {
                    character: [
                        "cute girl", "cool boy", "sleepy cat", "energetic puppy", "mischievous fox", "wise owl", "brave lion cub", "shy bunny", "playful squirrel", "magical unicorn", "tiny dragon", "friendly robot", "curious alien", "spooky ghost", "grumpy gnome", "happy slime", "adventurous penguin", "artistic raccoon", "baker bear", "chef frog", "detective dog", "explorer hamster", "fashionista flamingo", "gardener giraffe", "hacker hedgehog", "ice cream loving narwhal", "jester jellyfish", "king koala", "lazy llama", "musician mouse", "ninja newt", "operator octopus", "pirate parrot", "queen bee", "rockstar rabbit", "scientist sloth", "teacher turtle", "umbrella bird", "vampire bat", "werewolf wolf", "yeti crab", "zombie zebra", "angelic axolotl", "bookworm butterfly", "captain corgi", "dancer dolphin", "electric eel", "firefighter ferret", "ghostly goldfish", "heroic horse", "inventor iguana", "juggler jaguar", "knight kitten", "librarian lemur", "mailman mole", "nurse nightingale", "officer otter", "pilot pigeon", "quarterback quail", "reporter raccoon", "surfer seal", "tourist tiger", "viking vole", "waiter walrus", "xylophonist xenops", "yodeler yak", "zookeeper zebra", "archaeologist armadillo", "barista bee", "carpenter capybara", "dj dingo", "electrician elephant", "farmer ferret", "geologist goat", "historian hippo", "illustrator ibis", "janitor jaguar", "karate koala", "lifeguard lobster", "magician meerkat", "novelist newt", "optometrist owl", "plumber platypus", "radiologist rhino", "sculptor sheep", "tailor tapir", "undertaker urial", "veterinarian vulture", "writer wolf", "yoga instructor yak"
                    ],
                    facialExpression: [
                        "a happy smile", "a mischievous grin", "a curious look", "a sleepy yawn", "a determined frown", "a surprised gasp", "a sad pout", "a confident smirk", "a shy blush", "an angry scowl", "a joyful laugh", "a bored expression", "a focused look", "a dreamy stare", "a cheeky wink", "puffed cheeks", "a content sigh", "an excited squeal", "a worried face", "a proud beam", "a silly face with tongue out", "a thoughtful hum", "eyes wide with wonder", "a knowing nod", "a facepalm expression", "a teary-eyed look", "a relieved smile", "a nervous gulp", "a look of pure determination", "a mischievous side-eye glance", "a serene and peaceful expression", "a face full of awe", "a smug and knowing look", "an apologetic smile", "a look of disbelief", "a face scrunched up in concentration", "a hearty laugh", "a sympathetic head tilt", "a skeptical raised eyebrow"
                    ],
                    promptStyles: {
                        font_vintage: "Vintage typography design, reminiscent of old signage and packaging. Features ornate details, distressed textures, and a warm, nostalgic color palette. Vector graphic.",
                        font_futuristic: "Futuristic, sci-fi inspired typography. Features clean, geometric lines, digital glitch effects, and a cool color palette of blues and purples with neon highlights. Vector art.",
                        font_playful: "Playful, hand-drawn lettering style. Features bubbly shapes, bright, cheerful colors, and whimsical doodle elements. Fun and energetic vibe. Vector graphic.",
                        font_elegant: "Elegant and luxurious typography. Features delicate, flowing lines, metallic textures like gold or silver, and a sophisticated, minimalist aesthetic. High-resolution vector.",
                        font_graffiti: "Urban graffiti art style. Features bold, overlapping letters, spray paint textures, and vibrant, high-contrast colors. Dynamic and edgy vibe. Vector graphic.",
                        font_artnouveau: "Art Nouveau typography with elegant, flowing, organic lines and floral motifs. Uses a muted, sophisticated color palette with gold accents. Intricate and decorative. Vector graphic.",
                        font_blackletter: "Classic Gothic blackletter calligraphy. Features sharp, angular lines, high contrast, and a traditional, historical feel. Ornate and dramatic. Vector graphic.",
                        font_3d: "Bold 3D block lettering. Features a strong sense of dimension, dramatic shadows, and a solid, impactful presence. Can be colorful or monochrome. High-resolution vector.",
                        font_liquid: "Liquid chrome or melting typography effect. Features smooth, reflective surfaces and a fluid, dynamic shape. Futuristic and surreal. High-resolution vector.",
                        font_woodcut: "Retro woodcut or linocut print style typography. Features rough, imperfect edges, strong black lines, and a handcrafted, analog feel. Vector graphic.",
                        font_neon: "Realistic neon sign effect. Features glowing tubes of light, a dark background to make the colors pop, and visible wiring for authenticity. Luminous and eye-catching.",
                        font_stitch: "Typography that appears to be stitched or embroidered onto fabric. Features visible thread textures, fabric background, and a cozy, handcrafted feel. High-resolution.",
                        font_bubble: "Fun, rounded bubble letter typography. Features soft, inflated shapes, glossy highlights, and a playful, friendly vibe. Often uses bright, cheerful colors. Vector graphic.",
                        font_floral: "Typography made of or decorated with flowers and vines. Features letters formed by intertwined petals, stems, and leaves. Natural, beautiful, and delicate. Vector graphic.",
                        certificate_classic: "An elegant, high-resolution graphic design asset pack. Features clean vector lines, luxurious textures, and a professional, prestigious aesthetic. The composition should be balanced and legible, suitable for high-quality printing.",
                        certificate_modern: "A modern, minimalist set of graphic elements. Features sharp geometric shapes, bold sans-serif typography, and a clean, corporate color palette. Focus on negative space and clarity. Vector art.",
                        certificate_vintage: "A vintage-inspired collection of design assets. Features ornate, hand-drawn filigree, serif fonts, and aged parchment textures. The aesthetic is reminiscent of 19th-century documents and diplomas. Sepia tones.",
                        certificate_playful: "A playful and colorful asset pack for fun awards. Features bright, chunky shapes, whimsical doodle elements, and friendly, rounded fonts. The vibe is celebratory, energetic, and informal.",
                        sticker: "separate with their own outlines, borders, and cuts for the characters and elements, designed as a kawaii sticker with unique cutout style that they don't intersect, background contained only inside the outlines, thick black outlines with minimal white border, white canvas, high resolution.",
                        popart: "Bright, vibrant anime-style illustration with a futuristic pop-art and K-pop inspired aesthetic. Use smooth, clean digital line art with glossy neon gradients, pastel accents, and glowing crystal effects. Add playful graphic elements like hearts, stars, and sparkles floating in the background. Place the design on a clean white or light backdrop with faint diagonal lines for texture. Include bold, modern gradient typography at the top for branding or logo space. Overall vibe is energetic, youthful, and eye-catching, blending anime, cyber-fantasy, and trendy streetwear design.",
                        watercolor: "Soft and gentle watercolor illustration with bleeding colors and delicate ink outlines. The background should be a light paper texture. The overall feel is dreamy, whimsical, and handcrafted. Use a pastel color palette.",
                        pixel: "Crisp 16-bit pixel art style. Use a limited, vibrant color palette with no anti-aliasing. Characters should have bold, simple outlines. The background should be a simple dithering pattern. Think retro video game sprite, high resolution.",
                        retro: "Retro 1950s cartoon style with bold, thick outlines and solid block colors. Add a subtle paper texture and grain effect over the whole image. The characters should have pie-eyes and rubber hose limbs. Energetic and nostalgic feel.",
                        gothic: "A 'pastel goth' or 'creepy cute' aesthetic. Combines cute chibi characters with gothic elements like bats, skulls, and dark colors, but using a pastel palette (lavender, mint green, baby pink). Add cute stitches and patterns. Spooky but adorable.",
                        minimalist: "Minimalist clean vector line art. Uses only a few colors and simple, geometric shapes. No background, just the characters and props on a solid white canvas. Focus on elegant curves and negative space.",
                        storybook: "Charming children's storybook illustration style. Use soft, textured brushes that mimic colored pencils or crayons. The lighting should be warm and inviting. A gentle, heartwarming, and classic feel.",
                        clay: "A cute 3D claymation style. The characters and objects should look like they are made of soft, smooth modeling clay with visible fingerprints and tool marks for a handcrafted feel. Soft, diffused lighting and shallow depth of field, like a stop-motion movie set.",
                        vaporwave: "Vaporwave aesthetic with neon pinks and blues, checkerboard patterns, and Greco-Roman statue elements. Add glitch effects and 90s internet iconography. A surreal, nostalgic, and dreamy vibe.",
                        nouveau: "Art Nouveau inspired illustration with elegant, flowing, organic lines and floral motifs. Use a muted, sophisticated color palette with gold accents. Intricate and decorative.",
                        ukiyo: "Japanese Ukiyo-e woodblock print style. Flat areas of color, bold outlines, and patterns inspired by traditional Japanese art. A sense of calm, beauty, and history.",
                        steampunk: "Steampunk style, featuring gears, cogs, brass, and copper elements. Characters wear Victorian-era clothing mixed with mechanical gadgets. A blend of historical and futuristic.",
                        cyberpunk: "Cyberpunk chibi style with neon lights, futuristic cityscapes, and cybernetic enhancements. A dark color palette with bright, glowing neon highlights. High-tech and gritty.",
                        doodle: "A busy, chaotic doodle art style. The character is surrounded by lots of small, fun, hand-drawn elements and patterns. Black and white with small pops of color. Looks like a page from a sketchbook.",
                        stainedglass: "Stained glass window effect with bold black lines separating segments of vibrant, glowing color. The light should appear to shine through the character. Luminous and decorative."
                    },
                    themes: {
                        // For each theme, 'pose' is for single characters, 'interaction' is for groups.
                        House: {
                            outfit: ["comfy pajamas", "a cozy sweater", "casual t-shirt and shorts", "a fluffy bathrobe", "gardening overalls", "an apron", "slippers shaped like animals", "a onesie", "an oversized hoodie", "flannel pajama pants", "a silk robe"],
                            pose: ["watering plants", "watching TV on the sofa", "dusting furniture", "reading a book in a comfy chair", "building a pillow fort", "doing laundry", "sorting socks", "vacuuming the rug", "baking cookies", "rearranging photo frames"],
                            interaction: ["playing a board game together", "co-building a pillow fort", "cooking a meal together", "arguing over the TV remote", "doing chores together", "watching a scary movie together", "untangling Christmas lights", "assembling IKEA furniture"],
                            prop: ["a steaming mug", "a potted plant", "a TV remote", "a fluffy blanket", "a stack of books", "a feather duster", "a laundry basket", "a cozy armchair", "a plate of warm cookies", "a watering can", "a ball of yarn"]
                        },
                        MorningRoutine: {
                            outfit: ["pajamas", "a bathrobe", "a towel wrap", "an oversized t-shirt", "matching workout clothes", "a silk robe", "a sleep mask on their forehead"],
                            pose: ["brushing teeth", "yawning widely", "stretching happily", "making coffee", "looking in the mirror", "meditating peacefully", "hitting the snooze button", "pouring cereal", "trying to find matching socks"],
                            interaction: ["racing to the bathroom", "making breakfast for each other", "exercising together in the living room", "helping each other pick outfits", "fighting over the blanket", "sharing a newspaper"],
                            prop: ["a toothbrush", "an alarm clock", "a coffee machine", "a bowl of cereal", "a tube of toothpaste", "a yoga mat", "a steaming cup of tea", "a messy bed", "a pair of glasses", "a smartphone scrolling news"]
                        },
                        Cooking: {
                            outfit: ["a chef's apron and hat", "matching baker's uniforms", "a stained t-shirt", "casual home clothes", "an oven mitt", "a bandana holding hair back"],
                            pose: ["chopping vegetables", "stirring a pot", "flipping a pancake", "decorating a cake", "tasting food from a spoon", "kneading dough", "reading a recipe with a confused look", "cracking an egg perfectly"],
                            interaction: ["having a flour fight", "decorating a large cake together", "following a recipe as a team", "taste-testing each other's creations", "making a mess in the kitchen", "doing the dishes together"],
                            prop: ["a rolling pin", "a cookbook", "a whisk", "a steaming pot", "a beautifully decorated cake", "a cutting board", "a stack of clean plates", "a sizzling frying pan", "a spice rack", "measuring cups"]
                        },
                        Hobbies: {
                            outfit: ["matching painter's smocks", "comfy knitting sweaters", "rockstar t-shirts", "gardening gloves and boots", "a photographer's vest", "a comfy reading robe"],
                            pose: ["painting on a canvas", "knitting a scarf", "playing a guitar", "building with LEGOs", "taking a photo", "writing in a journal", "sculpting with clay", "doing a magic trick"],
                            interaction: ["painting a portrait of each other", "playing a musical duet", "building a large LEGO castle together", "collaborating on a puzzle", "gardening side-by-side", "reviewing each other's photography"],
                            prop: ["an easel", "a ball of yarn", "an electric guitar", "a camera", "a half-finished puzzle", "a fountain pen", "a beautiful bouquet", "a pottery wheel", "a model airplane", "a stamp collection book"]
                        },
                        Fitness: {
                            outfit: ["matching workout outfits", "yoga outfits", "a sweat suit", "runner's gear", "a sweatband", "matching sports jerseys", "a retro aerobics leotard"],
                            pose: ["lifting a tiny dumbbell", "doing a yoga pose", "jogging in place", "drinking from a water bottle", "jumping rope", "flexing muscles in a mirror", "looking exhausted on a treadmill"],
                            interaction: ["spotting each other while lifting weights", "doing partner yoga poses", "racing each other on treadmills", "passing a medicine ball back and forth", "stretching together", "having a push-up contest"],
                            prop: ["a yoga mat", "a water bottle", "a jump rope", "a dumbbell", "a stopwatch", "a soccer ball", "a kettlebell", "a resistance band", "a smoothie in a shaker bottle", "a fitness tracker watch"]
                        },
                        Bedtime: {
                            outfit: ["matching pajamas with cute patterns", "long nightgowns", "sleeping caps", "fluffy slippers", "oversized sleep shirts", "a onesie with animal ears"],
                            pose: ["reading a bedtime story", "hugging a teddy bear", "holding a night light", "sleepwalking", "dreaming of stars", "counting sheep", "falling out of bed", "pulling the covers up high"],
                            interaction: ["having a pillow fight", "reading a bedtime story to each other", "sharing a bed", "telling scary stories under the covers", "building a blanket fort", "trying to steal the blanket from each other"],
                            prop: ["a bedtime story book", "a teddy bear", "a glass of milk", "a crescent moon", "a trail of Z's", "a soft pillow", "a flock of fluffy sheep", "a dream catcher", "a glowing star projector"]
                        },
                        School: {
                            outfit: ["school uniforms", "nerdy sweater vests", "matching gym class clothes", "science lab coats", "art class smocks", "a hall monitor's sash", "a graduation cap and gown"],
                            pose: ["sitting at a desk", "raising a hand in class", "writing on a chalkboard", "doing a science experiment", "reading a textbook", "doodling in a notebook", "falling asleep in class"],
                            interaction: ["passing notes in class", "working on a group project", "sharing a lunch at a table", "playing on the swings together", "cheating on a test", "decorating a locker together"],
                            prop: ["a stack of books", "a giant pencil", "a backpack", "a bubbling beaker", "an apple for the teacher", "a school bus", "a globe", "a paper airplane", "a report card with all A's", "a spitball"]
                        },
                        Office: {
                            outfit: ["business suits", "casual friday outfits", "matching company polos", "smart blouses and skirts", "an intern's oversized suit", "a 'World's Best Boss' t-shirt"],
                            pose: ["typing on a laptop", "on a video call", "presenting a chart", "looking stressed with paperwork", "sipping coffee", "photocopying their face", "staring blankly at a screen"],
                            interaction: ["gossiping by the water cooler", "collaborating on a whiteboard", "having a meeting in a conference room", "complaining about the boss", "sharing a box of donuts", "having a swivel chair race"],
                            prop: ["a laptop", "a briefcase", "a pile of documents", "a coffee mug with a funny slogan", "a headset", "a stapler in jello", "a whiteboard with diagrams", "a water cooler", "a motivational cat poster"]
                        },
                        Canteen: {
                            outfit: ["school uniforms", "casual work clothes", "a lunch lady's apron and hairnet", "a visitor's badge"],
                            pose: ["carrying a lunch tray", "choosing food from the counter", "complaining about the food", "balancing a tray piled high with food", "trying to open a milk carton"],
                            interaction: ["sitting at a long table eating together", "trading food items", "starting a food fight", "sharing a dessert", "comparing lunches", "saving a seat for a friend"],
                            prop: ["a plastic lunch tray", "a carton of milk", "a mysterious casserole", "a vending machine", "a jello cup", "a spork", "a single green bean", "a pile of tater tots"]
                        },
                        Cafe: {
                            outfit: ["a barista's apron", "trendy casual outfits", "cozy sweaters", "a writer's tweed jacket", "a beatnik's turtleneck and beret", "a student's hoodie"],
                            pose: ["sipping a latte", "working on a laptop", "reading a book", "drawing in a sketchbook", "people-watching out the window", "writing furiously in a journal"],
                            interaction: ["chatting over coffee", "sharing a dessert", "studying together", "on a coffee date", "co-writing a story on a laptop", "ignoring each other while on their phones"],
                            prop: ["a steaming cup of coffee with latte art", "a croissant on a plate", "a laptop with stickers", "an open book", "two straws in one milkshake", "a slice of cake", "a sugar dispenser", "a stack of napkins"]
                        },
                        Bar: {
                            outfit: ["a bartender's vest and bowtie", "stylish evening dresses", "cool leather jackets", "casual t-shirts for a dive bar", "a bouncer's all-black outfit", "a musician's band t-shirt"],
                            pose: ["mixing a colorful cocktail", "leaning against the bar", "playing pool", "singing karaoke badly", "throwing darts", "looking cool and mysterious in a corner"],
                            interaction: ["laughing with friends at a table", "listening to a live band together", "playing a game of darts", "cheers-ing with drinks", "dancing together", "arm wrestling at a table"],
                            prop: ["a cocktail shaker", "a glowing neon sign", "a bowl of pretzels", "a pool table with balls", "a microphone on a stand", "a jukebox", "a dartboard", "a fancy-looking cocktail with a tiny umbrella"]
                        },
                        Shopping: {
                            outfit: ["stylish dresses", "matching hoodies", "fancy hats", "trendy jackets", "comfortable walking shoes", "a shirt with a shopping pun"],
                            pose: ["holding many shopping bags", "pushing a shopping cart", "looking at a price tag with shock", "trying on a hat", "getting lost in a clothing rack", "examining a product closely"],
                            interaction: ["helping each other pick out outfits", "fighting over the last item on sale", "sharing a giant pretzel in the food court", "getting tangled in clothing racks", "comparing prices on their phones"],
                            prop: ["colorful shopping bags", "a shopping cart full of groceries", "a designer handbag", "a giant pretzel", "a credit card", "a mannequin", "a '50% OFF' sign", "a long receipt", "a barcode scanner"]
                        },
                        Game: {
                            outfit: ["matching gamer hoodies", "VR headsets", "t-shirts of a favorite game", "esports team jerseys", "cosplay of game characters", "a wizard robe for a tabletop RPG"],
                            pose: ["holding a game controller", "staring intensely at a screen", "rolling dice for a board game", "rage-quitting", "celebrating a victory", "looking at a strategy guide"],
                            interaction: ["playing a competitive video game", "co-op gaming on the same couch", "playing a board game together", "high-fiving after a win", "arguing about the rules", "sharing a strategy guide"],
                            prop: ["glowing game controllers", "gaming headsets", "a D20 die", "a virtual reality landscape", "a stack of board games", "a shared bowl of snacks", "a pizza box", "a character sheet", "a pile of meeples"]
                        },
                        CityLife: {
                            outfit: ["trench coats", "touristy t-shirts", "business suits", "street performer costumes", "messenger bags", "a delivery person's uniform"],
                            pose: ["waiting for a bus", "hailing a taxi", "looking up at a skyscraper", "eating street food", "taking a photo of a landmark", "looking at a subway map"],
                            interaction: ["taking a selfie together", "sharing an umbrella in the rain", "navigating with a large map", "watching a street performer together", "chasing pigeons", "getting caught in a crowd"],
                            prop: ["a subway map", "a yellow taxi cab", "a hot dog from a street vendor", "a skyline of tall buildings", "a shared pair of headphones", "a traffic light", "a flock of pigeons", "a street sign", "a disposable camera"]
                        },
                        BeachDay: {
                            outfit: ["swimsuits", "sunglasses and sun hats", "surfer's rash guards", "flowy beach cover-ups", "a lifeguard's uniform", "a shirt that says 'Beach Bum'"],
                            pose: ["building a sandcastle", "holding a surfboard", "collecting seashells", "relaxing under an umbrella", "applying sunscreen", "looking for crabs under rocks"],
                            interaction: ["playing beach volleyball", "building a giant sandcastle together", "burying one person in the sand", "splashing each other in the water", "sharing a beach towel", "having a picnic on a blanket"],
                            prop: ["a sandcastle", "a surfboard", "a colorful beach umbrella", "a bucket and spade", "a melting popsicle", "a message in a bottle", "a friendly crab", "a beach ball", "a cooler full of drinks", "a pair of flip-flops"]
                        },
                        Nature: {
                            outfit: ["hiker's backpacks and boots", "park ranger uniforms", "flower crowns", "fishing vests", "matching raincoats", "a beekeeper's suit", "a birdwatcher's vest"],
                            pose: ["sitting on a mushroom", "hugging a tree", "watching butterflies", "fishing in a pond", "identifying a plant with a field guide", "roasting a marshmallow"],
                            interaction: ["roasting marshmallows over a campfire", "paddling a canoe together", "helping each other climb a small rock", "birdwatching with binoculars", "setting up a tent", "following a trail map together"],
                            prop: ["a trail map", "a friendly butterfly", "a fishing rod", "a campfire with marshmallows", "a telescope pointing at stars", "a compass", "a canoe with two paddles", "a tent", "a pair of binoculars", "a s'more"]
                        },
                        Sports: {
                            outfit: ["matching basketball jerseys", "soccer uniforms", "tennis outfits", "full baseball uniforms", "karate gis", "a referee uniform", "a figure skating costume"],
                            pose: ["dribbling a basketball", "kicking a soccer ball", "swinging a tennis racket", "hitting a baseball with a bat", "striking a karate pose", "balancing on a balance beam"],
                            interaction: ["playing a 1-on-1 basketball game", "passing a soccer ball back and forth", "playing a doubles tennis match", "celebrating a victory together", "competing against each other", "forming a human pyramid"],
                            prop: ["a basketball hoop", "a soccer goal", "a tennis net", "a baseball glove", "a shiny gold medal", "a large trophy", "a glowing scoreboard", "a referee's whistle", "a foam finger", "a bottle of sports drink"]
                        },
                        OnTheRoad: {
                            outfit: ["race car driver suits", "matching cyclist jerseys and helmets", "motorcyclist leather jackets", "trucker hats", "a road trip t-shirt", "a mechanic's overalls"],
                            pose: ["driving a convertible with the top down", "happily riding a bicycle down a path", "leaning against a cool motorcycle", "changing a flat tire", "singing along to the radio"],
                            interaction: ["on a road trip in a van", "racing each other in go-karts", "riding a tandem bicycle", "pushing a broken-down car together", "arguing over a road map", "taking turns driving"],
                            prop: ["a classic convertible car", "a tandem bicycle", "a vintage scooter", "a monster truck", "a winding road map", "a bright orange traffic cone", "a retro gas pump", "a 'Welcome to...' city sign", "a pair of fuzzy dice", "a pile of luggage"]
                        },
                        Fantasy: {
                            outfit: ["a knight protecting a mage", "elven tunics", "matching fairy petal dresses", "rogue's leather gear", "a king's royal robes", "a witch's pointy hat and robes"],
                            pose: ["wielding a glowing sword", "casting a magic spell", "riding a griffin", "consulting an ancient map", "polishing armor", "reading from a spellbook"],
                            interaction: ["fighting a dragon together", "brewing a potion in a large cauldron", "exploring a dungeon as a party", "a knight and a princess holding hands", "two wizards in a magic duel", "bartering with a goblin merchant"],
                            prop: ["a treasure chest", "an ancient scroll", "a fairy companion", "a bubbling cauldron", "a castle in the background", "a crystal ball", "a powerful staff", "a giant dragon", "a glowing potion bottle", "a mimic disguised as a chest"]
                        },
                        SciFi: {
                            outfit: ["futuristic jumpsuits", "space ranger suits", "alien costumes", "mad scientist lab coats", "a starship captain's uniform", "a cyborg's metallic limbs"],
                            pose: ["piloting a small spaceship", "holding a laser gun", "interacting with a holographic map", "floating in zero gravity", "analyzing a strange alien artifact", "pressing a big red button"],
                            interaction: ["co-piloting a spaceship", "fighting back-to-back against aliens", "repairing a friendly droid together", "exploring a strange new planet", "beaming down from a teleporter", "arguing with a ship's AI"],
                            prop: ["a robot pet", "a UFO in the sky", "a strange, glowing planet", "a holographic interface", "a laser blaster", "a team of friendly aliens", "a portal to another dimension", "a friendly droid", "a test tube with glowing liquid"]
                        },
                        Certificate: {
                            frames: ["a delicate, thin-line filigree border", "a thick, geometric Art Deco frame", "a border of intertwined Celtic knotwork", "a minimalist double-line border", "a frame of realistic, blooming roses", "a whimsical border of stars and moons", "a prestigious border of oak leaves and acorns", "a modern, abstract geometric pattern border", "a hand-drawn, sketchy floral border", "a border made of repeating laurel wreath icons", "an ornate, baroque-style frame with heavy flourishes", "a simple, elegant dotted line border"],
                            decorations: ["ornate acanthus leaf corner flourishes", "minimalist gold line art in the corners", "subtle, abstract watercolor splashes in the background", "a faint guilloche pattern overlay", "a background of interlocking hexagons", "playful confetti shapes scattered in the background", "a subtle watermark of a lion's head", "elegant Art Nouveau corner decorations", "a starburst pattern radiating from the center", "tiny, decorative fleur-de-lis icons as separators", "a clean, textured paper background", "a background pattern of mathematical equations"],
                            seals_ribbons: ["a large, official gold foil seal in the bottom center", "a flowing, folded blue ribbon in the top-left corner", "a realistic red wax seal with a custom initial", "a silver embossed medal emblem", "a colorful, striped ribbon banner at the top", "a simple, elegant 'First Place' blue ribbon", "a modern, circular emblem with the year", "a complex, multi-layered ribbon rosette", "no seal, just clean typography", "a small, iconic torch emblem for knowledge", "a heraldic crest representing an institution", "a banner that reads 'Excellence'"]
                        },
                        Fonts: {
                            font_family: ["a clean sans-serif font", "an elegant serif font", "a playful script font", "a bold, slab-serif font", "a futuristic, digital font", "a classic, calligraphic font", "a heavy, blackletter font", "a whimsical, hand-drawn font", "a condensed, tall font", "a wide, extended font", "a monospaced, typewriter font"],
                            font_style: ["with a heavy, impactful weight", "in a light, airy style", "with a metallic gold texture", "with a glossy, liquid effect", "made of carved stone", "with a neon glow effect", "in a distressed, grunge style", "with a 3D bevel effect", "with a subtle letterpress texture", "filled with a colorful gradient", "with a clean, minimalist outline"],
                            decorations: ["adorned with floral flourishes", "surrounded by geometric shapes", "with flowing, elegant swashes", "entwined with thorny vines", "with sparks and stars coming off it", "encased in a block of ice", "with dripping, liquid paint details", "integrated with mechanical gears and cogs", "with a long, dramatic shadow", "with birds flying around it", "wreathed in flames"]
                        }
                    }
                };

                // --- DOM ELEMENTS ---
                const characterInput = document.getElementById('character-input');
                const characterLabel = document.getElementById('character-label');
                const themeSelect = document.getElementById('theme-select');
                const themeSelectorWrapper = document.getElementById('theme-selector-wrapper');
                const styleSelect = document.getElementById('style-select');
                const generateBtn = document.getElementById('generate-btn');
                const shuffleBtn = document.getElementById('shuffle-btn');
                const shuffleStyleBtn = document.getElementById('shuffle-style-btn');
                const promptOutput = document.getElementById('prompt-output');
                const copyBtn = document.getElementById('copy-btn');
                const usePromptBtn = document.getElementById('use-prompt-btn');
                const promptTypeRadios = document.querySelectorAll('input[name="prompt-type"]');
                const customStyleInput = document.getElementById('custom-style-input');


                let lastSubject = '';
                let lastFullPrompt = '';

                // --- FUNCTIONS ---
                function getRandomElement(arr) {
                    return arr[Math.floor(Math.random() * arr.length)];
                }

                function generatePrompt(isShuffle = false) {
                    const promptMode = document.querySelector('input[name="prompt-type"]:checked').value;
                    
                    let fullPrompt = '';
                    const styleEnding = customStyleInput.value.trim();

                    if (promptMode === 'certificate') {
                        const themeData = prompts.themes.Certificate;
                        
                        const frame = getRandomElement(themeData.frames);
                        const decoration = getRandomElement(themeData.decorations);
                        const sealRibbon = getRandomElement(themeData.seals_ribbons);
                        
                        fullPrompt = `A collection of decorative elements for a certificate, featuring: ${frame}, ${decoration}, and ${sealRibbon}. All elements are isolated on a plain white background for easy selection and chroma keying. ${styleEnding}`;

                    } else if (promptMode === 'font') {
                        const themeData = prompts.themes.Fonts;
                        const customText = characterInput.value.trim();

                        let text = '';
                        if (isShuffle) {
                            text = customText || lastSubject;
                        } else {
                            text = customText || "Typography";
                            if (!customText) {
                                lastSubject = text;
                            }
                        }

                        const fontFamily = getRandomElement(themeData.font_family);
                        const fontStyle = getRandomElement(themeData.font_style);
                        const fontDecoration = getRandomElement(themeData.decorations);
                        
                        fullPrompt = `Typography design for the text '${text}', featuring ${fontFamily}, ${fontStyle}, ${fontDecoration}. All elements isolated on a plain white background for easy cutout. ${styleEnding}`;


                    } else { // Handle Single and Group modes
                        const selectedTheme = themeSelect.value;
                        const themeData = prompts.themes[selectedTheme];
                        const customCharacter = characterInput.value.trim();
                        
                        const expression = getRandomElement(prompts.facialExpression);
                        const outfit = getRandomElement(themeData.outfit);
                        const prop = getRandomElement(themeData.prop);
                        
                        let character = '';
                        let action = '';

                         if (isShuffle) {
                            character = customCharacter || lastSubject;
                        } else {
                            if (promptMode === 'group') {
                                character = customCharacter || (getRandomElement(prompts.character) + ' and ' + getRandomElement(prompts.character));
                            } else {
                                character = customCharacter || getRandomElement(prompts.character);
                            }
                            if (!customCharacter) {
                                lastSubject = character;
                            }
                        }
                        
                        if (promptMode === 'group') {
                            action = getRandomElement(themeData.interaction);
                        } else {
                            action = getRandomElement(themeData.pose);
                        }
                        fullPrompt = `Chibi ${character} with ${expression}, in ${outfit}, ${action}, ${prop}, ${styleEnding}`;
                    }

                    promptOutput.textContent = fullPrompt;
                    lastFullPrompt = fullPrompt;
                }

                function generateStyle() {
                    const styleKeys = Object.keys(prompts.promptStyles);
                    const randomStyleKey = getRandomElement(styleKeys);
                    styleSelect.value = randomStyleKey;
                    updateStyleEditor();
                    generatePrompt(true); // Re-generate with the new style immediately
                }
                
                function copyPrompt() {
                    const textToCopy = promptOutput.textContent;
                    const textArea = document.createElement('textarea');
                    textArea.value = textToCopy;
                    textArea.style.top = "0";
                    textArea.style.left = "0";
                    textArea.style.position = 'fixed';
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        const successful = document.execCommand('copy');
                        if (successful) {
                            showCopyFeedback();
                        }
                    } catch (err) {
                        console.error('Fallback: Oops, unable to copy', err);
                    }
                    document.body.removeChild(textArea);
                }
                
                function showCopyFeedback() {
                    const originalText = copyBtn.textContent;
                    copyBtn.textContent = 'Copied!';
                    copyBtn.classList.add('bg-green-500');
                    setTimeout(() => {
                        copyBtn.textContent = originalText;
                        copyBtn.classList.remove('bg-green-500');
                    }, 2000);
                }
                
                function updateUIMode() {
                    const promptMode = document.querySelector('input[name="prompt-type"]:checked').value;

                    if (promptMode === 'certificate') {
                        themeSelectorWrapper.style.display = 'none';
                        characterLabel.style.display = 'none';
                        characterInput.style.display = 'none';
                        const currentStyle = styleSelect.value;
                        if (!currentStyle.startsWith('certificate_')) {
                            styleSelect.value = 'certificate_classic';
                        }
                    } else if (promptMode === 'font') {
                        themeSelectorWrapper.style.display = 'none';
                        characterLabel.style.display = 'block';
                        characterInput.style.display = 'block';
                        characterLabel.textContent = 'CUSTOM TEXT (OPTIONAL)';
                        characterInput.placeholder = "e.g., 'Hello World', 'Victory'";
                        const currentStyle = styleSelect.value;
                        if (!currentStyle.startsWith('font_')) {
                            styleSelect.value = 'font_vintage';
                        }
                    } else {
                        themeSelectorWrapper.style.display = 'block';
                        characterLabel.style.display = 'block';
                        characterInput.style.display = 'block';
                        characterLabel.textContent = 'CUSTOM SUBJECT (OPTIONAL)';
                        if (styleSelect.value.startsWith('certificate_') || styleSelect.value.startsWith('font_')) {
                            styleSelect.value = 'sticker';
                        }
                        if (promptMode === 'group') {
                            characterInput.placeholder = "e.g., 'two friendly robots', 'a cat and a dog'";
                        } else {
                            characterInput.placeholder = "e.g., 'a smiling red panda', 'my OC Luna'";
                        }
                    }
                    updateStyleEditor();
                }
                
                function updateStyleEditor() {
                    const selectedStyleValue = styleSelect.value;
                    if (selectedStyleValue !== 'custom') {
                        customStyleInput.value = prompts.promptStyles[selectedStyleValue] || '';
                    }
                }

                // --- EVENT LISTENERS ---
                generateBtn.addEventListener('click', () => generatePrompt(false));
                shuffleBtn.addEventListener('click', () => generatePrompt(true));
                shuffleStyleBtn.addEventListener('click', generateStyle);
                copyBtn.addEventListener('click', copyPrompt);
                
                usePromptBtn.addEventListener('click', () => {
                    const promptText = promptOutput.textContent;
                    if (promptText && promptText.trim().length > 0 && lastFullPrompt) {
                        document.getElementById('aiImagePrompt').value = promptText;
                        document.getElementById('aiImageModal').style.display = 'flex';
                        promptGeneratorPopup.style.display = 'none';
                        uiManager.showToast('Prompt sent to AI Studio!');
                    } else {
                        uiManager.showToast('Generate a prompt first!');
                    }
                });

                promptTypeRadios.forEach(radio => {
                    radio.addEventListener('change', () => {
                        updateUIMode();
                        generatePrompt(false); // Generate a new prompt when mode changes
                    });
                });
                styleSelect.addEventListener('change', () => {
                    updateStyleEditor();
                    generatePrompt(true); // Regenerate with new style
                });


                // --- INITIALIZATION ---
                updateStyleEditor();
                updateUIMode();
                generatePrompt(false);
            }

            initPromptGenerator();
        };
    </script>
</body>
</html>

